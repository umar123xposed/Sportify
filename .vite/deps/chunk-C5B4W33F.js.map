{
  "version": 3,
  "sources": ["../../node_modules/@apollo/src/link/http/iterators/async.ts", "../../node_modules/@apollo/src/link/http/iterators/nodeStream.ts", "../../node_modules/@apollo/src/link/http/iterators/promise.ts", "../../node_modules/@apollo/src/link/http/iterators/reader.ts", "../../node_modules/@apollo/src/link/http/responseIterator.ts", "../../node_modules/@apollo/src/link/http/parseAndCheckHttpResponse.ts", "../../node_modules/@apollo/src/link/http/serializeFetchParameter.ts", "../../node_modules/@apollo/src/link/http/selectHttpOptionsAndBody.ts", "../../node_modules/@apollo/src/link/http/checkFetcher.ts", "../../node_modules/@apollo/src/link/http/createSignalIfSupported.ts", "../../node_modules/@apollo/src/link/http/selectURI.ts", "../../node_modules/@apollo/src/link/http/rewriteURIForGET.ts", "../../node_modules/@apollo/src/link/http/createHttpLink.ts", "../../node_modules/@apollo/src/link/http/HttpLink.ts", "../../node_modules/@apollo/src/link/http/index.ts", "../../node_modules/@wry/equality/src/index.ts", "../../node_modules/@apollo/src/core/equalByQuery.ts", "../../node_modules/@apollo/src/masking/utils.ts", "../../node_modules/@apollo/src/masking/maskDefinition.ts", "../../node_modules/@apollo/src/masking/maskFragment.ts", "../../node_modules/@apollo/src/masking/maskOperation.ts", "../../node_modules/@apollo/src/masking/index.ts", "../../node_modules/@apollo/src/cache/core/cache.ts", "../../node_modules/@apollo/src/cache/core/types/Cache.ts", "../../node_modules/@apollo/src/cache/core/types/common.ts", "../../node_modules/@apollo/src/cache/inmemory/helpers.ts", "../../node_modules/@apollo/src/cache/inmemory/reactiveVars.ts", "../../node_modules/@apollo/src/cache/inmemory/entityStore.ts", "../../node_modules/@apollo/src/cache/inmemory/object-canon.ts", "../../node_modules/@apollo/src/cache/inmemory/readFromStore.ts", "../../node_modules/@apollo/src/cache/inmemory/key-extractor.ts", "../../node_modules/@apollo/src/cache/inmemory/policies.ts", "../../node_modules/@apollo/src/cache/inmemory/writeToStore.ts", "../../node_modules/@apollo/src/cache/inmemory/inMemoryCache.ts", "../../node_modules/@apollo/src/cache/inmemory/fragmentRegistry.ts", "../../node_modules/@apollo/src/cache/index.ts", "../../node_modules/@apollo/src/core/networkStatus.ts", "../../node_modules/@apollo/src/core/ObservableQuery.ts", "../../node_modules/@apollo/src/core/QueryInfo.ts", "../../node_modules/@apollo/src/core/QueryManager.ts", "../../node_modules/@apollo/src/core/LocalState.ts", "../../node_modules/@apollo/src/core/ApolloClient.ts", "../../node_modules/graphql-tag/src/index.ts", "../../node_modules/@apollo/src/core/index.ts"],
  "sourcesContent": ["/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/async.ts\n */\n\nexport default function asyncIterator<T>(\n  source: AsyncIterableIterator<T>\n): AsyncIterableIterator<T> {\n  const iterator = source[Symbol.asyncIterator]();\n  return {\n    next(): Promise<IteratorResult<T, boolean>> {\n      return iterator.next();\n    },\n    [Symbol.asyncIterator](): AsyncIterableIterator<T> {\n      return this;\n    },\n  };\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/nodeStream.ts\n */\n\nimport type { Readable as NodeReadableStream } from \"stream\";\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\n\ninterface NodeStreamIterator<T> {\n  next(): Promise<IteratorResult<T, boolean | undefined>>;\n  [Symbol.asyncIterator]?(): AsyncIterator<T>;\n}\n\nexport default function nodeStreamIterator<T>(\n  stream: NodeReadableStream\n): AsyncIterableIterator<T> {\n  let cleanup: (() => void) | null = null;\n  let error: Error | null = null;\n  let done = false;\n  const data: unknown[] = [];\n\n  const waiting: [\n    (\n      value:\n        | IteratorResult<T, boolean | undefined>\n        | PromiseLike<IteratorResult<T, boolean | undefined>>\n    ) => void,\n    (reason?: any) => void,\n  ][] = [];\n\n  function onData(chunk: any) {\n    if (error) return;\n    if (waiting.length) {\n      const shiftedArr = waiting.shift();\n      if (Array.isArray(shiftedArr) && shiftedArr[0]) {\n        return shiftedArr[0]({ value: chunk, done: false });\n      }\n    }\n    data.push(chunk);\n  }\n  function onError(err: Error) {\n    error = err;\n    const all = waiting.slice();\n    all.forEach(function (pair) {\n      pair[1](err);\n    });\n    !cleanup || cleanup();\n  }\n  function onEnd() {\n    done = true;\n    const all = waiting.slice();\n    all.forEach(function (pair) {\n      pair[0]({ value: undefined, done: true });\n    });\n    !cleanup || cleanup();\n  }\n\n  cleanup = function () {\n    cleanup = null;\n    stream.removeListener(\"data\", onData);\n    stream.removeListener(\"error\", onError);\n    stream.removeListener(\"end\", onEnd);\n    stream.removeListener(\"finish\", onEnd);\n    stream.removeListener(\"close\", onEnd);\n  };\n  stream.on(\"data\", onData);\n  stream.on(\"error\", onError);\n  stream.on(\"end\", onEnd);\n  stream.on(\"finish\", onEnd);\n  stream.on(\"close\", onEnd);\n\n  function getNext(): Promise<IteratorResult<T, boolean | undefined>> {\n    return new Promise(function (resolve, reject) {\n      if (error) return reject(error);\n      if (data.length)\n        return resolve({ value: data.shift() as T, done: false });\n      if (done) return resolve({ value: undefined, done: true });\n      waiting.push([resolve, reject]);\n    });\n  }\n\n  const iterator: NodeStreamIterator<T> = {\n    next(): Promise<IteratorResult<T, boolean | undefined>> {\n      return getNext();\n    },\n  };\n\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function (): AsyncIterator<T> {\n      return this;\n    };\n  }\n\n  return iterator as AsyncIterableIterator<T>;\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/promise.ts\n */\n\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\n\ninterface PromiseIterator<T> {\n  next(): Promise<IteratorResult<T, ArrayBuffer | undefined>>;\n  [Symbol.asyncIterator]?(): AsyncIterator<T>;\n}\n\nexport default function promiseIterator<T = ArrayBuffer>(\n  promise: Promise<ArrayBuffer>\n): AsyncIterableIterator<T> {\n  let resolved = false;\n\n  const iterator: PromiseIterator<T> = {\n    next(): Promise<IteratorResult<T, ArrayBuffer | undefined>> {\n      if (resolved)\n        return Promise.resolve({\n          value: undefined,\n          done: true,\n        });\n      resolved = true;\n      return new Promise(function (resolve, reject) {\n        promise\n          .then(function (value) {\n            resolve({ value: value as unknown as T, done: false });\n          })\n          .catch(reject);\n      });\n    },\n  };\n\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function (): AsyncIterator<T> {\n      return this;\n    };\n  }\n\n  return iterator as AsyncIterableIterator<T>;\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/reader.ts\n */\n\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\n\ninterface ReaderIterator<T> {\n  next(): Promise<IteratorResult<T, T | undefined>>;\n  [Symbol.asyncIterator]?(): AsyncIterator<T>;\n}\n\nexport default function readerIterator<T>(\n  reader: ReadableStreamDefaultReader<T>\n): AsyncIterableIterator<T> {\n  const iterator: ReaderIterator<T> = {\n    next() {\n      return reader.read() as Promise<\n        | ReadableStreamReadValueResult<T>\n        // DoneResult has `value` optional, which doesn't comply with an\n        // `IteratorResult`, so we assert it to `T | undefined` instead\n        | Required<ReadableStreamReadDoneResult<T | undefined>>\n      >;\n    },\n  };\n\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function (): AsyncIterator<\n      T,\n      T | undefined\n    > {\n      return this;\n    };\n  }\n\n  return iterator as AsyncIterableIterator<T>;\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/index.ts\n */\n\nimport type { Response as NodeResponse } from \"node-fetch\";\nimport type { Readable as NodeReadableStream } from \"stream\";\nimport { canUseAsyncIteratorSymbol } from \"../../utilities/index.js\";\n\nimport asyncIterator from \"./iterators/async.js\";\nimport nodeStreamIterator from \"./iterators/nodeStream.js\";\nimport promiseIterator from \"./iterators/promise.js\";\nimport readerIterator from \"./iterators/reader.js\";\n\nfunction isNodeResponse(value: any): value is NodeResponse {\n  return !!(value as NodeResponse).body;\n}\n\nfunction isReadableStream(value: any): value is ReadableStream<any> {\n  return !!(value as ReadableStream<any>).getReader;\n}\n\nfunction isAsyncIterableIterator(\n  value: any\n): value is AsyncIterableIterator<any> {\n  return !!(\n    canUseAsyncIteratorSymbol &&\n    (value as AsyncIterableIterator<any>)[Symbol.asyncIterator]\n  );\n}\n\nfunction isStreamableBlob(value: any): value is Blob {\n  return !!(value as Blob).stream;\n}\n\nfunction isBlob(value: any): value is Blob {\n  return !!(value as Blob).arrayBuffer;\n}\n\nfunction isNodeReadableStream(value: any): value is NodeReadableStream {\n  return !!(value as NodeReadableStream).pipe;\n}\n\nexport function responseIterator<T>(\n  response: Response | NodeResponse\n): AsyncIterableIterator<T> {\n  let body: unknown = response;\n\n  if (isNodeResponse(response)) body = response.body;\n\n  if (isAsyncIterableIterator(body)) return asyncIterator<T>(body);\n\n  if (isReadableStream(body)) return readerIterator<T>(body.getReader());\n\n  // this errors without casting to ReadableStream<T>\n  // because Blob.stream() returns a NodeJS ReadableStream\n  if (isStreamableBlob(body)) {\n    return readerIterator<T>(\n      (body.stream() as unknown as ReadableStream<T>).getReader()\n    );\n  }\n\n  if (isBlob(body)) return promiseIterator<T>(body.arrayBuffer());\n\n  if (isNodeReadableStream(body)) return nodeStreamIterator<T>(body);\n\n  throw new Error(\n    \"Unknown body type for responseIterator. Please pass a streamable response.\"\n  );\n}\n", "import { responseIterator } from \"./responseIterator.js\";\nimport type { Operation } from \"../core/index.js\";\nimport { throwServerError } from \"../utils/index.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../../errors/index.js\";\nimport { isApolloPayloadResult } from \"../../utilities/common/incrementalResult.js\";\nimport type { SubscriptionObserver } from \"zen-observable-ts\";\n\nconst { hasOwnProperty } = Object.prototype;\n\nexport type ServerParseError = Error & {\n  response: Response;\n  statusCode: number;\n  bodyText: string;\n};\n\nexport async function readMultipartBody<\n  T extends object = Record<string, unknown>,\n>(response: Response, nextValue: (value: T) => void) {\n  if (TextDecoder === undefined) {\n    throw new Error(\n      \"TextDecoder must be defined in the environment: please import a polyfill.\"\n    );\n  }\n  const decoder = new TextDecoder(\"utf-8\");\n  const contentType = response.headers?.get(\"content-type\");\n  const delimiter = \"boundary=\";\n\n  // parse boundary value and ignore any subsequent name/value pairs after ;\n  // https://www.rfc-editor.org/rfc/rfc9110.html#name-parameters\n  // e.g. multipart/mixed;boundary=\"graphql\";deferSpec=20220824\n  // if no boundary is specified, default to -\n  const boundaryVal =\n    contentType?.includes(delimiter) ?\n      contentType\n        ?.substring(contentType?.indexOf(delimiter) + delimiter.length)\n        .replace(/['\"]/g, \"\")\n        .replace(/\\;(.*)/gm, \"\")\n        .trim()\n    : \"-\";\n\n  const boundary = `\\r\\n--${boundaryVal}`;\n  let buffer = \"\";\n  const iterator = responseIterator(response);\n  let running = true;\n\n  while (running) {\n    const { value, done } = await iterator.next();\n    const chunk = typeof value === \"string\" ? value : decoder.decode(value);\n    const searchFrom = buffer.length - boundary.length + 1;\n    running = !done;\n    buffer += chunk;\n    let bi = buffer.indexOf(boundary, searchFrom);\n\n    while (bi > -1) {\n      let message: string;\n      [message, buffer] = [\n        buffer.slice(0, bi),\n        buffer.slice(bi + boundary.length),\n      ];\n      const i = message.indexOf(\"\\r\\n\\r\\n\");\n      const headers = parseHeaders(message.slice(0, i));\n      const contentType = headers[\"content-type\"];\n      if (\n        contentType &&\n        contentType.toLowerCase().indexOf(\"application/json\") === -1\n      ) {\n        throw new Error(\n          \"Unsupported patch content type: application/json is required.\"\n        );\n      }\n      // nb: Technically you'd want to slice off the beginning \"\\r\\n\" but since\n      // this is going to be `JSON.parse`d there is no need.\n      const body = message.slice(i);\n\n      if (body) {\n        const result = parseJsonBody<T>(response, body);\n        if (\n          Object.keys(result).length > 1 ||\n          \"data\" in result ||\n          \"incremental\" in result ||\n          \"errors\" in result ||\n          \"payload\" in result\n        ) {\n          if (isApolloPayloadResult(result)) {\n            let next = {};\n            if (\"payload\" in result) {\n              if (Object.keys(result).length === 1 && result.payload === null) {\n                return;\n              }\n              next = { ...result.payload };\n            }\n            if (\"errors\" in result) {\n              next = {\n                ...next,\n                extensions: {\n                  ...(\"extensions\" in next ? next.extensions : (null as any)),\n                  [PROTOCOL_ERRORS_SYMBOL]: result.errors,\n                },\n              };\n            }\n            nextValue(next as T);\n          } else {\n            // for the last chunk with only `hasNext: false`\n            // we don't need to call observer.next as there is no data/errors\n            nextValue(result);\n          }\n        } else if (\n          // If the chunk contains only a \"hasNext: false\", we can call\n          // observer.complete() immediately.\n          Object.keys(result).length === 1 &&\n          \"hasNext\" in result &&\n          !result.hasNext\n        ) {\n          return;\n        }\n      }\n      bi = buffer.indexOf(boundary);\n    }\n  }\n}\n\nexport function parseHeaders(headerText: string): Record<string, string> {\n  const headersInit: Record<string, string> = {};\n  headerText.split(\"\\n\").forEach((line) => {\n    const i = line.indexOf(\":\");\n    if (i > -1) {\n      // normalize headers to lowercase\n      const name = line.slice(0, i).trim().toLowerCase();\n      const value = line.slice(i + 1).trim();\n      headersInit[name] = value;\n    }\n  });\n  return headersInit;\n}\n\nexport function parseJsonBody<T>(response: Response, bodyText: string): T {\n  if (response.status >= 300) {\n    // Network error\n    const getResult = (): Record<string, unknown> | string => {\n      try {\n        return JSON.parse(bodyText);\n      } catch (err) {\n        return bodyText;\n      }\n    };\n    throwServerError(\n      response,\n      getResult(),\n      `Response not successful: Received status code ${response.status}`\n    );\n  }\n\n  try {\n    return JSON.parse(bodyText) as T;\n  } catch (err) {\n    const parseError = err as ServerParseError;\n    parseError.name = \"ServerParseError\";\n    parseError.response = response;\n    parseError.statusCode = response.status;\n    parseError.bodyText = bodyText;\n    throw parseError;\n  }\n}\n\nexport function handleError(err: any, observer: SubscriptionObserver<any>) {\n  // if it is a network error, BUT there is graphql result info fire\n  // the next observer before calling error this gives apollo-client\n  // (and react-apollo) the `graphqlErrors` and `networkErrors` to\n  // pass to UI this should only happen if we *also* have data as\n  // part of the response key per the spec\n  if (err.result && err.result.errors && err.result.data) {\n    // if we don't call next, the UI can only show networkError\n    // because AC didn't get any graphqlErrors this is graphql\n    // execution result info (i.e errors and possibly data) this is\n    // because there is no formal spec how errors should translate to\n    // http status codes. So an auth error (401) could have both data\n    // from a public field, errors from a private field, and a status\n    // of 401\n    // {\n    //  user { // this will have errors\n    //    firstName\n    //  }\n    //  products { // this is public so will have data\n    //    cost\n    //  }\n    // }\n    //\n    // the result of above *could* look like this:\n    // {\n    //   data: { products: [{ cost: \"$10\" }] },\n    //   errors: [{\n    //      message: 'your session has timed out',\n    //      path: []\n    //   }]\n    // }\n    // status code of above would be a 401\n    // in the UI you want to show data where you can, errors as data where you can\n    // and use correct http status codes\n    observer.next(err.result);\n  }\n\n  observer.error(err);\n}\n\nexport function parseAndCheckHttpResponse(operations: Operation | Operation[]) {\n  return (response: Response) =>\n    response\n      .text()\n      .then((bodyText) => parseJsonBody(response, bodyText))\n      .then((result: any) => {\n        if (\n          !Array.isArray(result) &&\n          !hasOwnProperty.call(result, \"data\") &&\n          !hasOwnProperty.call(result, \"errors\")\n        ) {\n          // Data error\n          throwServerError(\n            response,\n            result,\n            `Server response was missing for query '${\n              Array.isArray(operations) ?\n                operations.map((op) => op.operationName)\n              : operations.operationName\n            }'.`\n          );\n        }\n        return result;\n      });\n}\n", "import { newInvariantError } from \"../../utilities/globals/index.js\";\nimport type { InvariantError } from \"../../utilities/globals/index.js\";\n\nexport type ClientParseError = InvariantError & {\n  parseError: Error;\n};\n\nexport const serializeFetchParameter = (p: any, label: string) => {\n  let serialized;\n  try {\n    serialized = JSON.stringify(p);\n  } catch (e: any) {\n    const parseError = newInvariantError(\n      `Network request failed. %s is not serializable: %s`,\n      label,\n      e.message\n    ) as ClientParseError;\n    parseError.parseError = e;\n    throw parseError;\n  }\n  return serialized;\n};\n", "import type { ASTNode } from \"graphql\";\nimport { print } from \"../../utilities/index.js\";\n\nimport type { Operation } from \"../core/index.js\";\n\nexport interface Printer {\n  (node: ASTNode, originalPrint: typeof print): string;\n}\n\nexport interface UriFunction {\n  (operation: Operation): string;\n}\n\nexport interface Body {\n  query?: string;\n  operationName?: string;\n  variables?: Record<string, any>;\n  extensions?: Record<string, any>;\n}\n\nexport interface HttpOptions {\n  /**\n   * The URI to use when fetching operations.\n   *\n   * Defaults to '/graphql'.\n   */\n  uri?: string | UriFunction;\n\n  /**\n   * Passes the extensions field to your graphql server.\n   *\n   * Defaults to false.\n   */\n  includeExtensions?: boolean;\n\n  /**\n   * A `fetch`-compatible API to use when making requests.\n   */\n  fetch?: typeof fetch;\n\n  /**\n   * An object representing values to be sent as headers on the request.\n   */\n  headers?: Record<string, string>;\n\n  /**\n   * If set to true, header names won't be automatically normalized to\n   * lowercase. This allows for non-http-spec-compliant servers that might\n   * expect capitalized header names.\n   */\n  preserveHeaderCase?: boolean;\n\n  /**\n   * The credentials policy you want to use for the fetch call.\n   */\n  credentials?: string;\n\n  /**\n   * Any overrides of the fetch options argument to pass to the fetch call.\n   */\n  fetchOptions?: any;\n\n  /**\n   * If set to true, use the HTTP GET method for query operations. Mutations\n   * will still use the method specified in fetchOptions.method (which defaults\n   * to POST).\n   */\n  useGETForQueries?: boolean;\n\n  /**\n   * If set to true, the default behavior of stripping unused variables\n   * from the request will be disabled.\n   *\n   * Unused variables are likely to trigger server-side validation errors,\n   * per https://spec.graphql.org/draft/#sec-All-Variables-Used, but this\n   * includeUnusedVariables option can be useful if your server deviates\n   * from the GraphQL specification by not strictly enforcing that rule.\n   */\n  includeUnusedVariables?: boolean;\n  /**\n   * A function to substitute for the default query print function. Can be\n   * used to apply changes to the results of the print function.\n   */\n  print?: Printer;\n}\n\nexport interface HttpQueryOptions {\n  includeQuery?: boolean;\n  includeExtensions?: boolean;\n  preserveHeaderCase?: boolean;\n}\n\nexport interface HttpConfig {\n  http?: HttpQueryOptions;\n  options?: any;\n  headers?: Record<string, string>;\n  credentials?: any;\n}\n\nconst defaultHttpOptions: HttpQueryOptions = {\n  includeQuery: true,\n  includeExtensions: false,\n  preserveHeaderCase: false,\n};\n\nconst defaultHeaders = {\n  // headers are case insensitive (https://stackoverflow.com/a/5259004)\n  accept: \"*/*\",\n  // The content-type header describes the type of the body of the request, and\n  // so it typically only is sent with requests that actually have bodies. One\n  // could imagine that Apollo Client would remove this header when constructing\n  // a GET request (which has no body), but we historically have not done that.\n  // This means that browsers will preflight all Apollo Client requests (even\n  // GET requests). Apollo Server's CSRF prevention feature (introduced in\n  // AS3.7) takes advantage of this fact and does not block requests with this\n  // header. If you want to drop this header from GET requests, then you should\n  // probably replace it with a `apollo-require-preflight` header, or servers\n  // with CSRF prevention enabled might block your GET request. See\n  // https://www.apollographql.com/docs/apollo-server/security/cors/#preventing-cross-site-request-forgery-csrf\n  // for more details.\n  \"content-type\": \"application/json\",\n};\n\nconst defaultOptions = {\n  method: \"POST\",\n};\n\nexport const fallbackHttpConfig = {\n  http: defaultHttpOptions,\n  headers: defaultHeaders,\n  options: defaultOptions,\n};\n\nexport const defaultPrinter: Printer = (ast, printer) => printer(ast);\n\nexport function selectHttpOptionsAndBody(\n  operation: Operation,\n  fallbackConfig: HttpConfig,\n  ...configs: Array<HttpConfig>\n) {\n  configs.unshift(fallbackConfig);\n  return selectHttpOptionsAndBodyInternal(\n    operation,\n    defaultPrinter,\n    ...configs\n  );\n}\n\nexport function selectHttpOptionsAndBodyInternal(\n  operation: Operation,\n  printer: Printer,\n  ...configs: HttpConfig[]\n) {\n  let options = {} as HttpConfig & Record<string, any>;\n  let http = {} as HttpQueryOptions;\n\n  configs.forEach((config) => {\n    options = {\n      ...options,\n      ...config.options,\n      headers: {\n        ...options.headers,\n        ...config.headers,\n      },\n    };\n\n    if (config.credentials) {\n      options.credentials = config.credentials;\n    }\n\n    http = {\n      ...http,\n      ...config.http,\n    };\n  });\n\n  if (options.headers) {\n    options.headers = removeDuplicateHeaders(\n      options.headers,\n      http.preserveHeaderCase\n    );\n  }\n\n  //The body depends on the http options\n  const { operationName, extensions, variables, query } = operation;\n  const body: Body = { operationName, variables };\n\n  if (http.includeExtensions) (body as any).extensions = extensions;\n\n  // not sending the query (i.e persisted queries)\n  if (http.includeQuery) (body as any).query = printer(query, print);\n\n  return {\n    options,\n    body,\n  };\n}\n\n// Remove potential duplicate header names, preserving last (by insertion order).\n// This is done to prevent unintentionally duplicating a header instead of\n// overwriting it (See #8447 and #8449).\nfunction removeDuplicateHeaders(\n  headers: Record<string, string>,\n  preserveHeaderCase: boolean | undefined\n): typeof headers {\n  // If we're not preserving the case, just remove duplicates w/ normalization.\n  if (!preserveHeaderCase) {\n    const normalizedHeaders: Record<string, string> = {};\n    Object.keys(Object(headers)).forEach((name) => {\n      normalizedHeaders[name.toLowerCase()] = headers[name];\n    });\n    return normalizedHeaders;\n  }\n\n  // If we are preserving the case, remove duplicates w/ normalization,\n  // preserving the original name.\n  // This allows for non-http-spec-compliant servers that expect intentionally\n  // capitalized header names (See #6741).\n  const headerData: Record<string, { originalName: string; value: string }> =\n    {};\n  Object.keys(Object(headers)).forEach((name) => {\n    headerData[name.toLowerCase()] = {\n      originalName: name,\n      value: headers[name],\n    };\n  });\n\n  const normalizedHeaders: Record<string, string> = {};\n  Object.keys(headerData).forEach((name) => {\n    normalizedHeaders[headerData[name].originalName] = headerData[name].value;\n  });\n  return normalizedHeaders;\n}\n", "import { newInvariantError } from \"../../utilities/globals/index.js\";\n\nexport const checkFetcher = (fetcher: typeof fetch | undefined) => {\n  if (!fetcher && typeof fetch === \"undefined\") {\n    throw newInvariantError(`\n\"fetch\" has not been found globally and no fetcher has been \\\nconfigured. To fix this, install a fetch package (like \\\nhttps://www.npmjs.com/package/cross-fetch), instantiate the \\\nfetcher, and pass it into your HttpLink constructor. For example:\n\nimport fetch from 'cross-fetch';\nimport { ApolloClient, HttpLink } from '@apollo/client';\nconst client = new ApolloClient({\n  link: new HttpLink({ uri: '/graphql', fetch })\n});\n    `);\n  }\n};\n", "/**\n * @deprecated\n * This is not used internally any more and will be removed in\n * the next major version of Apollo Client.\n */\nexport const createSignalIfSupported = () => {\n  if (typeof AbortController === \"undefined\")\n    return { controller: false, signal: false };\n\n  const controller = new AbortController();\n  const signal = controller.signal;\n  return { controller, signal };\n};\n", "import type { Operation } from \"../core/index.js\";\n\nexport const selectURI = (\n  operation: Operation,\n  fallbackURI?: string | ((operation: Operation) => string)\n) => {\n  const context = operation.getContext();\n  const contextURI = context.uri;\n\n  if (contextURI) {\n    return contextURI;\n  } else if (typeof fallbackURI === \"function\") {\n    return fallbackURI(operation);\n  } else {\n    return (fallbackURI as string) || \"/graphql\";\n  }\n};\n", "import { serializeFetchParameter } from \"./serializeFetchParameter.js\";\nimport type { Body } from \"./selectHttpOptionsAndBody.js\";\n\n// For GET operations, returns the given URI rewritten with parameters, or a\n// parse error.\nexport function rewriteURIForGET(chosenURI: string, body: Body) {\n  // Implement the standard HTTP GET serialization, plus 'extensions'. Note\n  // the extra level of JSON serialization!\n  const queryParams: string[] = [];\n  const addQueryParam = (key: string, value: string) => {\n    queryParams.push(`${key}=${encodeURIComponent(value)}`);\n  };\n\n  if (\"query\" in body) {\n    addQueryParam(\"query\", body.query!);\n  }\n  if (body.operationName) {\n    addQueryParam(\"operationName\", body.operationName);\n  }\n  if (body.variables) {\n    let serializedVariables;\n    try {\n      serializedVariables = serializeFetchParameter(\n        body.variables,\n        \"Variables map\"\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam(\"variables\", serializedVariables);\n  }\n  if (body.extensions) {\n    let serializedExtensions;\n    try {\n      serializedExtensions = serializeFetchParameter(\n        body.extensions,\n        \"Extensions map\"\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam(\"extensions\", serializedExtensions);\n  }\n\n  // Reconstruct the URI with added query params.\n  // XXX This assumes that the URI is well-formed and that it doesn't\n  //     already contain any of these query params. We could instead use the\n  //     URL API and take a polyfill (whatwg-url@6) for older browsers that\n  //     don't support URLSearchParams. Note that some browsers (and\n  //     versions of whatwg-url) support URL but not URLSearchParams!\n  let fragment = \"\",\n    preFragment = chosenURI;\n  const fragmentStart = chosenURI.indexOf(\"#\");\n  if (fragmentStart !== -1) {\n    fragment = chosenURI.substr(fragmentStart);\n    preFragment = chosenURI.substr(0, fragmentStart);\n  }\n  const queryParamsPrefix = preFragment.indexOf(\"?\") === -1 ? \"?\" : \"&\";\n  const newURI =\n    preFragment + queryParamsPrefix + queryParams.join(\"&\") + fragment;\n  return { newURI };\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\n\nimport type { DefinitionNode } from \"graphql\";\n\nimport { ApolloLink } from \"../core/index.js\";\nimport { Observable, hasDirectives } from \"../../utilities/index.js\";\nimport { serializeFetchParameter } from \"./serializeFetchParameter.js\";\nimport { selectURI } from \"./selectURI.js\";\nimport {\n  handleError,\n  readMultipartBody,\n  parseAndCheckHttpResponse,\n} from \"./parseAndCheckHttpResponse.js\";\nimport { checkFetcher } from \"./checkFetcher.js\";\nimport type { HttpOptions } from \"./selectHttpOptionsAndBody.js\";\nimport {\n  selectHttpOptionsAndBodyInternal,\n  defaultPrinter,\n  fallbackHttpConfig,\n} from \"./selectHttpOptionsAndBody.js\";\nimport { rewriteURIForGET } from \"./rewriteURIForGET.js\";\nimport { fromError, filterOperationVariables } from \"../utils/index.js\";\nimport {\n  maybe,\n  getMainDefinition,\n  removeClientSetsFromDocument,\n} from \"../../utilities/index.js\";\n\nconst backupFetch = maybe(() => fetch);\n\nexport const createHttpLink = (linkOptions: HttpOptions = {}) => {\n  let {\n    uri = \"/graphql\",\n    // use default global fetch if nothing passed in\n    fetch: preferredFetch,\n    print = defaultPrinter,\n    includeExtensions,\n    preserveHeaderCase,\n    useGETForQueries,\n    includeUnusedVariables = false,\n    ...requestOptions\n  } = linkOptions;\n\n  if (__DEV__) {\n    // Make sure at least one of preferredFetch, window.fetch, or backupFetch is\n    // defined, so requests won't fail at runtime.\n    checkFetcher(preferredFetch || backupFetch);\n  }\n\n  const linkConfig = {\n    http: { includeExtensions, preserveHeaderCase },\n    options: requestOptions.fetchOptions,\n    credentials: requestOptions.credentials,\n    headers: requestOptions.headers,\n  };\n\n  return new ApolloLink((operation) => {\n    let chosenURI = selectURI(operation, uri);\n\n    const context = operation.getContext();\n\n    // `apollographql-client-*` headers are automatically set if a\n    // `clientAwareness` object is found in the context. These headers are\n    // set first, followed by the rest of the headers pulled from\n    // `context.headers`. If desired, `apollographql-client-*` headers set by\n    // the `clientAwareness` object can be overridden by\n    // `apollographql-client-*` headers set in `context.headers`.\n    const clientAwarenessHeaders: {\n      \"apollographql-client-name\"?: string;\n      \"apollographql-client-version\"?: string;\n    } = {};\n\n    if (context.clientAwareness) {\n      const { name, version } = context.clientAwareness;\n      if (name) {\n        clientAwarenessHeaders[\"apollographql-client-name\"] = name;\n      }\n      if (version) {\n        clientAwarenessHeaders[\"apollographql-client-version\"] = version;\n      }\n    }\n\n    const contextHeaders = { ...clientAwarenessHeaders, ...context.headers };\n\n    const contextConfig = {\n      http: context.http,\n      options: context.fetchOptions,\n      credentials: context.credentials,\n      headers: contextHeaders,\n    };\n\n    if (hasDirectives([\"client\"], operation.query)) {\n      const transformedQuery = removeClientSetsFromDocument(operation.query);\n\n      if (!transformedQuery) {\n        return fromError(\n          new Error(\n            \"HttpLink: Trying to send a client-only query to the server. To send to the server, ensure a non-client field is added to the query or set the `transformOptions.removeClientFields` option to `true`.\"\n          )\n        );\n      }\n\n      operation.query = transformedQuery;\n    }\n\n    //uses fallback, link, and then context to build options\n    const { options, body } = selectHttpOptionsAndBodyInternal(\n      operation,\n      print,\n      fallbackHttpConfig,\n      linkConfig,\n      contextConfig\n    );\n\n    if (body.variables && !includeUnusedVariables) {\n      body.variables = filterOperationVariables(\n        body.variables,\n        operation.query\n      );\n    }\n\n    let controller: AbortController | undefined;\n    if (!options.signal && typeof AbortController !== \"undefined\") {\n      controller = new AbortController();\n      options.signal = controller.signal;\n    }\n\n    // If requested, set method to GET if there are no mutations.\n    const definitionIsMutation = (d: DefinitionNode) => {\n      return d.kind === \"OperationDefinition\" && d.operation === \"mutation\";\n    };\n    const definitionIsSubscription = (d: DefinitionNode) => {\n      return d.kind === \"OperationDefinition\" && d.operation === \"subscription\";\n    };\n    const isSubscription = definitionIsSubscription(\n      getMainDefinition(operation.query)\n    );\n    // does not match custom directives beginning with @defer\n    const hasDefer = hasDirectives([\"defer\"], operation.query);\n    if (\n      useGETForQueries &&\n      !operation.query.definitions.some(definitionIsMutation)\n    ) {\n      options.method = \"GET\";\n    }\n\n    if (hasDefer || isSubscription) {\n      options.headers = options.headers || {};\n      let acceptHeader = \"multipart/mixed;\";\n      // Omit defer-specific headers if the user attempts to defer a selection\n      // set on a subscription and log a warning.\n      if (isSubscription && hasDefer) {\n        invariant.warn(\"Multipart-subscriptions do not support @defer\");\n      }\n\n      if (isSubscription) {\n        acceptHeader +=\n          \"boundary=graphql;subscriptionSpec=1.0,application/json\";\n      } else if (hasDefer) {\n        acceptHeader += \"deferSpec=20220824,application/json\";\n      }\n      options.headers.accept = acceptHeader;\n    }\n\n    if (options.method === \"GET\") {\n      const { newURI, parseError } = rewriteURIForGET(chosenURI, body);\n      if (parseError) {\n        return fromError(parseError);\n      }\n      chosenURI = newURI;\n    } else {\n      try {\n        (options as any).body = serializeFetchParameter(body, \"Payload\");\n      } catch (parseError) {\n        return fromError(parseError);\n      }\n    }\n\n    return new Observable((observer) => {\n      // Prefer linkOptions.fetch (preferredFetch) if provided, and otherwise\n      // fall back to the *current* global window.fetch function (see issue\n      // #7832), or (if all else fails) the backupFetch function we saved when\n      // this module was first evaluated. This last option protects against the\n      // removal of window.fetch, which is unlikely but not impossible.\n      const currentFetch = preferredFetch || maybe(() => fetch) || backupFetch;\n\n      const observerNext = observer.next.bind(observer);\n      currentFetch!(chosenURI, options)\n        .then((response) => {\n          operation.setContext({ response });\n          const ctype = response.headers?.get(\"content-type\");\n\n          if (ctype !== null && /^multipart\\/mixed/i.test(ctype)) {\n            return readMultipartBody(response, observerNext);\n          } else {\n            return parseAndCheckHttpResponse(operation)(response).then(\n              observerNext\n            );\n          }\n        })\n        .then(() => {\n          controller = undefined;\n          observer.complete();\n        })\n        .catch((err) => {\n          controller = undefined;\n          handleError(err, observer);\n        });\n\n      return () => {\n        // XXX support canceling this request\n        // https://developers.google.com/web/updates/2017/09/abortable-fetch\n        if (controller) controller.abort();\n      };\n    });\n  });\n};\n", "import { ApolloLink } from \"../core/index.js\";\nimport type { HttpOptions } from \"./selectHttpOptionsAndBody.js\";\nimport { createHttpLink } from \"./createHttpLink.js\";\n\nexport class HttpLink extends ApolloLink {\n  constructor(public options: HttpOptions = {}) {\n    super(createHttpLink(options).request);\n  }\n}\n", "import \"../../utilities/globals/index.js\";\n\nexport type { ServerParseError } from \"./parseAndCheckHttpResponse.js\";\nexport { parseAndCheckHttpResponse } from \"./parseAndCheckHttpResponse.js\";\nexport type { ClientParseError } from \"./serializeFetchParameter.js\";\nexport { serializeFetchParameter } from \"./serializeFetchParameter.js\";\nexport type { HttpOptions, UriFunction } from \"./selectHttpOptionsAndBody.js\";\nexport {\n  fallbackHttpConfig,\n  defaultPrinter,\n  selectHttpOptionsAndBody,\n  selectHttpOptionsAndBodyInternal, // needed by ../batch-http but not public\n} from \"./selectHttpOptionsAndBody.js\";\nexport { checkFetcher } from \"./checkFetcher.js\";\nexport { createSignalIfSupported } from \"./createSignalIfSupported.js\";\nexport { selectURI } from \"./selectURI.js\";\nexport { createHttpLink } from \"./createHttpLink.js\";\nexport { HttpLink } from \"./HttpLink.js\";\nexport { rewriteURIForGET } from \"./rewriteURIForGET.js\";\n", "const { toString, hasOwnProperty } = Object.prototype;\nconst fnToStr = Function.prototype.toString;\nconst previousComparisons = new Map<object, Set<object>>();\n\n/**\n * Performs a deep equality check on two JavaScript values, tolerating cycles.\n */\nexport function equal(a: any, b: any): boolean {\n  try {\n    return check(a, b);\n  } finally {\n    previousComparisons.clear();\n  }\n}\n\n// Allow default imports as well.\nexport default equal;\n\nfunction check(a: any, b: any): boolean {\n  // If the two values are strictly equal, our job is easy.\n  if (a === b) {\n    return true;\n  }\n\n  // Object.prototype.toString returns a representation of the runtime type of\n  // the given value that is considerably more precise than typeof.\n  const aTag = toString.call(a);\n  const bTag = toString.call(b);\n\n  // If the runtime types of a and b are different, they could maybe be equal\n  // under some interpretation of equality, but for simplicity and performance\n  // we just return false instead.\n  if (aTag !== bTag) {\n    return false;\n  }\n\n  switch (aTag) {\n    case '[object Array]':\n      // Arrays are a lot like other objects, but we can cheaply compare their\n      // lengths as a short-cut before comparing their elements.\n      if (a.length !== b.length) return false;\n      // Fall through to object case...\n    case '[object Object]': {\n      if (previouslyCompared(a, b)) return true;\n\n      const aKeys = definedKeys(a);\n      const bKeys = definedKeys(b);\n\n      // If `a` and `b` have a different number of enumerable keys, they\n      // must be different.\n      const keyCount = aKeys.length;\n      if (keyCount !== bKeys.length) return false;\n\n      // Now make sure they have the same keys.\n      for (let k = 0; k < keyCount; ++k) {\n        if (!hasOwnProperty.call(b, aKeys[k])) {\n          return false;\n        }\n      }\n\n      // Finally, check deep equality of all child properties.\n      for (let k = 0; k < keyCount; ++k) {\n        const key = aKeys[k];\n        if (!check(a[key], b[key])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    case '[object Error]':\n      return a.name === b.name && a.message === b.message;\n\n    case '[object Number]':\n      // Handle NaN, which is !== itself.\n      if (a !== a) return b !== b;\n      // Fall through to shared +a === +b case...\n    case '[object Boolean]':\n    case '[object Date]':\n      return +a === +b;\n\n    case '[object RegExp]':\n    case '[object String]':\n      return a == `${b}`;\n\n    case '[object Map]':\n    case '[object Set]': {\n      if (a.size !== b.size) return false;\n      if (previouslyCompared(a, b)) return true;\n\n      const aIterator = a.entries();\n      const isMap = aTag === '[object Map]';\n\n      while (true) {\n        const info = aIterator.next();\n        if (info.done) break;\n\n        // If a instanceof Set, aValue === aKey.\n        const [aKey, aValue] = info.value;\n\n        // So this works the same way for both Set and Map.\n        if (!b.has(aKey)) {\n          return false;\n        }\n\n        // However, we care about deep equality of values only when dealing\n        // with Map structures.\n        if (isMap && !check(aValue, b.get(aKey))) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    case '[object Uint16Array]':\n    case '[object Uint8Array]': // Buffer, in Node.js.\n    case '[object Uint32Array]':\n    case '[object Int32Array]':\n    case '[object Int8Array]':\n    case '[object Int16Array]':\n    case '[object ArrayBuffer]':\n      // DataView doesn't need these conversions, but the equality check is\n      // otherwise the same.\n      a = new Uint8Array(a);\n      b = new Uint8Array(b);\n      // Fall through...\n    case '[object DataView]': {\n      let len = a.byteLength;\n      if (len === b.byteLength) {\n        while (len-- && a[len] === b[len]) {\n          // Keep looping as long as the bytes are equal.\n        }\n      }\n      return len === -1;\n    }\n\n    case '[object AsyncFunction]':\n    case '[object GeneratorFunction]':\n    case '[object AsyncGeneratorFunction]':\n    case '[object Function]': {\n      const aCode = fnToStr.call(a);\n      if (aCode !== fnToStr.call(b)) {\n        return false;\n      }\n\n      // We consider non-native functions equal if they have the same code\n      // (native functions require === because their code is censored).\n      // Note that this behavior is not entirely sound, since !== function\n      // objects with the same code can behave differently depending on\n      // their closure scope. However, any function can behave differently\n      // depending on the values of its input arguments (including this)\n      // and its calling context (including its closure scope), even\n      // though the function object is === to itself; and it is entirely\n      // possible for functions that are not === to behave exactly the\n      // same under all conceivable circumstances. Because none of these\n      // factors are statically decidable in JavaScript, JS function\n      // equality is not well-defined. This ambiguity allows us to\n      // consider the best possible heuristic among various imperfect\n      // options, and equating non-native functions that have the same\n      // code has enormous practical benefits, such as when comparing\n      // functions that are repeatedly passed as fresh function\n      // expressions within objects that are otherwise deeply equal. Since\n      // any function created from the same syntactic expression (in the\n      // same code location) will always stringify to the same code\n      // according to fnToStr.call, we can reasonably expect these\n      // repeatedly passed function expressions to have the same code, and\n      // thus behave \"the same\" (with all the caveats mentioned above),\n      // even though the runtime function objects are !== to one another.\n      return !endsWith(aCode, nativeCodeSuffix);\n    }\n  }\n\n  // Otherwise the values are not equal.\n  return false;\n}\n\nfunction definedKeys<TObject extends object>(obj: TObject) {\n  // Remember that the second argument to Array.prototype.filter will be\n  // used as `this` within the callback function.\n  return Object.keys(obj).filter(isDefinedKey, obj);\n}\nfunction isDefinedKey<TObject extends object>(\n  this: TObject,\n  key: keyof TObject,\n) {\n  return this[key] !== void 0;\n}\n\nconst nativeCodeSuffix = \"{ [native code] }\";\n\nfunction endsWith(full: string, suffix: string) {\n  const fromIndex = full.length - suffix.length;\n  return fromIndex >= 0 &&\n    full.indexOf(suffix, fromIndex) === fromIndex;\n}\n\nfunction previouslyCompared(a: object, b: object): boolean {\n  // Though cyclic references can make an object graph appear infinite from the\n  // perspective of a depth-first traversal, the graph still contains a finite\n  // number of distinct object references. We use the previousComparisons cache\n  // to avoid comparing the same pair of object references more than once, which\n  // guarantees termination (even if we end up comparing every object in one\n  // graph to every object in the other graph, which is extremely unlikely),\n  // while still allowing weird isomorphic structures (like rings with different\n  // lengths) a chance to pass the equality test.\n  let bSet = previousComparisons.get(a);\n  if (bSet) {\n    // Return true here because we can be sure false will be returned somewhere\n    // else if the objects are not equivalent.\n    if (bSet.has(b)) return true;\n  } else {\n    previousComparisons.set(a, bSet = new Set);\n  }\n  bSet.add(b);\n  return false;\n}\n", "import equal from \"@wry/equality\";\n\nimport type {\n  DirectiveNode,\n  DocumentNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  FragmentSpreadNode,\n  InlineFragmentNode,\n  SelectionNode,\n  SelectionSetNode,\n} from \"graphql\";\n\nimport type { ApolloQueryResult, OperationVariables } from \"./types.js\";\n\nimport type { FragmentMap } from \"../utilities/index.js\";\nimport {\n  createFragmentMap,\n  getFragmentDefinitions,\n  getFragmentFromSelection,\n  getMainDefinition,\n  isField,\n  resultKeyNameFromField,\n  shouldInclude,\n} from \"../utilities/index.js\";\n\n// Returns true if aResult and bResult are deeply equal according to the fields\n// selected by the given query, ignoring any fields marked as @nonreactive.\nexport function equalByQuery(\n  query: DocumentNode,\n  { data: aData, ...aRest }: Partial<ApolloQueryResult<unknown>>,\n  { data: bData, ...bRest }: Partial<ApolloQueryResult<unknown>>,\n  variables?: OperationVariables\n): boolean {\n  return (\n    equal(aRest, bRest) &&\n    equalBySelectionSet(getMainDefinition(query).selectionSet, aData, bData, {\n      fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n      variables,\n    })\n  );\n}\n\n// Encapsulates the information used by equalBySelectionSet that does not change\n// during the recursion.\ninterface CompareContext<TVariables> {\n  fragmentMap: FragmentMap;\n  variables: TVariables | undefined;\n}\n\nfunction equalBySelectionSet(\n  selectionSet: SelectionSetNode,\n  aResult: any,\n  bResult: any,\n  context: CompareContext<OperationVariables>\n): boolean {\n  if (aResult === bResult) {\n    return true;\n  }\n\n  const seenSelections = new Set<SelectionNode>();\n\n  // Returning true from this Array.prototype.every callback function skips the\n  // current field/subtree. Returning false aborts the entire traversal\n  // immediately, causing equalBySelectionSet to return false.\n  return selectionSet.selections.every((selection) => {\n    // Avoid re-processing the same selection at the same level of recursion, in\n    // case the same field gets included via multiple indirect fragment spreads.\n    if (seenSelections.has(selection)) return true;\n    seenSelections.add(selection);\n\n    // Ignore @skip(if: true) and @include(if: false) fields.\n    if (!shouldInclude(selection, context.variables)) return true;\n\n    // If the field or (named) fragment spread has a @nonreactive directive on\n    // it, we don't care if it's different, so we pretend it's the same.\n    if (selectionHasNonreactiveDirective(selection)) return true;\n\n    if (isField(selection)) {\n      const resultKey = resultKeyNameFromField(selection);\n      const aResultChild = aResult && aResult[resultKey];\n      const bResultChild = bResult && bResult[resultKey];\n      const childSelectionSet = selection.selectionSet;\n\n      if (!childSelectionSet) {\n        // These are scalar values, so we can compare them with deep equal\n        // without redoing the main recursive work.\n        return equal(aResultChild, bResultChild);\n      }\n\n      const aChildIsArray = Array.isArray(aResultChild);\n      const bChildIsArray = Array.isArray(bResultChild);\n      if (aChildIsArray !== bChildIsArray) return false;\n      if (aChildIsArray && bChildIsArray) {\n        const length = aResultChild.length;\n        if (bResultChild.length !== length) {\n          return false;\n        }\n        for (let i = 0; i < length; ++i) {\n          if (\n            !equalBySelectionSet(\n              childSelectionSet,\n              aResultChild[i],\n              bResultChild[i],\n              context\n            )\n          ) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      return equalBySelectionSet(\n        childSelectionSet,\n        aResultChild,\n        bResultChild,\n        context\n      );\n    } else {\n      const fragment = getFragmentFromSelection(selection, context.fragmentMap);\n      if (fragment) {\n        // The fragment might === selection if it's an inline fragment, but\n        // could be !== if it's a named fragment ...spread.\n        if (selectionHasNonreactiveDirective(fragment)) return true;\n\n        return equalBySelectionSet(\n          fragment.selectionSet,\n          // Notice that we reuse the same aResult and bResult values here,\n          // since the fragment ...spread does not specify a field name, but\n          // consists of multiple fields (within the fragment's selection set)\n          // that should be applied to the current result value(s).\n          aResult,\n          bResult,\n          context\n        );\n      }\n    }\n  });\n}\n\nfunction selectionHasNonreactiveDirective(\n  selection:\n    | FieldNode\n    | InlineFragmentNode\n    | FragmentSpreadNode\n    | FragmentDefinitionNode\n): boolean {\n  return (\n    !!selection.directives && selection.directives.some(directiveIsNonreactive)\n  );\n}\n\nfunction directiveIsNonreactive(dir: DirectiveNode): boolean {\n  return dir.name.value === \"nonreactive\";\n}\n", "import { Slot } from \"optimism\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport { canUseWeakMap, canUseWeakSet } from \"../utilities/index.js\";\n\nexport const MapImpl = canUseWeakMap ? WeakMap : Map;\nexport const SetImpl = canUseWeakSet ? WeakSet : Set;\n\n// Contextual slot that allows us to disable accessor warnings on fields when in\n// migrate mode.\n/** @internal */\nexport const disableWarningsSlot = new Slot<boolean>();\n\nlet issuedWarning = false;\nexport function warnOnImproperCacheImplementation() {\n  if (!issuedWarning) {\n    issuedWarning = true;\n    invariant.warn(\n      \"The configured cache does not support data masking which effectively disables it. Please use a cache that supports data masking or disable data masking to silence this warning.\"\n    );\n  }\n}\n", "import { Kind } from \"graphql\";\nimport type { FragmentDefinitionNode, SelectionSetNode } from \"graphql\";\nimport {\n  getFragmentMaskMode,\n  maybeDeepFreeze,\n  resultKeyNameFromField,\n} from \"../utilities/index.js\";\nimport type { FragmentMap } from \"../utilities/index.js\";\nimport type { ApolloCache } from \"../cache/index.js\";\nimport { disableWarningsSlot } from \"./utils.js\";\nimport { invariant } from \"../utilities/globals/index.js\";\n\ninterface MaskingContext {\n  operationType: \"query\" | \"mutation\" | \"subscription\" | \"fragment\";\n  operationName: string | undefined;\n  fragmentMap: FragmentMap;\n  cache: ApolloCache<unknown>;\n  mutableTargets: WeakMap<any, any>;\n  knownChanged: WeakSet<any>;\n}\n\nexport function maskDefinition(\n  data: Record<string, any>,\n  selectionSet: SelectionSetNode,\n  context: MaskingContext\n) {\n  return disableWarningsSlot.withValue(true, () => {\n    const masked = maskSelectionSet(data, selectionSet, context, false);\n\n    if (Object.isFrozen(data)) {\n      maybeDeepFreeze(masked);\n    }\n    return masked;\n  });\n}\n\nfunction getMutableTarget(\n  data: Record<string, any>,\n  mutableTargets: WeakMap<any, any>\n): typeof data {\n  if (mutableTargets.has(data)) {\n    return mutableTargets.get(data);\n  }\n\n  const mutableTarget = Array.isArray(data) ? [] : Object.create(null);\n  mutableTargets.set(data, mutableTarget);\n  return mutableTarget;\n}\n\nfunction maskSelectionSet(\n  data: any,\n  selectionSet: SelectionSetNode,\n  context: MaskingContext,\n  migration: boolean,\n  path?: string | undefined\n): typeof data {\n  const { knownChanged } = context;\n  const memo = getMutableTarget(data, context.mutableTargets);\n\n  if (Array.isArray(data)) {\n    for (const [index, item] of Array.from(data.entries())) {\n      if (item === null) {\n        memo[index] = null;\n        continue;\n      }\n\n      const masked = maskSelectionSet(\n        item,\n        selectionSet,\n        context,\n        migration,\n        __DEV__ ? `${path || \"\"}[${index}]` : void 0\n      );\n      if (knownChanged.has(masked)) {\n        knownChanged.add(memo);\n      }\n\n      memo[index] = masked;\n    }\n\n    return knownChanged.has(memo) ? memo : data;\n  }\n\n  for (const selection of selectionSet.selections) {\n    let value: any;\n\n    // we later want to add acessor warnings to the final result\n    // so we need a new object to add the accessor warning to\n    if (migration) {\n      knownChanged.add(memo);\n    }\n\n    if (selection.kind === Kind.FIELD) {\n      const keyName = resultKeyNameFromField(selection);\n      const childSelectionSet = selection.selectionSet;\n\n      value = memo[keyName] || data[keyName];\n\n      if (value === void 0) {\n        continue;\n      }\n\n      if (childSelectionSet && value !== null) {\n        const masked = maskSelectionSet(\n          data[keyName],\n          childSelectionSet,\n          context,\n          migration,\n          __DEV__ ? `${path || \"\"}.${keyName}` : void 0\n        );\n\n        if (knownChanged.has(masked)) {\n          value = masked;\n        }\n      }\n\n      if (!__DEV__) {\n        memo[keyName] = value;\n      }\n      if (__DEV__) {\n        if (\n          migration &&\n          keyName !== \"__typename\" &&\n          // either the field is not present in the memo object\n          // or it has a `get` descriptor, not a `value` descriptor\n          // => it is a warning accessor and we can overwrite it\n          // with another accessor\n          !Object.getOwnPropertyDescriptor(memo, keyName)?.value\n        ) {\n          Object.defineProperty(\n            memo,\n            keyName,\n            getAccessorWarningDescriptor(\n              keyName,\n              value,\n              path || \"\",\n              context.operationName,\n              context.operationType\n            )\n          );\n        } else {\n          delete memo[keyName];\n          memo[keyName] = value;\n        }\n      }\n    }\n\n    if (\n      selection.kind === Kind.INLINE_FRAGMENT &&\n      (!selection.typeCondition ||\n        context.cache.fragmentMatches!(selection, data.__typename))\n    ) {\n      value = maskSelectionSet(\n        data,\n        selection.selectionSet,\n        context,\n        migration,\n        path\n      );\n    }\n\n    if (selection.kind === Kind.FRAGMENT_SPREAD) {\n      const fragmentName = selection.name.value;\n      const fragment: FragmentDefinitionNode | null =\n        context.fragmentMap[fragmentName] ||\n        (context.fragmentMap[fragmentName] =\n          context.cache.lookupFragment(fragmentName)!);\n      invariant(\n        fragment,\n        \"Could not find fragment with name '%s'.\",\n        fragmentName\n      );\n\n      const mode = getFragmentMaskMode(selection);\n\n      if (mode !== \"mask\") {\n        value = maskSelectionSet(\n          data,\n          fragment.selectionSet,\n          context,\n          mode === \"migrate\",\n          path\n        );\n      }\n    }\n\n    if (knownChanged.has(value)) {\n      knownChanged.add(memo);\n    }\n  }\n\n  if (\"__typename\" in data && !(\"__typename\" in memo)) {\n    memo.__typename = data.__typename;\n  }\n\n  // This check prevents cases where masked fields may accidentally be\n  // returned as part of this object when the fragment also selects\n  // additional fields from the same child selection.\n  if (Object.keys(memo).length !== Object.keys(data).length) {\n    knownChanged.add(memo);\n  }\n\n  return knownChanged.has(memo) ? memo : data;\n}\n\nfunction getAccessorWarningDescriptor(\n  fieldName: string,\n  value: any,\n  path: string,\n  operationName: string | undefined,\n  operationType: string\n): PropertyDescriptor {\n  let getValue = () => {\n    if (disableWarningsSlot.getValue()) {\n      return value;\n    }\n\n    invariant.warn(\n      \"Accessing unmasked field on %s at path '%s'. This field will not be available when masking is enabled. Please read the field from the fragment instead.\",\n      operationName ?\n        `${operationType} '${operationName}'`\n      : `anonymous ${operationType}`,\n      `${path}.${fieldName}`.replace(/^\\./, \"\")\n    );\n\n    getValue = () => value;\n\n    return value;\n  };\n\n  return {\n    get() {\n      return getValue();\n    },\n    set(newValue) {\n      getValue = () => newValue;\n    },\n    enumerable: true,\n    configurable: true,\n  };\n}\n", "import { Kind } from \"graphql\";\nimport type { FragmentDefinitionNode } from \"graphql\";\nimport type {\n  ApolloCache,\n  DocumentNode,\n  TypedDocumentNode,\n} from \"../core/index.js\";\nimport {\n  MapImpl,\n  SetImpl,\n  warnOnImproperCacheImplementation,\n} from \"./utils.js\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport equal from \"@wry/equality\";\nimport { maskDefinition } from \"./maskDefinition.js\";\nimport {\n  createFragmentMap,\n  getFragmentDefinitions,\n} from \"../utilities/index.js\";\n\n/** @internal */\nexport function maskFragment<TData = unknown>(\n  data: TData,\n  document: TypedDocumentNode<TData> | DocumentNode,\n  cache: ApolloCache<unknown>,\n  fragmentName?: string\n): TData {\n  if (!cache.fragmentMatches) {\n    if (__DEV__) {\n      warnOnImproperCacheImplementation();\n    }\n\n    return data;\n  }\n\n  const fragments = document.definitions.filter(\n    (node): node is FragmentDefinitionNode =>\n      node.kind === Kind.FRAGMENT_DEFINITION\n  );\n\n  if (typeof fragmentName === \"undefined\") {\n    invariant(\n      fragments.length === 1,\n      `Found %s fragments. \\`fragmentName\\` must be provided when there is not exactly 1 fragment.`,\n      fragments.length\n    );\n    fragmentName = fragments[0].name.value;\n  }\n\n  const fragment = fragments.find(\n    (fragment) => fragment.name.value === fragmentName\n  );\n\n  invariant(\n    !!fragment,\n    `Could not find fragment with name \"%s\".`,\n    fragmentName\n  );\n\n  if (data == null) {\n    // Maintain the original `null` or `undefined` value\n    return data;\n  }\n\n  if (equal(data, {})) {\n    // Return early and skip the masking algorithm if we don't have any data\n    // yet. This can happen when cache.diff returns an empty object which is\n    // used from watchFragment.\n    return data;\n  }\n\n  return maskDefinition(data, fragment.selectionSet, {\n    operationType: \"fragment\",\n    operationName: fragment.name.value,\n    fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n    cache,\n    mutableTargets: new MapImpl(),\n    knownChanged: new SetImpl(),\n  });\n}\n", "import type {\n  ApolloCache,\n  DocumentNode,\n  TypedDocumentNode,\n} from \"../core/index.js\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport {\n  createFragmentMap,\n  getFragmentDefinitions,\n  getOperationDefinition,\n} from \"../utilities/index.js\";\nimport { maskDefinition } from \"./maskDefinition.js\";\nimport {\n  MapImpl,\n  SetImpl,\n  warnOnImproperCacheImplementation,\n} from \"./utils.js\";\n\n/** @internal */\nexport function maskOperation<TData = unknown>(\n  data: TData,\n  document: DocumentNode | TypedDocumentNode<TData>,\n  cache: ApolloCache<unknown>\n): TData {\n  if (!cache.fragmentMatches) {\n    if (__DEV__) {\n      warnOnImproperCacheImplementation();\n    }\n\n    return data;\n  }\n\n  const definition = getOperationDefinition(document);\n\n  invariant(\n    definition,\n    \"Expected a parsed GraphQL document with a query, mutation, or subscription.\"\n  );\n\n  if (data == null) {\n    // Maintain the original `null` or `undefined` value\n    return data;\n  }\n\n  return maskDefinition(data, definition.selectionSet, {\n    operationType: definition.operation,\n    operationName: definition.name?.value,\n    fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n    cache,\n    mutableTargets: new MapImpl(),\n    knownChanged: new SetImpl(),\n  });\n}\n", "export type {\n  DataMasking,\n  FragmentType,\n  Masked,\n  MaskedDocumentNode,\n  MaybeMasked,\n  Unmasked,\n} from \"./types.js\";\nexport { disableWarningsSlot } from \"./utils.js\";\nexport { maskFragment } from \"./maskFragment.js\";\nexport { maskOperation } from \"./maskOperation.js\";\n", "import type {\n  DocumentNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n} from \"graphql\";\nimport { wrap } from \"optimism\";\n\nimport type {\n  StoreObject,\n  Reference,\n  DeepPartial,\n  NoInfer,\n} from \"../../utilities/index.js\";\nimport {\n  Observable,\n  cacheSizes,\n  defaultCacheSizes,\n  getFragmentDefinition,\n  getFragmentQueryDocument,\n  mergeDeepArray,\n} from \"../../utilities/index.js\";\nimport type { DataProxy } from \"./types/DataProxy.js\";\nimport type { Cache } from \"./types/Cache.js\";\nimport { WeakCache } from \"@wry/caches\";\nimport { getApolloCacheMemoryInternals } from \"../../utilities/caching/getMemoryInternals.js\";\nimport type {\n  OperationVariables,\n  TypedDocumentNode,\n} from \"../../core/types.js\";\nimport type { MissingTree } from \"./types/common.js\";\nimport { equalByQuery } from \"../../core/equalByQuery.js\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { maskFragment } from \"../../masking/index.js\";\nimport type {\n  FragmentType,\n  MaybeMasked,\n  Unmasked,\n} from \"../../masking/index.js\";\n\nexport type Transaction<T> = (c: ApolloCache<T>) => void;\n\n/**\n * Watched fragment options.\n */\nexport interface WatchFragmentOptions<TData, TVars> {\n  /**\n   * A GraphQL fragment document parsed into an AST with the `gql`\n   * template literal.\n   *\n   * @docGroup 1. Required options\n   */\n  fragment: DocumentNode | TypedDocumentNode<TData, TVars>;\n  /**\n   * An object containing a `__typename` and primary key fields\n   * (such as `id`) identifying the entity object from which the fragment will\n   * be retrieved, or a `{ __ref: \"...\" }` reference, or a `string` ID\n   * (uncommon).\n   *\n   * @docGroup 1. Required options\n   */\n  from: StoreObject | Reference | FragmentType<NoInfer<TData>> | string;\n  /**\n   * Any variables that the GraphQL fragment may depend on.\n   *\n   * @docGroup 2. Cache options\n   */\n  variables?: TVars;\n  /**\n   * The name of the fragment defined in the fragment document.\n   *\n   * Required if the fragment document includes more than one fragment,\n   * optional otherwise.\n   *\n   * @docGroup 2. Cache options\n   */\n  fragmentName?: string;\n  /**\n   * If `true`, `watchFragment` returns optimistic results.\n   *\n   * The default value is `true`.\n   *\n   * @docGroup 2. Cache options\n   */\n  optimistic?: boolean;\n}\n\n/**\n * Watched fragment results.\n */\nexport type WatchFragmentResult<TData> =\n  | {\n      data: MaybeMasked<TData>;\n      complete: true;\n      missing?: never;\n    }\n  | {\n      data: DeepPartial<MaybeMasked<TData>>;\n      complete: false;\n      missing: MissingTree;\n    };\n\nexport abstract class ApolloCache<TSerialized> implements DataProxy {\n  public readonly assumeImmutableResults: boolean = false;\n\n  // required to implement\n  // core API\n  public abstract read<TData = any, TVariables = any>(\n    query: Cache.ReadOptions<TVariables, TData>\n  ): Unmasked<TData> | null;\n  public abstract write<TData = any, TVariables = any>(\n    write: Cache.WriteOptions<TData, TVariables>\n  ): Reference | undefined;\n  public abstract diff<T>(query: Cache.DiffOptions): Cache.DiffResult<T>;\n  public abstract watch<TData = any, TVariables = any>(\n    watch: Cache.WatchOptions<TData, TVariables>\n  ): () => void;\n\n  // Empty the cache and restart all current watches (unless\n  // options.discardWatches is true).\n  public abstract reset(options?: Cache.ResetOptions): Promise<void>;\n\n  // Remove whole objects from the cache by passing just options.id, or\n  // specific fields by passing options.field and/or options.args. If no\n  // options.args are provided, all fields matching options.field (even\n  // those with arguments) will be removed. Returns true iff any data was\n  // removed from the cache.\n  public abstract evict(options: Cache.EvictOptions): boolean;\n\n  // initializer / offline / ssr API\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public abstract restore(\n    serializedState: TSerialized\n  ): ApolloCache<TSerialized>;\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public abstract extract(optimistic?: boolean): TSerialized;\n\n  // Optimistic API\n\n  public abstract removeOptimistic(id: string): void;\n\n  // Data masking API\n\n  // Used by data masking to determine if an inline fragment with a type\n  // condition matches a given typename.\n  //\n  // If not implemented by a cache subclass, data masking will effectively be\n  // disabled since we will not be able to accurately determine if a given type\n  // condition for a union or interface matches a particular type.\n  public fragmentMatches?(\n    fragment: InlineFragmentNode,\n    typename: string\n  ): boolean;\n\n  // Function used to lookup a fragment when a fragment definition is not part\n  // of the GraphQL document. This is useful for caches, such as InMemoryCache,\n  // that register fragments ahead of time so they can be referenced by name.\n  public lookupFragment(fragmentName: string): FragmentDefinitionNode | null {\n    return null;\n  }\n\n  // Transactional API\n\n  // The batch method is intended to replace/subsume both performTransaction\n  // and recordOptimisticTransaction, but performTransaction came first, so we\n  // provide a default batch implementation that's just another way of calling\n  // performTransaction. Subclasses of ApolloCache (such as InMemoryCache) can\n  // override the batch method to do more interesting things with its options.\n  public batch<U>(options: Cache.BatchOptions<this, U>): U {\n    const optimisticId =\n      typeof options.optimistic === \"string\" ? options.optimistic\n      : options.optimistic === false ? null\n      : void 0;\n    let updateResult: U;\n    this.performTransaction(\n      () => (updateResult = options.update(this)),\n      optimisticId\n    );\n    return updateResult!;\n  }\n\n  public abstract performTransaction(\n    transaction: Transaction<TSerialized>,\n    // Although subclasses may implement recordOptimisticTransaction\n    // however they choose, the default implementation simply calls\n    // performTransaction with a string as the second argument, allowing\n    // performTransaction to handle both optimistic and non-optimistic\n    // (broadcast-batching) transactions. Passing null for optimisticId is\n    // also allowed, and indicates that performTransaction should apply\n    // the transaction non-optimistically (ignoring optimistic data).\n    optimisticId?: string | null\n  ): void;\n\n  public recordOptimisticTransaction(\n    transaction: Transaction<TSerialized>,\n    optimisticId: string\n  ) {\n    this.performTransaction(transaction, optimisticId);\n  }\n\n  // Optional API\n\n  // Called once per input document, allowing the cache to make static changes\n  // to the query, such as adding __typename fields.\n  public transformDocument(document: DocumentNode): DocumentNode {\n    return document;\n  }\n\n  // Called before each ApolloLink request, allowing the cache to make dynamic\n  // changes to the query, such as filling in missing fragment definitions.\n  public transformForLink(document: DocumentNode): DocumentNode {\n    return document;\n  }\n\n  public identify(object: StoreObject | Reference): string | undefined {\n    return;\n  }\n\n  public gc(): string[] {\n    return [];\n  }\n\n  public modify<Entity extends Record<string, any> = Record<string, any>>(\n    options: Cache.ModifyOptions<Entity>\n  ): boolean {\n    return false;\n  }\n\n  // DataProxy API\n  public readQuery<QueryType, TVariables = any>(\n    options: Cache.ReadQueryOptions<QueryType, TVariables>,\n    optimistic = !!options.optimistic\n  ): Unmasked<QueryType> | null {\n    return this.read({\n      ...options,\n      rootId: options.id || \"ROOT_QUERY\",\n      optimistic,\n    });\n  }\n\n  /** {@inheritDoc @apollo/client!ApolloClient#watchFragment:member(1)} */\n  public watchFragment<TData = any, TVars = OperationVariables>(\n    options: WatchFragmentOptions<TData, TVars>\n  ): Observable<WatchFragmentResult<TData>> {\n    const {\n      fragment,\n      fragmentName,\n      from,\n      optimistic = true,\n      ...otherOptions\n    } = options;\n    const query = this.getFragmentDoc(fragment, fragmentName);\n    // While our TypeScript types do not allow for `undefined` as a valid\n    // `from`, its possible `useFragment` gives us an `undefined` since it\n    // calls` cache.identify` and provides that value to `from`. We are\n    // adding this fix here however to ensure those using plain JavaScript\n    // and using `cache.identify` themselves will avoid seeing the obscure\n    // warning.\n    const id =\n      typeof from === \"undefined\" || typeof from === \"string\" ?\n        from\n      : this.identify(from);\n    const dataMasking = !!(options as any)[Symbol.for(\"apollo.dataMasking\")];\n\n    if (__DEV__) {\n      const actualFragmentName =\n        fragmentName || getFragmentDefinition(fragment).name.value;\n\n      if (!id) {\n        invariant.warn(\n          \"Could not identify object passed to `from` for '%s' fragment, either because the object is non-normalized or the key fields are missing. If you are masking this object, please ensure the key fields are requested by the parent object.\",\n          actualFragmentName\n        );\n      }\n    }\n\n    const diffOptions: Cache.DiffOptions<TData, TVars> = {\n      ...otherOptions,\n      returnPartialData: true,\n      id,\n      query,\n      optimistic,\n    };\n\n    let latestDiff: DataProxy.DiffResult<TData> | undefined;\n\n    return new Observable((observer) => {\n      return this.watch<TData, TVars>({\n        ...diffOptions,\n        immediate: true,\n        callback: (diff) => {\n          const data =\n            dataMasking ?\n              maskFragment(diff.result, fragment, this, fragmentName)\n            : diff.result;\n\n          if (\n            // Always ensure we deliver the first result\n            latestDiff &&\n            equalByQuery(\n              query,\n              { data: latestDiff.result },\n              { data },\n              // TODO: Fix the type on WatchFragmentOptions so that TVars\n              // extends OperationVariables\n              options.variables as OperationVariables\n            )\n          ) {\n            return;\n          }\n\n          const result = {\n            data,\n            complete: !!diff.complete,\n          } as WatchFragmentResult<TData>;\n\n          if (diff.missing) {\n            result.missing = mergeDeepArray(\n              diff.missing.map((error) => error.missing)\n            );\n          }\n\n          latestDiff = { ...diff, result: data };\n          observer.next(result);\n        },\n      });\n    });\n  }\n\n  // Make sure we compute the same (===) fragment query document every\n  // time we receive the same fragment in readFragment.\n  private getFragmentDoc = wrap(getFragmentQueryDocument, {\n    max:\n      cacheSizes[\"cache.fragmentQueryDocuments\"] ||\n      defaultCacheSizes[\"cache.fragmentQueryDocuments\"],\n    cache: WeakCache,\n  });\n\n  public readFragment<FragmentType, TVariables = any>(\n    options: Cache.ReadFragmentOptions<FragmentType, TVariables>,\n    optimistic = !!options.optimistic\n  ): Unmasked<FragmentType> | null {\n    return this.read({\n      ...options,\n      query: this.getFragmentDoc(options.fragment, options.fragmentName),\n      rootId: options.id,\n      optimistic,\n    });\n  }\n\n  public writeQuery<TData = any, TVariables = any>({\n    id,\n    data,\n    ...options\n  }: Cache.WriteQueryOptions<TData, TVariables>): Reference | undefined {\n    return this.write(\n      Object.assign(options, {\n        dataId: id || \"ROOT_QUERY\",\n        result: data,\n      })\n    );\n  }\n\n  public writeFragment<TData = any, TVariables = any>({\n    id,\n    data,\n    fragment,\n    fragmentName,\n    ...options\n  }: Cache.WriteFragmentOptions<TData, TVariables>): Reference | undefined {\n    return this.write(\n      Object.assign(options, {\n        query: this.getFragmentDoc(fragment, fragmentName),\n        dataId: id,\n        result: data,\n      })\n    );\n  }\n\n  public updateQuery<TData = any, TVariables = any>(\n    options: Cache.UpdateQueryOptions<TData, TVariables>,\n    update: (data: Unmasked<TData> | null) => Unmasked<TData> | null | void\n  ): Unmasked<TData> | null {\n    return this.batch({\n      update(cache) {\n        const value = cache.readQuery<TData, TVariables>(options);\n        const data = update(value);\n        if (data === void 0 || data === null) return value;\n        cache.writeQuery<TData, TVariables>({ ...options, data });\n        return data;\n      },\n    });\n  }\n\n  public updateFragment<TData = any, TVariables = any>(\n    options: Cache.UpdateFragmentOptions<TData, TVariables>,\n    update: (data: Unmasked<TData> | null) => Unmasked<TData> | null | void\n  ): Unmasked<TData> | null {\n    return this.batch({\n      update(cache) {\n        const value = cache.readFragment<TData, TVariables>(options);\n        const data = update(value);\n        if (data === void 0 || data === null) return value;\n        cache.writeFragment<TData, TVariables>({ ...options, data });\n        return data;\n      },\n    });\n  }\n\n  /**\n   * @experimental\n   * @internal\n   * This is not a stable API - it is used in development builds to expose\n   * information to the DevTools.\n   * Use at your own risk!\n   */\n  public getMemoryInternals?: typeof getApolloCacheMemoryInternals;\n}\n\nif (__DEV__) {\n  ApolloCache.prototype.getMemoryInternals = getApolloCacheMemoryInternals;\n}\n", "import { DataProxy } from \"./DataProxy.js\";\nimport type { AllFieldsModifier, Modifiers } from \"./common.js\";\nimport type { ApolloCache } from \"../cache.js\";\nimport type { Unmasked } from \"../../../masking/index.js\";\n\nexport namespace Cache {\n  export type WatchCallback<TData = any> = (\n    diff: Cache.DiffResult<TData>,\n    lastDiff?: Cache.DiffResult<TData>\n  ) => void;\n\n  export interface ReadOptions<TVariables = any, TData = any>\n    extends DataProxy.Query<TVariables, TData> {\n    rootId?: string;\n    previousResult?: any;\n    optimistic: boolean;\n    returnPartialData?: boolean;\n    /**\n     * @deprecated\n     * Using `canonizeResults` can result in memory leaks so we generally do not\n     * recommend using this option anymore.\n     * A future version of Apollo Client will contain a similar feature without\n     * the risk of memory leaks.\n     */\n    canonizeResults?: boolean;\n  }\n\n  export interface WriteOptions<TResult = any, TVariables = any>\n    extends Omit<DataProxy.Query<TVariables, TResult>, \"id\">,\n      Omit<DataProxy.WriteOptions<TResult>, \"data\"> {\n    dataId?: string;\n    result: Unmasked<TResult>;\n  }\n\n  export interface DiffOptions<TData = any, TVariables = any>\n    extends Omit<ReadOptions<TVariables, TData>, \"rootId\"> {\n    // The DiffOptions interface is currently just an alias for\n    // ReadOptions, though DiffOptions used to be responsible for\n    // declaring the returnPartialData option.\n  }\n\n  export interface WatchOptions<TData = any, TVariables = any>\n    extends DiffOptions<TData, TVariables> {\n    watcher?: object;\n    immediate?: boolean;\n    callback: WatchCallback<TData>;\n    lastDiff?: DiffResult<TData>;\n  }\n\n  export interface EvictOptions {\n    id?: string;\n    fieldName?: string;\n    args?: Record<string, any>;\n    broadcast?: boolean;\n  }\n\n  // Although you can call cache.reset() without options, its behavior can be\n  // configured by passing a Cache.ResetOptions object.\n  export interface ResetOptions {\n    discardWatches?: boolean;\n  }\n\n  export interface ModifyOptions<\n    Entity extends Record<string, any> = Record<string, any>,\n  > {\n    id?: string;\n    fields: Modifiers<Entity> | AllFieldsModifier<Entity>;\n    optimistic?: boolean;\n    broadcast?: boolean;\n  }\n\n  export interface BatchOptions<\n    TCache extends ApolloCache<any>,\n    TUpdateResult = void,\n  > {\n    // Same as the first parameter of performTransaction, except the cache\n    // argument will have the subclass type rather than ApolloCache.\n    update(cache: TCache): TUpdateResult;\n\n    // Passing a string for this option creates a new optimistic layer, with the\n    // given string as its layer.id, just like passing a string for the\n    // optimisticId parameter of performTransaction. Passing true is the same as\n    // passing undefined to performTransaction (running the batch operation\n    // against the current top layer of the cache), and passing false is the\n    // same as passing null (running the operation against root/non-optimistic\n    // cache data).\n    optimistic?: string | boolean;\n\n    // If you specify the ID of an optimistic layer using this option, that\n    // layer will be removed as part of the batch transaction, triggering at\n    // most one broadcast for both the transaction and the removal of the layer.\n    // Note: this option is needed because calling cache.removeOptimistic during\n    // the transaction function may not be not safe, since any modifications to\n    // cache layers may be discarded after the transaction finishes.\n    removeOptimistic?: string;\n\n    // If you want to find out which watched queries were invalidated during\n    // this batch operation, pass this optional callback function. Returning\n    // false from the callback will prevent broadcasting this result.\n    onWatchUpdated?: (\n      this: TCache,\n      watch: Cache.WatchOptions,\n      diff: Cache.DiffResult<any>,\n      lastDiff?: Cache.DiffResult<any> | undefined\n    ) => any;\n  }\n\n  export import DiffResult = DataProxy.DiffResult;\n  export import ReadQueryOptions = DataProxy.ReadQueryOptions;\n  export import ReadFragmentOptions = DataProxy.ReadFragmentOptions;\n  export import WriteQueryOptions = DataProxy.WriteQueryOptions;\n  export import WriteFragmentOptions = DataProxy.WriteFragmentOptions;\n  export import UpdateQueryOptions = DataProxy.UpdateQueryOptions;\n  export import UpdateFragmentOptions = DataProxy.UpdateFragmentOptions;\n  export import Fragment = DataProxy.Fragment;\n}\n", "import type { DocumentNode, FieldNode } from \"graphql\";\n\nimport type {\n  Reference,\n  StoreObject,\n  StoreValue,\n  isReference,\n  AsStoreObject,\n  DeepPartial,\n} from \"../../../utilities/index.js\";\n\nimport type { StorageType } from \"../../inmemory/policies.js\";\n\n// The Readonly<T> type only really works for object types, since it marks\n// all of the object's properties as readonly, but there are many cases when\n// a generic type parameter like TExisting might be a string or some other\n// primitive type, in which case we need to avoid wrapping it with Readonly.\n// SafeReadonly<string> collapses to just string, which makes string\n// assignable to SafeReadonly<any>, whereas string is not assignable to\n// Readonly<any>, somewhat surprisingly.\nexport type SafeReadonly<T> = T extends object ? Readonly<T> : T;\n\nexport type MissingTree =\n  | string\n  | {\n      readonly [key: string]: MissingTree;\n    };\n\nexport class MissingFieldError extends Error {\n  constructor(\n    public readonly message: string,\n    public readonly path: MissingTree | Array<string | number>,\n    public readonly query: DocumentNode,\n    public readonly variables?: Record<string, any>\n  ) {\n    // 'Error' breaks prototype chain here\n    super(message);\n\n    if (Array.isArray(this.path)) {\n      this.missing = this.message;\n      for (let i = this.path.length - 1; i >= 0; --i) {\n        this.missing = { [this.path[i]]: this.missing };\n      }\n    } else {\n      this.missing = this.path;\n    }\n\n    // We're not using `Object.setPrototypeOf` here as it isn't fully supported\n    // on Android (see issue #3236).\n    (this as any).__proto__ = MissingFieldError.prototype;\n  }\n\n  public readonly missing: MissingTree;\n}\n\nexport interface FieldSpecifier {\n  typename?: string;\n  fieldName: string;\n  field?: FieldNode;\n  args?: Record<string, any>;\n  variables?: Record<string, any>;\n}\n\nexport interface ReadFieldOptions extends FieldSpecifier {\n  from?: StoreObject | Reference;\n}\n\nexport interface ReadFieldFunction {\n  <V = StoreValue>(options: ReadFieldOptions): SafeReadonly<V> | undefined;\n  <V = StoreValue>(\n    fieldName: string,\n    from?: StoreObject | Reference\n  ): SafeReadonly<V> | undefined;\n}\n\nexport type ToReferenceFunction = (\n  objOrIdOrRef: StoreObject | string | Reference,\n  mergeIntoStore?: boolean\n) => Reference | undefined;\n\nexport type CanReadFunction = (value: StoreValue) => boolean;\n\ndeclare const _deleteModifier: unique symbol;\nexport interface DeleteModifier {\n  [_deleteModifier]: true;\n}\ndeclare const _invalidateModifier: unique symbol;\nexport interface InvalidateModifier {\n  [_invalidateModifier]: true;\n}\ndeclare const _ignoreModifier: unique symbol;\nexport interface IgnoreModifier {\n  [_ignoreModifier]: true;\n}\n\nexport type ModifierDetails = {\n  DELETE: DeleteModifier;\n  INVALIDATE: InvalidateModifier;\n  fieldName: string;\n  storeFieldName: string;\n  readField: ReadFieldFunction;\n  canRead: CanReadFunction;\n  isReference: typeof isReference;\n  toReference: ToReferenceFunction;\n  storage: StorageType;\n};\n\nexport type Modifier<T> = (\n  value: T,\n  details: ModifierDetails\n) => DeepPartial<T> | DeleteModifier | InvalidateModifier | undefined;\n\ntype StoreObjectValueMaybeReference<StoreVal> =\n  StoreVal extends Array<Record<string, any>> ?\n    StoreVal extends Array<infer Item> ?\n      [Item] extends [Record<string, any>] ?\n        ReadonlyArray<AsStoreObject<Item> | Reference>\n      : never\n    : never\n  : StoreVal extends Record<string, any> ? AsStoreObject<StoreVal> | Reference\n  : StoreVal;\n\nexport type AllFieldsModifier<Entity extends Record<string, any>> = Modifier<\n  Entity[keyof Entity] extends infer Value ?\n    StoreObjectValueMaybeReference<Exclude<Value, undefined>>\n  : never\n>;\n\nexport type Modifiers<T extends Record<string, any> = Record<string, unknown>> =\n  Partial<{\n    [FieldName in keyof T]: Modifier<\n      StoreObjectValueMaybeReference<Exclude<T[FieldName], undefined>>\n    >;\n  }>;\n", "import type {\n  DocumentNode,\n  FragmentDefinitionNode,\n  SelectionSetNode,\n} from \"graphql\";\n\nimport type { NormalizedCache, InMemoryCacheConfig } from \"./types.js\";\n\nimport type { KeyFieldsContext } from \"./policies.js\";\nimport type { FragmentRegistryAPI } from \"./fragmentRegistry.js\";\n\nimport type {\n  Reference,\n  StoreValue,\n  StoreObject,\n  FragmentMap,\n  FragmentMapFunction,\n} from \"../../utilities/index.js\";\nimport {\n  isReference,\n  isField,\n  DeepMerger,\n  resultKeyNameFromField,\n  shouldInclude,\n  isNonNullObject,\n  compact,\n  createFragmentMap,\n  getFragmentDefinitions,\n  isArray,\n} from \"../../utilities/index.js\";\n\nexport const { hasOwnProperty: hasOwn } = Object.prototype;\n\nexport function isNullish(value: any): value is null | undefined {\n  return value === null || value === void 0;\n}\n\nexport { isArray };\n\nexport function defaultDataIdFromObject(\n  { __typename, id, _id }: Readonly<StoreObject>,\n  context?: KeyFieldsContext\n): string | undefined {\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject =\n        !isNullish(id) ? { id }\n        : !isNullish(_id) ? { _id }\n        : void 0;\n    }\n\n    // If there is no object.id, fall back to object._id.\n    if (isNullish(id) && !isNullish(_id)) {\n      id = _id;\n    }\n\n    if (!isNullish(id)) {\n      return `${__typename}:${\n        typeof id === \"number\" || typeof id === \"string\" ?\n          id\n        : JSON.stringify(id)\n      }`;\n    }\n  }\n}\n\nconst defaultConfig = {\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  // Thanks to the shouldCanonizeResults helper, this should be the only line\n  // you have to change to reenable canonization by default in the future.\n  canonizeResults: false,\n};\n\nexport function normalizeConfig(config: InMemoryCacheConfig) {\n  return compact(defaultConfig, config);\n}\n\nexport function shouldCanonizeResults(\n  config: Pick<InMemoryCacheConfig, \"canonizeResults\">\n): boolean {\n  const value = config.canonizeResults;\n  return value === void 0 ? defaultConfig.canonizeResults : value;\n}\n\nexport function getTypenameFromStoreObject(\n  store: NormalizedCache,\n  objectOrReference: StoreObject | Reference\n): string | undefined {\n  return isReference(objectOrReference) ?\n      (store.get(objectOrReference.__ref, \"__typename\") as string)\n    : objectOrReference && objectOrReference.__typename;\n}\n\nexport const TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\n\nexport function fieldNameFromStoreName(storeFieldName: string): string {\n  const match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\n\nexport function selectionSetMatchesResult(\n  selectionSet: SelectionSetNode,\n  result: Record<string, any>,\n  variables?: Record<string, any>\n): boolean {\n  if (isNonNullObject(result)) {\n    return isArray(result) ?\n        result.every((item) =>\n          selectionSetMatchesResult(selectionSet, item, variables)\n        )\n      : selectionSet.selections.every((field) => {\n          if (isField(field) && shouldInclude(field, variables)) {\n            const key = resultKeyNameFromField(field);\n            return (\n              hasOwn.call(result, key) &&\n              (!field.selectionSet ||\n                selectionSetMatchesResult(\n                  field.selectionSet,\n                  result[key],\n                  variables\n                ))\n            );\n          }\n          // If the selection has been skipped with @skip(true) or\n          // @include(false), it should not count against the matching. If\n          // the selection is not a field, it must be a fragment (inline or\n          // named). We will determine if selectionSetMatchesResult for that\n          // fragment when we get to it, so for now we return true.\n          return true;\n        });\n  }\n  return false;\n}\n\nexport function storeValueIsStoreObject(\n  value: StoreValue\n): value is StoreObject {\n  return isNonNullObject(value) && !isReference(value) && !isArray(value);\n}\n\nexport function makeProcessedFieldsMerger() {\n  return new DeepMerger();\n}\n\nexport function extractFragmentContext(\n  document: DocumentNode,\n  fragments?: FragmentRegistryAPI\n): {\n  fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n} {\n  // FragmentMap consisting only of fragments defined directly in document, not\n  // including other fragments registered in the FragmentRegistry.\n  const fragmentMap = createFragmentMap(getFragmentDefinitions(document));\n  return {\n    fragmentMap,\n    lookupFragment(name) {\n      let def: FragmentDefinitionNode | null = fragmentMap[name];\n      if (!def && fragments) {\n        def = fragments.lookup(name);\n      }\n      return def || null;\n    },\n  };\n}\n", "import type { OptimisticDependencyFunction } from \"optimism\";\nimport { dep, Slot } from \"optimism\";\nimport type { InMemoryCache } from \"./inMemoryCache.js\";\nimport type { ApolloCache } from \"../../core/index.js\";\n\nexport interface ReactiveVar<T> {\n  (newValue?: T): T;\n  onNextChange(listener: ReactiveListener<T>): () => void;\n  attachCache(cache: ApolloCache<any>): this;\n  forgetCache(cache: ApolloCache<any>): boolean;\n}\n\nexport type ReactiveListener<T> = (value: T) => any;\n\n// Contextual Slot that acquires its value when custom read functions are\n// called in Policies#readField.\nexport const cacheSlot = new Slot<ApolloCache<any>>();\n\nconst cacheInfoMap = new WeakMap<\n  ApolloCache<any>,\n  {\n    vars: Set<ReactiveVar<any>>;\n    dep: OptimisticDependencyFunction<ReactiveVar<any>>;\n  }\n>();\n\nfunction getCacheInfo(cache: ApolloCache<any>) {\n  let info = cacheInfoMap.get(cache)!;\n  if (!info) {\n    cacheInfoMap.set(\n      cache,\n      (info = {\n        vars: new Set(),\n        dep: dep(),\n      })\n    );\n  }\n  return info;\n}\n\nexport function forgetCache(cache: ApolloCache<any>) {\n  getCacheInfo(cache).vars.forEach((rv) => rv.forgetCache(cache));\n}\n\n// Calling forgetCache(cache) serves to silence broadcasts and allows the\n// cache to be garbage collected. However, the varsByCache WeakMap\n// preserves the set of reactive variables that were previously associated\n// with this cache, which makes it possible to \"recall\" the cache at a\n// later time, by reattaching it to those variables. If the cache has been\n// garbage collected in the meantime, because it is no longer reachable,\n// you won't be able to call recallCache(cache), and the cache will\n// automatically disappear from the varsByCache WeakMap.\nexport function recallCache(cache: ApolloCache<any>) {\n  getCacheInfo(cache).vars.forEach((rv) => rv.attachCache(cache));\n}\n\nexport function makeVar<T>(value: T): ReactiveVar<T> {\n  const caches = new Set<ApolloCache<any>>();\n  const listeners = new Set<ReactiveListener<T>>();\n\n  const rv: ReactiveVar<T> = function (newValue) {\n    if (arguments.length > 0) {\n      if (value !== newValue) {\n        value = newValue!;\n        caches.forEach((cache) => {\n          // Invalidate any fields with custom read functions that\n          // consumed this variable, so query results involving those\n          // fields will be recomputed the next time we read them.\n          getCacheInfo(cache).dep.dirty(rv);\n          // Broadcast changes to any caches that have previously read\n          // from this variable.\n          broadcast(cache);\n        });\n        // Finally, notify any listeners added via rv.onNextChange.\n        const oldListeners = Array.from(listeners);\n        listeners.clear();\n        oldListeners.forEach((listener) => listener(value));\n      }\n    } else {\n      // When reading from the variable, obtain the current cache from\n      // context via cacheSlot. This isn't entirely foolproof, but it's\n      // the same system that powers varDep.\n      const cache = cacheSlot.getValue();\n      if (cache) {\n        attach(cache);\n        getCacheInfo(cache).dep(rv);\n      }\n    }\n\n    return value;\n  };\n\n  rv.onNextChange = (listener) => {\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n    };\n  };\n\n  const attach = (rv.attachCache = (cache) => {\n    caches.add(cache);\n    getCacheInfo(cache).vars.add(rv);\n    return rv;\n  });\n\n  rv.forgetCache = (cache) => caches.delete(cache);\n\n  return rv;\n}\n\ntype Broadcastable = ApolloCache<any> & {\n  // This method is protected in InMemoryCache, which we are ignoring, but\n  // we still want some semblance of type safety when we call it.\n  broadcastWatches?: InMemoryCache[\"broadcastWatches\"];\n};\n\nfunction broadcast(cache: Broadcastable) {\n  if (cache.broadcastWatches) {\n    cache.broadcastWatches();\n  }\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\nimport type { OptimisticDependencyFunction } from \"optimism\";\nimport { dep } from \"optimism\";\nimport { equal } from \"@wry/equality\";\nimport { Trie } from \"@wry/trie\";\n\nimport type {\n  StoreValue,\n  StoreObject,\n  Reference,\n} from \"../../utilities/index.js\";\nimport {\n  isReference,\n  makeReference,\n  DeepMerger,\n  maybeDeepFreeze,\n  canUseWeakMap,\n  isNonNullObject,\n} from \"../../utilities/index.js\";\nimport type { NormalizedCache, NormalizedCacheObject } from \"./types.js\";\nimport { hasOwn, fieldNameFromStoreName } from \"./helpers.js\";\nimport type { Policies, StorageType } from \"./policies.js\";\nimport type { Cache } from \"../core/types/Cache.js\";\nimport type {\n  SafeReadonly,\n  Modifier,\n  Modifiers,\n  ReadFieldOptions,\n  ToReferenceFunction,\n  CanReadFunction,\n  InvalidateModifier,\n  DeleteModifier,\n  ModifierDetails,\n} from \"../core/types/common.js\";\nimport type { DocumentNode, FieldNode, SelectionSetNode } from \"graphql\";\n\nconst DELETE: DeleteModifier = Object.create(null);\nconst delModifier: Modifier<any> = () => DELETE;\nconst INVALIDATE: InvalidateModifier = Object.create(null);\n\nexport abstract class EntityStore implements NormalizedCache {\n  protected data: NormalizedCacheObject = Object.create(null);\n\n  constructor(\n    public readonly policies: Policies,\n    public readonly group: CacheGroup\n  ) {}\n\n  public abstract addLayer(\n    layerId: string,\n    replay: (layer: EntityStore) => any\n  ): Layer;\n\n  public abstract removeLayer(layerId: string): EntityStore;\n\n  // Although the EntityStore class is abstract, it contains concrete\n  // implementations of the various NormalizedCache interface methods that\n  // are inherited by the Root and Layer subclasses.\n\n  public toObject(): NormalizedCacheObject {\n    return { ...this.data };\n  }\n\n  public has(dataId: string): boolean {\n    return this.lookup(dataId, true) !== void 0;\n  }\n\n  public get(dataId: string, fieldName: string): StoreValue {\n    this.group.depend(dataId, fieldName);\n    if (hasOwn.call(this.data, dataId)) {\n      const storeObject = this.data[dataId];\n      if (storeObject && hasOwn.call(storeObject, fieldName)) {\n        return storeObject[fieldName];\n      }\n    }\n    if (\n      fieldName === \"__typename\" &&\n      hasOwn.call(this.policies.rootTypenamesById, dataId)\n    ) {\n      return this.policies.rootTypenamesById[dataId];\n    }\n    if (this instanceof Layer) {\n      return this.parent.get(dataId, fieldName);\n    }\n  }\n\n  protected lookup(\n    dataId: string,\n    dependOnExistence?: boolean\n  ): StoreObject | undefined {\n    // The has method (above) calls lookup with dependOnExistence = true, so\n    // that it can later be invalidated when we add or remove a StoreObject for\n    // this dataId. Any consumer who cares about the contents of the StoreObject\n    // should not rely on this dependency, since the contents could change\n    // without the object being added or removed.\n    if (dependOnExistence) this.group.depend(dataId, \"__exists\");\n\n    if (hasOwn.call(this.data, dataId)) {\n      return this.data[dataId];\n    }\n\n    if (this instanceof Layer) {\n      return this.parent.lookup(dataId, dependOnExistence);\n    }\n\n    if (this.policies.rootTypenamesById[dataId]) {\n      return Object.create(null);\n    }\n  }\n\n  public merge(older: string | StoreObject, newer: StoreObject | string): void {\n    let dataId: string | undefined;\n\n    // Convert unexpected references to ID strings.\n    if (isReference(older)) older = older.__ref;\n    if (isReference(newer)) newer = newer.__ref;\n\n    const existing: StoreObject | undefined =\n      typeof older === \"string\" ? this.lookup((dataId = older)) : older;\n\n    const incoming: StoreObject | undefined =\n      typeof newer === \"string\" ? this.lookup((dataId = newer)) : newer;\n\n    // If newer was a string ID, but that ID was not defined in this store,\n    // then there are no fields to be merged, so we're done.\n    if (!incoming) return;\n\n    invariant(typeof dataId === \"string\", \"store.merge expects a string ID\");\n\n    const merged: StoreObject = new DeepMerger(storeObjectReconciler).merge(\n      existing,\n      incoming\n    );\n\n    // Even if merged === existing, existing may have come from a lower\n    // layer, so we always need to set this.data[dataId] on this level.\n    this.data[dataId] = merged;\n\n    if (merged !== existing) {\n      delete this.refs[dataId];\n      if (this.group.caching) {\n        const fieldsToDirty: Record<string, 1> = Object.create(null);\n\n        // If we added a new StoreObject where there was previously none, dirty\n        // anything that depended on the existence of this dataId, such as the\n        // EntityStore#has method.\n        if (!existing) fieldsToDirty.__exists = 1;\n\n        // Now invalidate dependents who called getFieldValue for any fields\n        // that are changing as a result of this merge.\n        Object.keys(incoming).forEach((storeFieldName) => {\n          if (\n            !existing ||\n            existing[storeFieldName] !== merged[storeFieldName]\n          ) {\n            // Always dirty the full storeFieldName, which may include\n            // serialized arguments following the fieldName prefix.\n            fieldsToDirty[storeFieldName] = 1;\n\n            // Also dirty fieldNameFromStoreName(storeFieldName) if it's\n            // different from storeFieldName and this field does not have\n            // keyArgs configured, because that means the cache can't make\n            // any assumptions about how field values with the same field\n            // name but different arguments might be interrelated, so it\n            // must err on the side of invalidating all field values that\n            // share the same short fieldName, regardless of arguments.\n            const fieldName = fieldNameFromStoreName(storeFieldName);\n            if (\n              fieldName !== storeFieldName &&\n              !this.policies.hasKeyArgs(merged.__typename, fieldName)\n            ) {\n              fieldsToDirty[fieldName] = 1;\n            }\n\n            // If merged[storeFieldName] has become undefined, and this is the\n            // Root layer, actually delete the property from the merged object,\n            // which is guaranteed to have been created fresh in this method.\n            if (merged[storeFieldName] === void 0 && !(this instanceof Layer)) {\n              delete merged[storeFieldName];\n            }\n          }\n        });\n\n        if (\n          fieldsToDirty.__typename &&\n          !(existing && existing.__typename) &&\n          // Since we return default root __typename strings\n          // automatically from store.get, we don't need to dirty the\n          // ROOT_QUERY.__typename field if merged.__typename is equal\n          // to the default string (usually \"Query\").\n          this.policies.rootTypenamesById[dataId] === merged.__typename\n        ) {\n          delete fieldsToDirty.__typename;\n        }\n\n        Object.keys(fieldsToDirty).forEach((fieldName) =>\n          this.group.dirty(dataId as string, fieldName)\n        );\n      }\n    }\n  }\n\n  public modify(\n    dataId: string,\n    fields: Modifier<any> | Modifiers<Record<string, any>>\n  ): boolean {\n    const storeObject = this.lookup(dataId);\n\n    if (storeObject) {\n      const changedFields: Record<string, any> = Object.create(null);\n      let needToMerge = false;\n      let allDeleted = true;\n\n      const sharedDetails = {\n        DELETE,\n        INVALIDATE,\n        isReference,\n        toReference: this.toReference,\n        canRead: this.canRead,\n        readField: <V = StoreValue>(\n          fieldNameOrOptions: string | ReadFieldOptions,\n          from?: StoreObject | Reference\n        ) =>\n          this.policies.readField<V>(\n            typeof fieldNameOrOptions === \"string\" ?\n              {\n                fieldName: fieldNameOrOptions,\n                from: from || makeReference(dataId),\n              }\n            : fieldNameOrOptions,\n            { store: this }\n          ),\n      } satisfies Partial<ModifierDetails>;\n\n      Object.keys(storeObject).forEach((storeFieldName) => {\n        const fieldName = fieldNameFromStoreName(storeFieldName);\n        let fieldValue = storeObject[storeFieldName];\n        if (fieldValue === void 0) return;\n        const modify: Modifier<StoreValue> | undefined =\n          typeof fields === \"function\" ? fields : (\n            fields[storeFieldName] || fields[fieldName]\n          );\n        if (modify) {\n          let newValue =\n            modify === delModifier ? DELETE : (\n              modify(maybeDeepFreeze(fieldValue), {\n                ...sharedDetails,\n                fieldName,\n                storeFieldName,\n                storage: this.getStorage(dataId, storeFieldName),\n              })\n            );\n          if (newValue === INVALIDATE) {\n            this.group.dirty(dataId, storeFieldName);\n          } else {\n            if (newValue === DELETE) newValue = void 0;\n            if (newValue !== fieldValue) {\n              changedFields[storeFieldName] = newValue;\n              needToMerge = true;\n              fieldValue = newValue as StoreValue;\n\n              if (__DEV__) {\n                const checkReference = (ref: Reference) => {\n                  if (this.lookup(ref.__ref) === undefined) {\n                    invariant.warn(\n                      \"cache.modify: You are trying to write a Reference that is not part of the store: %o\\n\" +\n                        \"Please make sure to set the `mergeIntoStore` parameter to `true` when creating a Reference that is not part of the store yet:\\n\" +\n                        \"`toReference(object, true)`\",\n                      ref\n                    );\n                    return true;\n                  }\n                };\n                if (isReference(newValue)) {\n                  checkReference(newValue);\n                } else if (Array.isArray(newValue)) {\n                  // Warn about writing \"mixed\" arrays of Reference and non-Reference objects\n                  let seenReference: boolean = false;\n                  let someNonReference: unknown;\n                  for (const value of newValue) {\n                    if (isReference(value)) {\n                      seenReference = true;\n                      if (checkReference(value)) break;\n                    } else {\n                      // Do not warn on primitive values, since those could never be represented\n                      // by a reference. This is a valid (albeit uncommon) use case.\n                      if (typeof value === \"object\" && !!value) {\n                        const [id] = this.policies.identify(value);\n                        // check if object could even be referenced, otherwise we are not interested in it for this warning\n                        if (id) {\n                          someNonReference = value;\n                        }\n                      }\n                    }\n                    if (seenReference && someNonReference !== undefined) {\n                      invariant.warn(\n                        \"cache.modify: Writing an array with a mix of both References and Objects will not result in the Objects being normalized correctly.\\n\" +\n                          \"Please convert the object instance %o to a Reference before writing it to the cache by calling `toReference(object, true)`.\",\n                        someNonReference\n                      );\n                      break;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (fieldValue !== void 0) {\n          allDeleted = false;\n        }\n      });\n\n      if (needToMerge) {\n        this.merge(dataId, changedFields);\n\n        if (allDeleted) {\n          if (this instanceof Layer) {\n            this.data[dataId] = void 0;\n          } else {\n            delete this.data[dataId];\n          }\n          this.group.dirty(dataId, \"__exists\");\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // If called with only one argument, removes the entire entity\n  // identified by dataId. If called with a fieldName as well, removes all\n  // fields of that entity whose names match fieldName according to the\n  // fieldNameFromStoreName helper function. If called with a fieldName\n  // and variables, removes all fields of that entity whose names match fieldName\n  // and whose arguments when cached exactly match the variables passed.\n  public delete(\n    dataId: string,\n    fieldName?: string,\n    args?: Record<string, any>\n  ) {\n    const storeObject = this.lookup(dataId);\n    if (storeObject) {\n      const typename = this.getFieldValue<string>(storeObject, \"__typename\");\n      const storeFieldName =\n        fieldName && args ?\n          this.policies.getStoreFieldName({ typename, fieldName, args })\n        : fieldName;\n      return this.modify(\n        dataId,\n        storeFieldName ?\n          {\n            [storeFieldName]: delModifier,\n          }\n        : delModifier\n      );\n    }\n    return false;\n  }\n\n  public evict(options: Cache.EvictOptions, limit: EntityStore): boolean {\n    let evicted = false;\n    if (options.id) {\n      if (hasOwn.call(this.data, options.id)) {\n        evicted = this.delete(options.id, options.fieldName, options.args);\n      }\n      if (this instanceof Layer && this !== limit) {\n        evicted = this.parent.evict(options, limit) || evicted;\n      }\n      // Always invalidate the field to trigger rereading of watched\n      // queries, even if no cache data was modified by the eviction,\n      // because queries may depend on computed fields with custom read\n      // functions, whose values are not stored in the EntityStore.\n      if (options.fieldName || evicted) {\n        this.group.dirty(options.id, options.fieldName || \"__exists\");\n      }\n    }\n    return evicted;\n  }\n\n  public clear(): void {\n    this.replace(null);\n  }\n\n  public extract(): NormalizedCacheObject {\n    const obj = this.toObject();\n    const extraRootIds: string[] = [];\n    this.getRootIdSet().forEach((id) => {\n      if (!hasOwn.call(this.policies.rootTypenamesById, id)) {\n        extraRootIds.push(id);\n      }\n    });\n    if (extraRootIds.length) {\n      obj.__META = { extraRootIds: extraRootIds.sort() };\n    }\n    return obj;\n  }\n\n  public replace(newData: NormalizedCacheObject | null): void {\n    Object.keys(this.data).forEach((dataId) => {\n      if (!(newData && hasOwn.call(newData, dataId))) {\n        this.delete(dataId);\n      }\n    });\n    if (newData) {\n      const { __META, ...rest } = newData;\n      Object.keys(rest).forEach((dataId) => {\n        this.merge(dataId, rest[dataId] as StoreObject);\n      });\n      if (__META) {\n        __META.extraRootIds.forEach(this.retain, this);\n      }\n    }\n  }\n\n  public abstract getStorage(\n    idOrObj: string | StoreObject,\n    ...storeFieldNames: (string | number)[]\n  ): StorageType;\n\n  // Maps root entity IDs to the number of times they have been retained, minus\n  // the number of times they have been released. Retained entities keep other\n  // entities they reference (even indirectly) from being garbage collected.\n  private rootIds: {\n    [rootId: string]: number;\n  } = Object.create(null);\n\n  public retain(rootId: string): number {\n    return (this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1);\n  }\n\n  public release(rootId: string): number {\n    if (this.rootIds[rootId] > 0) {\n      const count = --this.rootIds[rootId];\n      if (!count) delete this.rootIds[rootId];\n      return count;\n    }\n    return 0;\n  }\n\n  // Return a Set<string> of all the ID strings that have been retained by\n  // this layer/root *and* any layers/roots beneath it.\n  public getRootIdSet(ids = new Set<string>()) {\n    Object.keys(this.rootIds).forEach(ids.add, ids);\n    if (this instanceof Layer) {\n      this.parent.getRootIdSet(ids);\n    } else {\n      // Official singleton IDs like ROOT_QUERY and ROOT_MUTATION are\n      // always considered roots for garbage collection, regardless of\n      // their retainment counts in this.rootIds.\n      Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);\n    }\n    return ids;\n  }\n\n  // The goal of garbage collection is to remove IDs from the Root layer of the\n  // store that are no longer reachable starting from any IDs that have been\n  // explicitly retained (see retain and release, above). Returns an array of\n  // dataId strings that were removed from the store.\n  public gc() {\n    const ids = this.getRootIdSet();\n    const snapshot = this.toObject();\n    ids.forEach((id) => {\n      if (hasOwn.call(snapshot, id)) {\n        // Because we are iterating over an ECMAScript Set, the IDs we add here\n        // will be visited in later iterations of the forEach loop only if they\n        // were not previously contained by the Set.\n        Object.keys(this.findChildRefIds(id)).forEach(ids.add, ids);\n        // By removing IDs from the snapshot object here, we protect them from\n        // getting removed from the root store layer below.\n        delete snapshot[id];\n      }\n    });\n    const idsToRemove = Object.keys(snapshot);\n    if (idsToRemove.length) {\n      let root: EntityStore = this;\n      while (root instanceof Layer) root = root.parent;\n      idsToRemove.forEach((id) => root.delete(id));\n    }\n    return idsToRemove;\n  }\n\n  // Lazily tracks { __ref: <dataId> } strings contained by this.data[dataId].\n  private refs: {\n    [dataId: string]: Record<string, true>;\n  } = Object.create(null);\n\n  public findChildRefIds(dataId: string): Record<string, true> {\n    if (!hasOwn.call(this.refs, dataId)) {\n      const found = (this.refs[dataId] = Object.create(null));\n      const root = this.data[dataId];\n      if (!root) return found;\n\n      const workSet = new Set<Record<string | number, any>>([root]);\n      // Within the store, only arrays and objects can contain child entity\n      // references, so we can prune the traversal using this predicate:\n      workSet.forEach((obj) => {\n        if (isReference(obj)) {\n          found[obj.__ref] = true;\n          // In rare cases, a { __ref } Reference object may have other fields.\n          // This often indicates a mismerging of References with StoreObjects,\n          // but garbage collection should not be fooled by a stray __ref\n          // property in a StoreObject (ignoring all the other fields just\n          // because the StoreObject looks like a Reference). To avoid this\n          // premature termination of findChildRefIds recursion, we fall through\n          // to the code below, which will handle any other properties of obj.\n        }\n        if (isNonNullObject(obj)) {\n          Object.keys(obj).forEach((key) => {\n            const child = obj[key];\n            // No need to add primitive values to the workSet, since they cannot\n            // contain reference objects.\n            if (isNonNullObject(child)) {\n              workSet.add(child);\n            }\n          });\n        }\n      });\n    }\n    return this.refs[dataId];\n  }\n\n  // Used to compute cache keys specific to this.group.\n  /** overload for `InMemoryCache.maybeBroadcastWatch` */\n  public makeCacheKey(\n    document: DocumentNode,\n    callback: Cache.WatchCallback<any>,\n    details: string\n  ): object;\n  /** overload for `StoreReader.executeSelectionSet` */\n  public makeCacheKey(\n    selectionSet: SelectionSetNode,\n    parent: string /* = ( Reference.__ref ) */ | StoreObject,\n    varString: string | undefined,\n    canonizeResults: boolean\n  ): object;\n  /** overload for `StoreReader.executeSubSelectedArray` */\n  public makeCacheKey(\n    field: FieldNode,\n    array: readonly any[],\n    varString: string | undefined\n  ): object;\n  /** @deprecated This is only meant for internal usage,\n   * in your own code please use a `Trie` instance instead. */\n  public makeCacheKey(...args: any[]): object;\n  public makeCacheKey() {\n    return this.group.keyMaker.lookupArray(arguments);\n  }\n\n  // Bound function that can be passed around to provide easy access to fields\n  // of Reference objects as well as ordinary objects.\n  public getFieldValue = <T = StoreValue>(\n    objectOrReference: StoreObject | Reference | undefined,\n    storeFieldName: string\n  ) =>\n    maybeDeepFreeze(\n      isReference(objectOrReference) ?\n        this.get(objectOrReference.__ref, storeFieldName)\n      : objectOrReference && objectOrReference[storeFieldName]\n    ) as SafeReadonly<T>;\n\n  // Returns true for non-normalized StoreObjects and non-dangling\n  // References, indicating that readField(name, objOrRef) has a chance of\n  // working. Useful for filtering out dangling references from lists.\n  public canRead: CanReadFunction = (objOrRef) => {\n    return isReference(objOrRef) ?\n        this.has(objOrRef.__ref)\n      : typeof objOrRef === \"object\";\n  };\n\n  // Bound function that converts an id or an object with a __typename and\n  // primary key fields to a Reference object. If called with a Reference object,\n  // that same Reference object is returned. Pass true for mergeIntoStore to persist\n  // an object into the store.\n  public toReference: ToReferenceFunction = (objOrIdOrRef, mergeIntoStore) => {\n    if (typeof objOrIdOrRef === \"string\") {\n      return makeReference(objOrIdOrRef);\n    }\n\n    if (isReference(objOrIdOrRef)) {\n      return objOrIdOrRef;\n    }\n\n    const [id] = this.policies.identify(objOrIdOrRef);\n\n    if (id) {\n      const ref = makeReference(id);\n      if (mergeIntoStore) {\n        this.merge(id, objOrIdOrRef);\n      }\n      return ref;\n    }\n  };\n}\n\nexport type FieldValueGetter = EntityStore[\"getFieldValue\"];\n\n// A single CacheGroup represents a set of one or more EntityStore objects,\n// typically the Root store in a CacheGroup by itself, and all active Layer\n// stores in a group together. A single EntityStore object belongs to only\n// one CacheGroup, store.group. The CacheGroup is responsible for tracking\n// dependencies, so store.group is helpful for generating unique keys for\n// cached results that need to be invalidated when/if those dependencies\n// change. If we used the EntityStore objects themselves as cache keys (that\n// is, store rather than store.group), the cache would become unnecessarily\n// fragmented by all the different Layer objects. Instead, the CacheGroup\n// approach allows all optimistic Layer objects in the same linked list to\n// belong to one CacheGroup, with the non-optimistic Root object belonging\n// to another CacheGroup, allowing resultCaching dependencies to be tracked\n// separately for optimistic and non-optimistic entity data.\nclass CacheGroup {\n  private d: OptimisticDependencyFunction<string> | null = null;\n\n  // Used by the EntityStore#makeCacheKey method to compute cache keys\n  // specific to this CacheGroup.\n  public keyMaker!: Trie<object>;\n\n  constructor(\n    public readonly caching: boolean,\n    private parent: CacheGroup | null = null\n  ) {\n    this.resetCaching();\n  }\n\n  public resetCaching() {\n    this.d = this.caching ? dep<string>() : null;\n    this.keyMaker = new Trie(canUseWeakMap);\n  }\n\n  public depend(dataId: string, storeFieldName: string) {\n    if (this.d) {\n      this.d(makeDepKey(dataId, storeFieldName));\n      const fieldName = fieldNameFromStoreName(storeFieldName);\n      if (fieldName !== storeFieldName) {\n        // Fields with arguments that contribute extra identifying\n        // information to the fieldName (thus forming the storeFieldName)\n        // depend not only on the full storeFieldName but also on the\n        // short fieldName, so the field can be invalidated using either\n        // level of specificity.\n        this.d(makeDepKey(dataId, fieldName));\n      }\n      if (this.parent) {\n        this.parent.depend(dataId, storeFieldName);\n      }\n    }\n  }\n\n  public dirty(dataId: string, storeFieldName: string) {\n    if (this.d) {\n      this.d.dirty(\n        makeDepKey(dataId, storeFieldName),\n        // When storeFieldName === \"__exists\", that means the entity identified\n        // by dataId has either disappeared from the cache or was newly added,\n        // so the result caching system would do well to \"forget everything it\n        // knows\" about that object. To achieve that kind of invalidation, we\n        // not only dirty the associated result cache entry, but also remove it\n        // completely from the dependency graph. For the optimism implementation\n        // details, see https://github.com/benjamn/optimism/pull/195.\n        storeFieldName === \"__exists\" ? \"forget\" : \"setDirty\"\n      );\n    }\n  }\n}\n\nfunction makeDepKey(dataId: string, storeFieldName: string) {\n  // Since field names cannot have '#' characters in them, this method\n  // of joining the field name and the ID should be unambiguous, and much\n  // cheaper than JSON.stringify([dataId, fieldName]).\n  return storeFieldName + \"#\" + dataId;\n}\n\nexport function maybeDependOnExistenceOfEntity(\n  store: NormalizedCache,\n  entityId: string\n) {\n  if (supportsResultCaching(store)) {\n    // We use this pseudo-field __exists elsewhere in the EntityStore code to\n    // represent changes in the existence of the entity object identified by\n    // entityId. This dependency gets reliably dirtied whenever an object with\n    // this ID is deleted (or newly created) within this group, so any result\n    // cache entries (for example, StoreReader#executeSelectionSet results) that\n    // depend on __exists for this entityId will get dirtied as well, leading to\n    // the eventual recomputation (instead of reuse) of those result objects the\n    // next time someone reads them from the cache.\n    store.group.depend(entityId, \"__exists\");\n  }\n}\n\nexport namespace EntityStore {\n  // Refer to this class as EntityStore.Root outside this namespace.\n  export class Root extends EntityStore {\n    constructor({\n      policies,\n      resultCaching = true,\n      seed,\n    }: {\n      policies: Policies;\n      resultCaching?: boolean;\n      seed?: NormalizedCacheObject;\n    }) {\n      super(policies, new CacheGroup(resultCaching));\n      if (seed) this.replace(seed);\n    }\n\n    public readonly stump = new Stump(this);\n\n    public addLayer(\n      layerId: string,\n      replay: (layer: EntityStore) => any\n    ): Layer {\n      // Adding an optimistic Layer on top of the Root actually adds the Layer\n      // on top of the Stump, so the Stump always comes between the Root and\n      // any Layer objects that we've added.\n      return this.stump.addLayer(layerId, replay);\n    }\n\n    public removeLayer(): Root {\n      // Never remove the root layer.\n      return this;\n    }\n\n    public readonly storageTrie = new Trie<StorageType>(canUseWeakMap);\n    public getStorage(): StorageType {\n      return this.storageTrie.lookupArray(arguments);\n    }\n  }\n}\n\n// Not exported, since all Layer instances are created by the addLayer method\n// of the EntityStore.Root class.\nclass Layer extends EntityStore {\n  constructor(\n    public readonly id: string,\n    public readonly parent: EntityStore,\n    public readonly replay: (layer: EntityStore) => any,\n    public readonly group: CacheGroup\n  ) {\n    super(parent.policies, group);\n    replay(this);\n  }\n\n  public addLayer(layerId: string, replay: (layer: EntityStore) => any): Layer {\n    return new Layer(layerId, this, replay, this.group);\n  }\n\n  public removeLayer(layerId: string): EntityStore {\n    // Remove all instances of the given id, not just the first one.\n    const parent = this.parent.removeLayer(layerId);\n\n    if (layerId === this.id) {\n      if (this.group.caching) {\n        // Dirty every ID we're removing. Technically we might be able to avoid\n        // dirtying fields that have values in higher layers, but we don't have\n        // easy access to higher layers here, and we're about to recreate those\n        // layers anyway (see parent.addLayer below).\n        Object.keys(this.data).forEach((dataId) => {\n          const ownStoreObject = this.data[dataId];\n          const parentStoreObject = parent[\"lookup\"](dataId);\n          if (!parentStoreObject) {\n            // The StoreObject identified by dataId was defined in this layer\n            // but will be undefined in the parent layer, so we can delete the\n            // whole entity using this.delete(dataId). Since we're about to\n            // throw this layer away, the only goal of this deletion is to dirty\n            // the removed fields.\n            this.delete(dataId);\n          } else if (!ownStoreObject) {\n            // This layer had an entry for dataId but it was undefined, which\n            // means the entity was deleted in this layer, and it's about to\n            // become undeleted when we remove this layer, so we need to dirty\n            // all fields that are about to be reexposed.\n            this.group.dirty(dataId, \"__exists\");\n            Object.keys(parentStoreObject).forEach((storeFieldName) => {\n              this.group.dirty(dataId, storeFieldName);\n            });\n          } else if (ownStoreObject !== parentStoreObject) {\n            // If ownStoreObject is not exactly the same as parentStoreObject,\n            // dirty any fields whose values will change as a result of this\n            // removal.\n            Object.keys(ownStoreObject).forEach((storeFieldName) => {\n              if (\n                !equal(\n                  ownStoreObject[storeFieldName],\n                  parentStoreObject[storeFieldName]\n                )\n              ) {\n                this.group.dirty(dataId, storeFieldName);\n              }\n            });\n          }\n        });\n      }\n\n      return parent;\n    }\n\n    // No changes are necessary if the parent chain remains identical.\n    if (parent === this.parent) return this;\n\n    // Recreate this layer on top of the new parent.\n    return parent.addLayer(this.id, this.replay);\n  }\n\n  public toObject(): NormalizedCacheObject {\n    return {\n      ...this.parent.toObject(),\n      ...this.data,\n    };\n  }\n\n  public findChildRefIds(dataId: string): Record<string, true> {\n    const fromParent = this.parent.findChildRefIds(dataId);\n    return hasOwn.call(this.data, dataId) ?\n        {\n          ...fromParent,\n          ...super.findChildRefIds(dataId),\n        }\n      : fromParent;\n  }\n\n  public getStorage(): StorageType {\n    let p: EntityStore = this.parent;\n    while ((p as Layer).parent) p = (p as Layer).parent;\n    return p.getStorage.apply(\n      p,\n      // @ts-expect-error\n      arguments\n    );\n  }\n}\n\n// Represents a Layer permanently installed just above the Root, which allows\n// reading optimistically (and registering optimistic dependencies) even when\n// no optimistic layers are currently active. The stump.group CacheGroup object\n// is shared by any/all Layer objects added on top of the Stump.\nclass Stump extends Layer {\n  constructor(root: EntityStore.Root) {\n    super(\n      \"EntityStore.Stump\",\n      root,\n      () => {},\n      new CacheGroup(root.group.caching, root.group)\n    );\n  }\n\n  public removeLayer() {\n    // Never remove the Stump layer.\n    return this;\n  }\n\n  public merge(older: string | StoreObject, newer: string | StoreObject) {\n    // We never want to write any data into the Stump, so we forward any merge\n    // calls to the Root instead. Another option here would be to throw an\n    // exception, but the toReference(object, true) function can sometimes\n    // trigger Stump writes (which used to be Root writes, before the Stump\n    // concept was introduced).\n    return this.parent.merge(older, newer);\n  }\n}\n\nfunction storeObjectReconciler(\n  existingObject: StoreObject,\n  incomingObject: StoreObject,\n  property: string | number\n): StoreValue {\n  const existingValue = existingObject[property];\n  const incomingValue = incomingObject[property];\n  // Wherever there is a key collision, prefer the incoming value, unless\n  // it is deeply equal to the existing value. It's worth checking deep\n  // equality here (even though blindly returning incoming would be\n  // logically correct) because preserving the referential identity of\n  // existing data can prevent needless rereading and rerendering.\n  return equal(existingValue, incomingValue) ? existingValue : incomingValue;\n}\n\nexport function supportsResultCaching(store: any): store is EntityStore {\n  // When result caching is disabled, store.depend will be null.\n  return !!(store instanceof EntityStore && store.group.caching);\n}\n", "import { Trie } from \"@wry/trie\";\nimport {\n  canUseWeakMap,\n  canUseWeakSet,\n  isNonNullObject as isObjectOrArray,\n} from \"../../utilities/index.js\";\nimport { isArray } from \"./helpers.js\";\n\nfunction shallowCopy<T>(value: T): T {\n  if (isObjectOrArray(value)) {\n    return isArray(value) ?\n        (value.slice(0) as any as T)\n      : { __proto__: Object.getPrototypeOf(value), ...value };\n  }\n  return value;\n}\n\n// When programmers talk about the \"canonical form\" of an object, they\n// usually have the following meaning in mind, which I've copied from\n// https://en.wiktionary.org/wiki/canonical_form:\n//\n// 1. A standard or normal presentation of a mathematical entity [or\n//    object]. A canonical form is an element of a set of representatives\n//    of equivalence classes of forms such that there is a function or\n//    procedure which projects every element of each equivalence class\n//    onto that one element, the canonical form of that equivalence\n//    class. The canonical form is expected to be simpler than the rest of\n//    the forms in some way.\n//\n// That's a long-winded way of saying any two objects that have the same\n// canonical form may be considered equivalent, even if they are !==,\n// which usually means the objects are structurally equivalent (deeply\n// equal), but don't necessarily use the same memory.\n//\n// Like a literary or musical canon, this ObjectCanon class represents a\n// collection of unique canonical items (JavaScript objects), with the\n// important property that canon.admit(a) === canon.admit(b) if a and b\n// are deeply equal to each other. In terms of the definition above, the\n// canon.admit method is the \"function or procedure which projects every\"\n// object \"onto that one element, the canonical form.\"\n//\n// In the worst case, the canonicalization process may involve looking at\n// every property in the provided object tree, so it takes the same order\n// of time as deep equality checking. Fortunately, already-canonicalized\n// objects are returned immediately from canon.admit, so the presence of\n// canonical subtrees tends to speed up canonicalization.\n//\n// Since consumers of canonical objects can check for deep equality in\n// constant time, canonicalizing cache results can massively improve the\n// performance of application code that skips re-rendering unchanged\n// results, such as \"pure\" UI components in a framework like React.\n//\n// Of course, since canonical objects may be shared widely between\n// unrelated consumers, it's important to think of them as immutable, even\n// though they are not actually frozen with Object.freeze in production,\n// due to the extra performance overhead that comes with frozen objects.\n//\n// Custom scalar objects whose internal class name is neither Array nor\n// Object can be included safely in the admitted tree, but they will not\n// be replaced with a canonical version (to put it another way, they are\n// assumed to be canonical already).\n//\n// If we ignore custom objects, no detection of cycles or repeated object\n// references is currently required by the StoreReader class, since\n// GraphQL result objects are JSON-serializable trees (and thus contain\n// neither cycles nor repeated subtrees), so we can avoid the complexity\n// of keeping track of objects we've already seen during the recursion of\n// the admit method.\n//\n// In the future, we may consider adding additional cases to the switch\n// statement to handle other common object types, such as \"[object Date]\"\n// objects, as needed.\nexport class ObjectCanon {\n  // Set of all canonical objects this ObjectCanon has admitted, allowing\n  // canon.admit to return previously-canonicalized objects immediately.\n  private known = new (canUseWeakSet ? WeakSet : Set)<object>();\n\n  // Efficient storage/lookup structure for canonical objects.\n  private pool = new Trie<{\n    array?: any[];\n    object?: Record<string, any>;\n    keys?: SortedKeysInfo;\n  }>(canUseWeakMap);\n\n  public isKnown(value: any): boolean {\n    return isObjectOrArray(value) && this.known.has(value);\n  }\n\n  // Make the ObjectCanon assume this value has already been\n  // canonicalized.\n  private passes = new WeakMap<object, object>();\n  public pass<T>(value: T): T;\n  public pass(value: any) {\n    if (isObjectOrArray(value)) {\n      const copy = shallowCopy(value);\n      this.passes.set(copy, value);\n      return copy;\n    }\n    return value;\n  }\n\n  // Returns the canonical version of value.\n  public admit<T>(value: T): T;\n  public admit(value: any) {\n    if (isObjectOrArray(value)) {\n      const original = this.passes.get(value);\n      if (original) return original;\n\n      const proto = Object.getPrototypeOf(value);\n      switch (proto) {\n        case Array.prototype: {\n          if (this.known.has(value)) return value;\n          const array: any[] = (value as any[]).map(this.admit, this);\n          // Arrays are looked up in the Trie using their recursively\n          // canonicalized elements, and the known version of the array is\n          // preserved as node.array.\n          const node = this.pool.lookupArray(array);\n          if (!node.array) {\n            this.known.add((node.array = array));\n            // Since canonical arrays may be shared widely between\n            // unrelated consumers, it's important to regard them as\n            // immutable, even if they are not frozen in production.\n            if (__DEV__) {\n              Object.freeze(array);\n            }\n          }\n          return node.array;\n        }\n\n        case null:\n        case Object.prototype: {\n          if (this.known.has(value)) return value;\n          const proto = Object.getPrototypeOf(value);\n          const array = [proto];\n          const keys = this.sortedKeys(value);\n          array.push(keys.json);\n          const firstValueIndex = array.length;\n          keys.sorted.forEach((key) => {\n            array.push(this.admit((value as any)[key]));\n          });\n          // Objects are looked up in the Trie by their prototype (which\n          // is *not* recursively canonicalized), followed by a JSON\n          // representation of their (sorted) keys, followed by the\n          // sequence of recursively canonicalized values corresponding to\n          // those keys. To keep the final results unambiguous with other\n          // sequences (such as arrays that just happen to contain [proto,\n          // keys.json, value1, value2, ...]), the known version of the\n          // object is stored as node.object.\n          const node = this.pool.lookupArray(array);\n          if (!node.object) {\n            const obj = (node.object = Object.create(proto));\n            this.known.add(obj);\n            keys.sorted.forEach((key, i) => {\n              obj[key] = array[firstValueIndex + i];\n            });\n            // Since canonical objects may be shared widely between\n            // unrelated consumers, it's important to regard them as\n            // immutable, even if they are not frozen in production.\n            if (__DEV__) {\n              Object.freeze(obj);\n            }\n          }\n          return node.object;\n        }\n      }\n    }\n    return value;\n  }\n\n  // It's worthwhile to cache the sorting of arrays of strings, since the\n  // same initial unsorted arrays tend to be encountered many times.\n  // Fortunately, we can reuse the Trie machinery to look up the sorted\n  // arrays in linear time (which is faster than sorting large arrays).\n  private sortedKeys(obj: object) {\n    const keys = Object.keys(obj);\n    const node = this.pool.lookupArray(keys);\n    if (!node.keys) {\n      keys.sort();\n      const json = JSON.stringify(keys);\n      if (!(node.keys = this.keysByJSON.get(json))) {\n        this.keysByJSON.set(json, (node.keys = { sorted: keys, json }));\n      }\n    }\n    return node.keys;\n  }\n  // Arrays that contain the same elements in a different order can share\n  // the same SortedKeysInfo object, to save memory.\n  private keysByJSON = new Map<string, SortedKeysInfo>();\n\n  // This has to come last because it depends on keysByJSON.\n  public readonly empty = this.admit({});\n}\n\ntype SortedKeysInfo = {\n  sorted: string[];\n  json: string;\n};\n", "import { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\n\nimport type { DocumentNode, FieldNode, SelectionSetNode } from \"graphql\";\nimport { Kind } from \"graphql\";\nimport type { OptimisticWrapperFunction } from \"optimism\";\nimport { wrap } from \"optimism\";\n\nimport type {\n  Reference,\n  StoreObject,\n  FragmentMap,\n  FragmentMapFunction,\n} from \"../../utilities/index.js\";\nimport {\n  isField,\n  resultKeyNameFromField,\n  isReference,\n  makeReference,\n  shouldInclude,\n  addTypenameToDocument,\n  getDefaultValues,\n  getMainDefinition,\n  getQueryDefinition,\n  getFragmentFromSelection,\n  maybeDeepFreeze,\n  mergeDeepArray,\n  DeepMerger,\n  isNonNullObject,\n  canUseWeakMap,\n  compact,\n  canonicalStringify,\n  cacheSizes,\n  defaultCacheSizes,\n} from \"../../utilities/index.js\";\nimport type { Cache } from \"../core/types/Cache.js\";\nimport type {\n  DiffQueryAgainstStoreOptions,\n  InMemoryCacheConfig,\n  NormalizedCache,\n  ReadMergeModifyContext,\n} from \"./types.js\";\nimport {\n  maybeDependOnExistenceOfEntity,\n  supportsResultCaching,\n} from \"./entityStore.js\";\nimport {\n  isArray,\n  extractFragmentContext,\n  getTypenameFromStoreObject,\n  shouldCanonizeResults,\n} from \"./helpers.js\";\nimport type { Policies } from \"./policies.js\";\nimport type { InMemoryCache } from \"./inMemoryCache.js\";\nimport type { MissingTree } from \"../core/types/common.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport { ObjectCanon } from \"./object-canon.js\";\n\nexport type VariableMap = { [name: string]: any };\n\ninterface ReadContext extends ReadMergeModifyContext {\n  query: DocumentNode;\n  policies: Policies;\n  canonizeResults: boolean;\n  fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n}\n\nexport type ExecResult<R = any> = {\n  result: R;\n  missing?: MissingTree;\n};\n\ntype ExecSelectionSetOptions = {\n  selectionSet: SelectionSetNode;\n  objectOrReference: StoreObject | Reference;\n  enclosingRef: Reference;\n  context: ReadContext;\n};\n\ntype ExecSubSelectedArrayOptions = {\n  field: FieldNode;\n  array: readonly any[];\n  enclosingRef: Reference;\n  context: ReadContext;\n};\n\nexport interface StoreReaderConfig {\n  cache: InMemoryCache;\n  addTypename?: boolean;\n  resultCacheMaxSize?: number;\n  canonizeResults?: boolean;\n  canon?: ObjectCanon;\n  fragments?: InMemoryCacheConfig[\"fragments\"];\n}\n\n// Arguments type after keyArgs translation.\ntype ExecSelectionSetKeyArgs = [\n  SelectionSetNode,\n  StoreObject | Reference,\n  ReadMergeModifyContext,\n  boolean,\n];\n\nfunction execSelectionSetKeyArgs(\n  options: ExecSelectionSetOptions\n): ExecSelectionSetKeyArgs {\n  return [\n    options.selectionSet,\n    options.objectOrReference,\n    options.context,\n    // We split out this property so we can pass different values\n    // independently without modifying options.context itself.\n    options.context.canonizeResults,\n  ];\n}\n\nexport class StoreReader {\n  // cached version of executeSelectionSet\n  private executeSelectionSet: OptimisticWrapperFunction<\n    [ExecSelectionSetOptions], // Actual arguments tuple type.\n    ExecResult, // Actual return type.\n    ExecSelectionSetKeyArgs\n  >;\n\n  // cached version of executeSubSelectedArray\n  private executeSubSelectedArray: OptimisticWrapperFunction<\n    [ExecSubSelectedArrayOptions],\n    ExecResult<any>,\n    [ExecSubSelectedArrayOptions]\n  >;\n\n  private config: {\n    cache: InMemoryCache;\n    addTypename: boolean;\n    resultCacheMaxSize?: number;\n    canonizeResults: boolean;\n    fragments?: InMemoryCacheConfig[\"fragments\"];\n  };\n\n  private knownResults = new (canUseWeakMap ? WeakMap : Map)<\n    Record<string, any>,\n    SelectionSetNode\n  >();\n\n  public canon: ObjectCanon;\n  public resetCanon() {\n    this.canon = new ObjectCanon();\n  }\n\n  constructor(config: StoreReaderConfig) {\n    this.config = compact(config, {\n      addTypename: config.addTypename !== false,\n      canonizeResults: shouldCanonizeResults(config),\n    });\n\n    this.canon = config.canon || new ObjectCanon();\n\n    // memoized functions in this class will be \"garbage-collected\"\n    // by recreating the whole `StoreReader` in\n    // `InMemoryCache.resetResultsCache`\n    // (triggered from `InMemoryCache.gc` with `resetResultCache: true`)\n    this.executeSelectionSet = wrap(\n      (options) => {\n        const { canonizeResults } = options.context;\n\n        const peekArgs = execSelectionSetKeyArgs(options);\n\n        // Negate this boolean option so we can find out if we've already read\n        // this result using the other boolean value.\n        peekArgs[3] = !canonizeResults;\n\n        const other = this.executeSelectionSet.peek(...peekArgs);\n\n        if (other) {\n          if (canonizeResults) {\n            return {\n              ...other,\n              // If we previously read this result without canonizing it, we can\n              // reuse that result simply by canonizing it now.\n              result: this.canon.admit(other.result),\n            };\n          }\n          // If we previously read this result with canonization enabled, we can\n          // return that canonized result as-is.\n          return other;\n        }\n\n        maybeDependOnExistenceOfEntity(\n          options.context.store,\n          options.enclosingRef.__ref\n        );\n\n        // Finally, if we didn't find any useful previous results, run the real\n        // execSelectionSetImpl method with the given options.\n        return this.execSelectionSetImpl(options);\n      },\n      {\n        max:\n          this.config.resultCacheMaxSize ||\n          cacheSizes[\"inMemoryCache.executeSelectionSet\"] ||\n          defaultCacheSizes[\"inMemoryCache.executeSelectionSet\"],\n        keyArgs: execSelectionSetKeyArgs,\n        // Note that the parameters of makeCacheKey are determined by the\n        // array returned by keyArgs.\n        makeCacheKey(selectionSet, parent, context, canonizeResults) {\n          if (supportsResultCaching(context.store)) {\n            return context.store.makeCacheKey(\n              selectionSet,\n              isReference(parent) ? parent.__ref : parent,\n              context.varString,\n              canonizeResults\n            );\n          }\n        },\n      }\n    );\n\n    this.executeSubSelectedArray = wrap(\n      (options: ExecSubSelectedArrayOptions) => {\n        maybeDependOnExistenceOfEntity(\n          options.context.store,\n          options.enclosingRef.__ref\n        );\n        return this.execSubSelectedArrayImpl(options);\n      },\n      {\n        max:\n          this.config.resultCacheMaxSize ||\n          cacheSizes[\"inMemoryCache.executeSubSelectedArray\"] ||\n          defaultCacheSizes[\"inMemoryCache.executeSubSelectedArray\"],\n        makeCacheKey({ field, array, context }) {\n          if (supportsResultCaching(context.store)) {\n            return context.store.makeCacheKey(field, array, context.varString);\n          }\n        },\n      }\n    );\n  }\n\n  /**\n   * Given a store and a query, return as much of the result as possible and\n   * identify if any data was missing from the store.\n   */\n  public diffQueryAgainstStore<T>({\n    store,\n    query,\n    rootId = \"ROOT_QUERY\",\n    variables,\n    returnPartialData = true,\n    canonizeResults = this.config.canonizeResults,\n  }: DiffQueryAgainstStoreOptions): Cache.DiffResult<T> {\n    const policies = this.config.cache.policies;\n\n    variables = {\n      ...getDefaultValues(getQueryDefinition(query)),\n      ...variables!,\n    };\n\n    const rootRef = makeReference(rootId);\n    const execResult = this.executeSelectionSet({\n      selectionSet: getMainDefinition(query).selectionSet,\n      objectOrReference: rootRef,\n      enclosingRef: rootRef,\n      context: {\n        store,\n        query,\n        policies,\n        variables,\n        varString: canonicalStringify(variables),\n        canonizeResults,\n        ...extractFragmentContext(query, this.config.fragments),\n      },\n    });\n\n    let missing: MissingFieldError[] | undefined;\n    if (execResult.missing) {\n      // For backwards compatibility we still report an array of\n      // MissingFieldError objects, even though there will only ever be at most\n      // one of them, now that all missing field error messages are grouped\n      // together in the execResult.missing tree.\n      missing = [\n        new MissingFieldError(\n          firstMissing(execResult.missing)!,\n          execResult.missing,\n          query,\n          variables\n        ),\n      ];\n      if (!returnPartialData) {\n        throw missing[0];\n      }\n    }\n\n    return {\n      result: execResult.result,\n      complete: !missing,\n      missing,\n    };\n  }\n\n  public isFresh(\n    result: Record<string, any>,\n    parent: StoreObject | Reference,\n    selectionSet: SelectionSetNode,\n    context: ReadMergeModifyContext\n  ): boolean {\n    if (\n      supportsResultCaching(context.store) &&\n      this.knownResults.get(result) === selectionSet\n    ) {\n      const latest = this.executeSelectionSet.peek(\n        selectionSet,\n        parent,\n        context,\n        // If result is canonical, then it could only have been previously\n        // cached by the canonizing version of executeSelectionSet, so we can\n        // avoid checking both possibilities here.\n        this.canon.isKnown(result)\n      );\n      if (latest && result === latest.result) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Uncached version of executeSelectionSet.\n  private execSelectionSetImpl({\n    selectionSet,\n    objectOrReference,\n    enclosingRef,\n    context,\n  }: ExecSelectionSetOptions): ExecResult {\n    if (\n      isReference(objectOrReference) &&\n      !context.policies.rootTypenamesById[objectOrReference.__ref] &&\n      !context.store.has(objectOrReference.__ref)\n    ) {\n      return {\n        result: this.canon.empty,\n        missing: `Dangling reference to missing ${objectOrReference.__ref} object`,\n      };\n    }\n\n    const { variables, policies, store } = context;\n    const typename = store.getFieldValue<string>(\n      objectOrReference,\n      \"__typename\"\n    );\n\n    const objectsToMerge: Record<string, any>[] = [];\n    let missing: MissingTree | undefined;\n    const missingMerger = new DeepMerger();\n\n    if (\n      this.config.addTypename &&\n      typeof typename === \"string\" &&\n      !policies.rootIdsByTypename[typename]\n    ) {\n      // Ensure we always include a default value for the __typename\n      // field, if we have one, and this.config.addTypename is true. Note\n      // that this field can be overridden by other merged objects.\n      objectsToMerge.push({ __typename: typename });\n    }\n\n    function handleMissing<T>(result: ExecResult<T>, resultName: string): T {\n      if (result.missing) {\n        missing = missingMerger.merge(missing, {\n          [resultName]: result.missing,\n        });\n      }\n      return result.result;\n    }\n\n    const workSet = new Set(selectionSet.selections);\n\n    workSet.forEach((selection) => {\n      // Omit fields with directives @skip(if: <truthy value>) or\n      // @include(if: <falsy value>).\n      if (!shouldInclude(selection, variables)) return;\n\n      if (isField(selection)) {\n        let fieldValue = policies.readField(\n          {\n            fieldName: selection.name.value,\n            field: selection,\n            variables: context.variables,\n            from: objectOrReference,\n          },\n          context\n        );\n\n        const resultName = resultKeyNameFromField(selection);\n\n        if (fieldValue === void 0) {\n          if (!addTypenameToDocument.added(selection)) {\n            missing = missingMerger.merge(missing, {\n              [resultName]: `Can't find field '${selection.name.value}' on ${\n                isReference(objectOrReference) ?\n                  objectOrReference.__ref + \" object\"\n                : \"object \" + JSON.stringify(objectOrReference, null, 2)\n              }`,\n            });\n          }\n        } else if (isArray(fieldValue)) {\n          if (fieldValue.length > 0) {\n            fieldValue = handleMissing(\n              this.executeSubSelectedArray({\n                field: selection,\n                array: fieldValue,\n                enclosingRef,\n                context,\n              }),\n              resultName\n            );\n          }\n        } else if (!selection.selectionSet) {\n          // If the field does not have a selection set, then we handle it\n          // as a scalar value. To keep this.canon from canonicalizing\n          // this value, we use this.canon.pass to wrap fieldValue in a\n          // Pass object that this.canon.admit will later unwrap as-is.\n          if (context.canonizeResults) {\n            fieldValue = this.canon.pass(fieldValue);\n          }\n        } else if (fieldValue != null) {\n          // In this case, because we know the field has a selection set,\n          // it must be trying to query a GraphQLObjectType, which is why\n          // fieldValue must be != null.\n          fieldValue = handleMissing(\n            this.executeSelectionSet({\n              selectionSet: selection.selectionSet,\n              objectOrReference: fieldValue as StoreObject | Reference,\n              enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,\n              context,\n            }),\n            resultName\n          );\n        }\n\n        if (fieldValue !== void 0) {\n          objectsToMerge.push({ [resultName]: fieldValue });\n        }\n      } else {\n        const fragment = getFragmentFromSelection(\n          selection,\n          context.lookupFragment\n        );\n\n        if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n          throw newInvariantError(`No fragment named %s`, selection.name.value);\n        }\n\n        if (fragment && policies.fragmentMatches(fragment, typename)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n\n    const result = mergeDeepArray(objectsToMerge);\n    const finalResult: ExecResult = { result, missing };\n    const frozen =\n      context.canonizeResults ?\n        this.canon.admit(finalResult)\n        // Since this.canon is normally responsible for freezing results (only in\n        // development), freeze them manually if canonization is disabled.\n      : maybeDeepFreeze(finalResult);\n\n    // Store this result with its selection set so that we can quickly\n    // recognize it again in the StoreReader#isFresh method.\n    if (frozen.result) {\n      this.knownResults.set(frozen.result, selectionSet);\n    }\n\n    return frozen;\n  }\n\n  // Uncached version of executeSubSelectedArray.\n  private execSubSelectedArrayImpl({\n    field,\n    array,\n    enclosingRef,\n    context,\n  }: ExecSubSelectedArrayOptions): ExecResult {\n    let missing: MissingTree | undefined;\n    let missingMerger = new DeepMerger<MissingTree[]>();\n\n    function handleMissing<T>(childResult: ExecResult<T>, i: number): T {\n      if (childResult.missing) {\n        missing = missingMerger.merge(missing, { [i]: childResult.missing });\n      }\n      return childResult.result;\n    }\n\n    if (field.selectionSet) {\n      array = array.filter(context.store.canRead);\n    }\n\n    array = array.map((item, i) => {\n      // null value in array\n      if (item === null) {\n        return null;\n      }\n\n      // This is a nested array, recurse\n      if (isArray(item)) {\n        return handleMissing(\n          this.executeSubSelectedArray({\n            field,\n            array: item,\n            enclosingRef,\n            context,\n          }),\n          i\n        );\n      }\n\n      // This is an object, run the selection set on it\n      if (field.selectionSet) {\n        return handleMissing(\n          this.executeSelectionSet({\n            selectionSet: field.selectionSet,\n            objectOrReference: item,\n            enclosingRef: isReference(item) ? item : enclosingRef,\n            context,\n          }),\n          i\n        );\n      }\n\n      if (__DEV__) {\n        assertSelectionSetForIdValue(context.store, field, item);\n      }\n\n      return item;\n    });\n\n    return {\n      result: context.canonizeResults ? this.canon.admit(array) : array,\n      missing,\n    };\n  }\n}\n\nfunction firstMissing(tree: MissingTree): string | undefined {\n  try {\n    JSON.stringify(tree, (_, value) => {\n      if (typeof value === \"string\") throw value;\n      return value;\n    });\n  } catch (result) {\n    return result as string;\n  }\n}\n\nfunction assertSelectionSetForIdValue(\n  store: NormalizedCache,\n  field: FieldNode,\n  fieldValue: any\n) {\n  if (!field.selectionSet) {\n    const workSet = new Set([fieldValue]);\n    workSet.forEach((value) => {\n      if (isNonNullObject(value)) {\n        invariant(\n          !isReference(value),\n          `Missing selection set for object of type %s returned for query field %s`,\n          getTypenameFromStoreObject(store, value),\n          field.name.value\n        );\n        Object.values(value).forEach(workSet.add, workSet);\n      }\n    });\n  }\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\n\nimport {\n  argumentsObjectFromField,\n  DeepMerger,\n  isNonEmptyArray,\n  isNonNullObject,\n} from \"../../utilities/index.js\";\n\nimport { hasOwn, isArray } from \"./helpers.js\";\nimport type {\n  KeySpecifier,\n  KeyFieldsFunction,\n  KeyArgsFunction,\n} from \"./policies.js\";\n\n// Mapping from JSON-encoded KeySpecifier strings to associated information.\nconst specifierInfoCache: Record<\n  string,\n  {\n    paths?: string[][];\n    keyFieldsFn?: KeyFieldsFunction;\n    keyArgsFn?: KeyArgsFunction;\n  }\n> = Object.create(null);\n\nfunction lookupSpecifierInfo(spec: KeySpecifier) {\n  // It's safe to encode KeySpecifier arrays with JSON.stringify, since they're\n  // just arrays of strings or nested KeySpecifier arrays, and the order of the\n  // array elements is important (and suitably preserved by JSON.stringify).\n  const cacheKey = JSON.stringify(spec);\n  return (\n    specifierInfoCache[cacheKey] ||\n    (specifierInfoCache[cacheKey] = Object.create(null))\n  );\n}\n\nexport function keyFieldsFnFromSpecifier(\n  specifier: KeySpecifier\n): KeyFieldsFunction {\n  const info = lookupSpecifierInfo(specifier);\n\n  return (\n    info.keyFieldsFn ||\n    (info.keyFieldsFn = (object, context) => {\n      const extract: typeof extractKey = (from, key) =>\n        context.readField(key, from);\n\n      const keyObject = (context.keyObject = collectSpecifierPaths(\n        specifier,\n        (schemaKeyPath) => {\n          let extracted = extractKeyPath(\n            context.storeObject,\n            schemaKeyPath,\n            // Using context.readField to extract paths from context.storeObject\n            // allows the extraction to see through Reference objects and respect\n            // custom read functions.\n            extract\n          );\n\n          if (\n            extracted === void 0 &&\n            object !== context.storeObject &&\n            hasOwn.call(object, schemaKeyPath[0])\n          ) {\n            // If context.storeObject fails to provide a value for the requested\n            // path, fall back to the raw result object, if it has a top-level key\n            // matching the first key in the path (schemaKeyPath[0]). This allows\n            // key fields included in the written data to be saved in the cache\n            // even if they are not selected explicitly in context.selectionSet.\n            // Not being mentioned by context.selectionSet is convenient here,\n            // since it means these extra fields cannot be affected by field\n            // aliasing, which is why we can use extractKey instead of\n            // context.readField for this extraction.\n            extracted = extractKeyPath(object, schemaKeyPath, extractKey);\n          }\n\n          invariant(\n            extracted !== void 0,\n            `Missing field '%s' while extracting keyFields from %s`,\n            schemaKeyPath.join(\".\"),\n            object\n          );\n\n          return extracted;\n        }\n      ));\n\n      return `${context.typename}:${JSON.stringify(keyObject)}`;\n    })\n  );\n}\n\n// The keyArgs extraction process is roughly analogous to keyFields extraction,\n// but there are no aliases involved, missing fields are tolerated (by merely\n// omitting them from the key), and drawing from field.directives or variables\n// is allowed (in addition to drawing from the field's arguments object).\n// Concretely, these differences mean passing a different key path extractor\n// function to collectSpecifierPaths, reusing the shared extractKeyPath helper\n// wherever possible.\nexport function keyArgsFnFromSpecifier(\n  specifier: KeySpecifier\n): KeyArgsFunction {\n  const info = lookupSpecifierInfo(specifier);\n\n  return (\n    info.keyArgsFn ||\n    (info.keyArgsFn = (args, { field, variables, fieldName }) => {\n      const collected = collectSpecifierPaths(specifier, (keyPath) => {\n        const firstKey = keyPath[0];\n        const firstChar = firstKey.charAt(0);\n\n        if (firstChar === \"@\") {\n          if (field && isNonEmptyArray(field.directives)) {\n            const directiveName = firstKey.slice(1);\n            // If the directive appears multiple times, only the first\n            // occurrence's arguments will be used. TODO Allow repetition?\n            // TODO Cache this work somehow, a la aliasMap?\n            const d = field.directives.find(\n              (d) => d.name.value === directiveName\n            );\n            // Fortunately argumentsObjectFromField works for DirectiveNode!\n            const directiveArgs = d && argumentsObjectFromField(d, variables);\n            // For directives without arguments (d defined, but directiveArgs ===\n            // null), the presence or absence of the directive still counts as\n            // part of the field key, so we return null in those cases. If no\n            // directive with this name was found for this field (d undefined and\n            // thus directiveArgs undefined), we return undefined, which causes\n            // this value to be omitted from the key object returned by\n            // collectSpecifierPaths.\n            return (\n              directiveArgs &&\n              extractKeyPath(\n                directiveArgs,\n                // If keyPath.length === 1, this code calls extractKeyPath with an\n                // empty path, which works because it uses directiveArgs as the\n                // extracted value.\n                keyPath.slice(1)\n              )\n            );\n          }\n          // If the key started with @ but there was no corresponding directive,\n          // we want to omit this value from the key object, not fall through to\n          // treating @whatever as a normal argument name.\n          return;\n        }\n\n        if (firstChar === \"$\") {\n          const variableName = firstKey.slice(1);\n          if (variables && hasOwn.call(variables, variableName)) {\n            const varKeyPath = keyPath.slice(0);\n            varKeyPath[0] = variableName;\n            return extractKeyPath(variables, varKeyPath);\n          }\n          // If the key started with $ but there was no corresponding variable, we\n          // want to omit this value from the key object, not fall through to\n          // treating $whatever as a normal argument name.\n          return;\n        }\n\n        if (args) {\n          return extractKeyPath(args, keyPath);\n        }\n      });\n\n      const suffix = JSON.stringify(collected);\n\n      // If no arguments were passed to this field, and it didn't have any other\n      // field key contributions from directives or variables, hide the empty\n      // :{} suffix from the field key. However, a field passed no arguments can\n      // still end up with a non-empty :{...} suffix if its key configuration\n      // refers to directives or variables.\n      if (args || suffix !== \"{}\") {\n        fieldName += \":\" + suffix;\n      }\n\n      return fieldName;\n    })\n  );\n}\n\nexport function collectSpecifierPaths(\n  specifier: KeySpecifier,\n  extractor: (path: string[]) => any\n): Record<string, any> {\n  // For each path specified by specifier, invoke the extractor, and repeatedly\n  // merge the results together, with appropriate ancestor context.\n  const merger = new DeepMerger();\n  return getSpecifierPaths(specifier).reduce((collected, path) => {\n    let toMerge = extractor(path);\n    if (toMerge !== void 0) {\n      // This path is not expected to contain array indexes, so the toMerge\n      // reconstruction will not contain arrays. TODO Fix this?\n      for (let i = path.length - 1; i >= 0; --i) {\n        toMerge = { [path[i]]: toMerge };\n      }\n      collected = merger.merge(collected, toMerge);\n    }\n    return collected;\n  }, Object.create(null));\n}\n\nexport function getSpecifierPaths(spec: KeySpecifier): string[][] {\n  const info = lookupSpecifierInfo(spec);\n\n  if (!info.paths) {\n    const paths: string[][] = (info.paths = []);\n    const currentPath: string[] = [];\n\n    spec.forEach((s, i) => {\n      if (isArray(s)) {\n        getSpecifierPaths(s).forEach((p) => paths.push(currentPath.concat(p)));\n        currentPath.length = 0;\n      } else {\n        currentPath.push(s);\n        if (!isArray(spec[i + 1])) {\n          paths.push(currentPath.slice(0));\n          currentPath.length = 0;\n        }\n      }\n    });\n  }\n\n  return info.paths!;\n}\n\nfunction extractKey<TObj extends Record<string, any>, TKey extends string>(\n  object: TObj,\n  key: TKey\n): TObj[TKey] | undefined {\n  return object[key];\n}\n\nexport function extractKeyPath(\n  object: Record<string, any>,\n  path: string[],\n  extract?: typeof extractKey\n): any {\n  // For each key in path, extract the corresponding child property from obj,\n  // flattening arrays if encountered (uncommon for keyFields and keyArgs, but\n  // possible). The final result of path.reduce is normalized so unexpected leaf\n  // objects have their keys safely sorted. That final result is difficult to\n  // type as anything other than any. You're welcome to try to improve the\n  // return type, but keep in mind extractKeyPath is not a public function\n  // (exported only for testing), so the effort may not be worthwhile unless the\n  // limited set of actual callers (see above) pass arguments that TypeScript\n  // can statically type. If we know only that path is some array of strings\n  // (and not, say, a specific tuple of statically known strings), any (or\n  // possibly unknown) is the honest answer.\n  extract = extract || extractKey;\n  return normalize(\n    path.reduce(function reducer(obj, key): any {\n      return isArray(obj) ?\n          obj.map((child) => reducer(child, key))\n        : obj && extract!(obj, key);\n    }, object)\n  );\n}\n\nfunction normalize<T>(value: T): T {\n  // Usually the extracted value will be a scalar value, since most primary\n  // key fields are scalar, but just in case we get an object or an array, we\n  // need to do some normalization of the order of (nested) keys.\n  if (isNonNullObject(value)) {\n    if (isArray(value)) {\n      return value.map(normalize) as any;\n    }\n    return collectSpecifierPaths(Object.keys(value).sort(), (path) =>\n      extractKeyPath(value, path)\n    ) as T;\n  }\n  return value;\n}\n", "import { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\n\nimport type {\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n  SelectionSetNode,\n  FieldNode,\n} from \"graphql\";\n\nimport type {\n  FragmentMap,\n  StoreValue,\n  StoreObject,\n  Reference,\n} from \"../../utilities/index.js\";\nimport {\n  storeKeyNameFromField,\n  argumentsObjectFromField,\n  isReference,\n  getStoreKeyName,\n  isNonNullObject,\n  stringifyForDisplay,\n} from \"../../utilities/index.js\";\nimport type {\n  IdGetter,\n  MergeInfo,\n  NormalizedCache,\n  ReadMergeModifyContext,\n} from \"./types.js\";\nimport {\n  hasOwn,\n  fieldNameFromStoreName,\n  storeValueIsStoreObject,\n  selectionSetMatchesResult,\n  TypeOrFieldNameRegExp,\n  defaultDataIdFromObject,\n  isArray,\n} from \"./helpers.js\";\nimport { cacheSlot } from \"./reactiveVars.js\";\nimport type { InMemoryCache } from \"./inMemoryCache.js\";\nimport type {\n  SafeReadonly,\n  FieldSpecifier,\n  ToReferenceFunction,\n  ReadFieldFunction,\n  ReadFieldOptions,\n  CanReadFunction,\n} from \"../core/types/common.js\";\nimport type { WriteContext } from \"./writeToStore.js\";\n\nimport {\n  keyArgsFnFromSpecifier,\n  keyFieldsFnFromSpecifier,\n} from \"./key-extractor.js\";\nimport { disableWarningsSlot } from \"../../masking/index.js\";\n\nexport type TypePolicies = {\n  [__typename: string]: TypePolicy;\n};\n\n// TypeScript 3.7 will allow recursive type aliases, so this should work:\n// type KeySpecifier = (string | KeySpecifier)[]\nexport type KeySpecifier = ReadonlyArray<string | KeySpecifier>;\n\nexport type KeyFieldsContext = {\n  // The __typename of the incoming object, even if the __typename field was\n  // aliased to another name in the raw result object. May be undefined when\n  // dataIdFromObject is called for objects without __typename fields.\n  typename: string | undefined;\n\n  // The object to be identified, after processing to remove aliases and\n  // normalize identifiable child objects with references.\n  storeObject: StoreObject;\n\n  // Handy tool for reading additional fields from context.storeObject, either\n  // readField(\"fieldName\") to read storeObject[fieldName], or readField(\"name\",\n  // objectOrReference) to read from another object or Reference. If you read a\n  // field with a read function, that function will be invoked.\n  readField: ReadFieldFunction;\n\n  // If you are writing a custom keyFields function, and you plan to use the raw\n  // result object passed as the first argument, you may also need access to the\n  // selection set and available fragments for this object, just in case any\n  // fields have aliases. Since this logic is tricky to get right, and these\n  // context properties are not even always provided (for example, they are\n  // omitted when calling cache.identify(object), where object is assumed to be\n  // a StoreObject), we recommend you use context.storeObject (which has already\n  // been de-aliased) and context.readField (which can read from references as\n  // well as objects) instead of the raw result object in your keyFields\n  // functions, or just rely on the internal implementation of keyFields:[...]\n  // syntax to get these details right for you.\n  selectionSet?: SelectionSetNode;\n  fragmentMap?: FragmentMap;\n\n  // Internal. May be set by the KeyFieldsFunction to report fields that were\n  // involved in computing the ID. Never passed in by the caller.\n  keyObject?: Record<string, any>;\n};\n\nexport type KeyFieldsFunction = (\n  object: Readonly<StoreObject>,\n  context: KeyFieldsContext\n) => KeySpecifier | false | ReturnType<IdGetter>;\n\ntype KeyFieldsResult = Exclude<ReturnType<KeyFieldsFunction>, KeySpecifier>;\n\n// TODO Should TypePolicy be a generic type, with a TObject or TEntity\n// type parameter?\nexport type TypePolicy = {\n  // Allows defining the primary key fields for this type, either using an\n  // array of field names or a function that returns an arbitrary string.\n  keyFields?: KeySpecifier | KeyFieldsFunction | false;\n\n  // Allows defining a merge function (or merge:true/false shorthand) to\n  // be used for merging objects of this type wherever they appear, unless\n  // the parent field also defines a merge function/boolean (that is,\n  // parent field merge functions take precedence over type policy merge\n  // functions). In many cases, defining merge:true for a given type\n  // policy can save you from specifying merge:true for all the field\n  // policies where that type might be encountered.\n  merge?: FieldMergeFunction | boolean;\n\n  // In the rare event that your schema happens to use a different\n  // __typename for the root Query, Mutation, and/or Schema types, you can\n  // express your deviant preferences by enabling one of these options.\n  queryType?: true;\n  mutationType?: true;\n  subscriptionType?: true;\n\n  fields?: {\n    [fieldName: string]: FieldPolicy<any> | FieldReadFunction<any>;\n  };\n};\n\nexport type KeyArgsFunction = (\n  args: Record<string, any> | null,\n  context: {\n    typename: string;\n    fieldName: string;\n    field: FieldNode | null;\n    variables?: Record<string, any>;\n  }\n) => KeySpecifier | false | ReturnType<IdGetter>;\n\nexport type FieldPolicy<\n  // The internal representation used to store the field's data in the\n  // cache. Must be JSON-serializable if you plan to serialize the result\n  // of cache.extract() using JSON.\n  TExisting = any,\n  // The type of the incoming parameter passed to the merge function,\n  // typically matching the GraphQL response format, but with Reference\n  // objects substituted for any identifiable child objects. Often the\n  // same as TExisting, but not necessarily.\n  TIncoming = TExisting,\n  // The type that the read function actually returns, using TExisting\n  // data and options.args as input. Usually the same as TIncoming.\n  TReadResult = TIncoming,\n  // Allows FieldFunctionOptions definition to be overwritten by the\n  // developer\n  TOptions extends FieldFunctionOptions = FieldFunctionOptions,\n> = {\n  keyArgs?: KeySpecifier | KeyArgsFunction | false;\n  read?: FieldReadFunction<TExisting, TReadResult, TOptions>;\n  merge?: FieldMergeFunction<TExisting, TIncoming, TOptions> | boolean;\n};\n\nexport type StorageType = Record<string, any>;\n\nfunction argsFromFieldSpecifier(spec: FieldSpecifier) {\n  return (\n    spec.args !== void 0 ? spec.args\n    : spec.field ? argumentsObjectFromField(spec.field, spec.variables)\n    : null\n  );\n}\n\nexport interface FieldFunctionOptions<\n  TArgs = Record<string, any>,\n  TVars = Record<string, any>,\n> {\n  args: TArgs | null;\n\n  // The name of the field, equal to options.field.name.value when\n  // options.field is available. Useful if you reuse the same function for\n  // multiple fields, and you need to know which field you're currently\n  // processing. Always a string, even when options.field is null.\n  fieldName: string;\n\n  // The full field key used internally, including serialized key arguments.\n  storeFieldName: string;\n\n  // The FieldNode object used to read this field. Useful if you need to\n  // know about other attributes of the field, such as its directives. This\n  // option will be null when a string was passed to options.readField.\n  field: FieldNode | null;\n\n  variables?: TVars;\n\n  // Utilities for dealing with { __ref } objects.\n  isReference: typeof isReference;\n  toReference: ToReferenceFunction;\n\n  // A handy place to put field-specific data that you want to survive\n  // across multiple read function calls. Useful for field-level caching,\n  // if your read function does any expensive work.\n  storage: StorageType;\n\n  cache: InMemoryCache;\n\n  // Helper function for reading other fields within the current object.\n  // If a foreign object or reference is provided, the field will be read\n  // from that object instead of the current object, so this function can\n  // be used (together with isReference) to examine the cache outside the\n  // current object. If a FieldNode is passed instead of a string, and\n  // that FieldNode has arguments, the same options.variables will be used\n  // to compute the argument values. Note that this function will invoke\n  // custom read functions for other fields, if defined. Always returns\n  // immutable data (enforced with Object.freeze in development).\n  readField: ReadFieldFunction;\n\n  // Returns true for non-normalized StoreObjects and non-dangling\n  // References, indicating that readField(name, objOrRef) has a chance of\n  // working. Useful for filtering out dangling references from lists.\n  canRead: CanReadFunction;\n\n  // Instead of just merging objects with { ...existing, ...incoming }, this\n  // helper function can be used to merge objects in a way that respects any\n  // custom merge functions defined for their fields.\n  mergeObjects: MergeObjectsFunction;\n}\n\ntype MergeObjectsFunction = <T extends StoreObject | Reference>(\n  existing: T,\n  incoming: T\n) => T;\n\nexport type FieldReadFunction<\n  TExisting = any,\n  TReadResult = TExisting,\n  TOptions extends FieldFunctionOptions = FieldFunctionOptions,\n> = (\n  // When reading a field, one often needs to know about any existing\n  // value stored for that field. If the field is read before any value\n  // has been written to the cache, this existing parameter will be\n  // undefined, which makes it easy to use a default parameter expression\n  // to supply the initial value. This parameter is positional (rather\n  // than one of the named options) because that makes it possible for the\n  // developer to annotate it with a type, without also having to provide\n  // a whole new type for the options object.\n  existing: SafeReadonly<TExisting> | undefined,\n  options: TOptions\n) => TReadResult | undefined;\n\nexport type FieldMergeFunction<\n  TExisting = any,\n  TIncoming = TExisting,\n  // Passing the whole FieldFunctionOptions makes the current definition\n  // independent from its implementation\n  TOptions extends FieldFunctionOptions = FieldFunctionOptions,\n> = (\n  existing: SafeReadonly<TExisting> | undefined,\n  // The incoming parameter needs to be positional as well, for the same\n  // reasons discussed in FieldReadFunction above.\n  incoming: SafeReadonly<TIncoming>,\n  options: TOptions\n) => SafeReadonly<TExisting>;\n\nconst nullKeyFieldsFn: KeyFieldsFunction = () => void 0;\nconst simpleKeyArgsFn: KeyArgsFunction = (_args, context) => context.fieldName;\n\n// These merge functions can be selected by specifying merge:true or\n// merge:false in a field policy.\nconst mergeTrueFn: FieldMergeFunction<any> = (\n  existing,\n  incoming,\n  { mergeObjects }\n) => mergeObjects(existing, incoming);\nconst mergeFalseFn: FieldMergeFunction<any> = (_, incoming) => incoming;\n\nexport type PossibleTypesMap = {\n  [supertype: string]: string[];\n};\n\nexport class Policies {\n  private typePolicies: {\n    [__typename: string]: {\n      keyFn?: KeyFieldsFunction;\n      merge?: FieldMergeFunction<any>;\n      fields: {\n        [fieldName: string]: {\n          keyFn?: KeyArgsFunction;\n          read?: FieldReadFunction<any>;\n          merge?: FieldMergeFunction<any>;\n        };\n      };\n    };\n  } = Object.create(null);\n\n  private toBeAdded: {\n    [__typename: string]: TypePolicy[];\n  } = Object.create(null);\n\n  // Map from subtype names to sets of supertype names. Note that this\n  // representation inverts the structure of possibleTypes (whose keys are\n  // supertypes and whose values are arrays of subtypes) because it tends\n  // to be much more efficient to search upwards than downwards.\n  private supertypeMap = new Map<string, Set<string>>();\n\n  // Any fuzzy subtypes specified by possibleTypes will be converted to\n  // RegExp objects and recorded here. Every key of this map can also be\n  // found in supertypeMap. In many cases this Map will be empty, which\n  // means no fuzzy subtype checking will happen in fragmentMatches.\n  private fuzzySubtypes = new Map<string, RegExp>();\n\n  public readonly cache: InMemoryCache;\n\n  public readonly rootIdsByTypename: Record<string, string> =\n    Object.create(null);\n  public readonly rootTypenamesById: Record<string, string> =\n    Object.create(null);\n\n  public readonly usingPossibleTypes = false;\n\n  constructor(\n    private config: {\n      cache: InMemoryCache;\n      dataIdFromObject?: KeyFieldsFunction;\n      possibleTypes?: PossibleTypesMap;\n      typePolicies?: TypePolicies;\n    }\n  ) {\n    this.config = {\n      dataIdFromObject: defaultDataIdFromObject,\n      ...config,\n    };\n\n    this.cache = this.config.cache;\n\n    this.setRootTypename(\"Query\");\n    this.setRootTypename(\"Mutation\");\n    this.setRootTypename(\"Subscription\");\n\n    if (config.possibleTypes) {\n      this.addPossibleTypes(config.possibleTypes);\n    }\n\n    if (config.typePolicies) {\n      this.addTypePolicies(config.typePolicies);\n    }\n  }\n\n  public identify(\n    object: StoreObject,\n    partialContext?: Partial<KeyFieldsContext>\n  ): [string?, StoreObject?] {\n    const policies = this;\n\n    const typename =\n      (partialContext &&\n        (partialContext.typename || partialContext.storeObject?.__typename)) ||\n      object.__typename;\n\n    // It should be possible to write root Query fields with writeFragment,\n    // using { __typename: \"Query\", ... } as the data, but it does not make\n    // sense to allow the same identification behavior for the Mutation and\n    // Subscription types, since application code should never be writing\n    // directly to (or reading directly from) those root objects.\n    if (typename === this.rootTypenamesById.ROOT_QUERY) {\n      return [\"ROOT_QUERY\"];\n    }\n\n    // Default context.storeObject to object if not otherwise provided.\n    const storeObject =\n      (partialContext && partialContext.storeObject) || object;\n\n    const context: KeyFieldsContext = {\n      ...partialContext,\n      typename,\n      storeObject,\n      readField:\n        (partialContext && partialContext.readField) ||\n        function () {\n          const options = normalizeReadFieldOptions(arguments, storeObject);\n          return policies.readField(options, {\n            store: policies.cache[\"data\"],\n            variables: options.variables,\n          });\n        },\n    };\n\n    let id: KeyFieldsResult;\n\n    const policy = typename && this.getTypePolicy(typename);\n    let keyFn = (policy && policy.keyFn) || this.config.dataIdFromObject;\n\n    disableWarningsSlot.withValue(true, () => {\n      while (keyFn) {\n        const specifierOrId = keyFn({ ...object, ...storeObject }, context);\n        if (isArray(specifierOrId)) {\n          keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n        } else {\n          id = specifierOrId;\n          break;\n        }\n      }\n    });\n\n    id = id ? String(id) : void 0;\n    return context.keyObject ? [id, context.keyObject] : [id];\n  }\n\n  public addTypePolicies(typePolicies: TypePolicies) {\n    Object.keys(typePolicies).forEach((typename) => {\n      const { queryType, mutationType, subscriptionType, ...incoming } =\n        typePolicies[typename];\n\n      // Though {query,mutation,subscription}Type configurations are rare,\n      // it's important to call setRootTypename as early as possible,\n      // since these configurations should apply consistently for the\n      // entire lifetime of the cache. Also, since only one __typename can\n      // qualify as one of these root types, these three properties cannot\n      // be inherited, unlike the rest of the incoming properties. That\n      // restriction is convenient, because the purpose of this.toBeAdded\n      // is to delay the processing of type/field policies until the first\n      // time they're used, allowing policies to be added in any order as\n      // long as all relevant policies (including policies for supertypes)\n      // have been added by the time a given policy is used for the first\n      // time. In other words, since inheritance doesn't matter for these\n      // properties, there's also no need to delay their processing using\n      // the this.toBeAdded queue.\n      if (queryType) this.setRootTypename(\"Query\", typename);\n      if (mutationType) this.setRootTypename(\"Mutation\", typename);\n      if (subscriptionType) this.setRootTypename(\"Subscription\", typename);\n\n      if (hasOwn.call(this.toBeAdded, typename)) {\n        this.toBeAdded[typename].push(incoming);\n      } else {\n        this.toBeAdded[typename] = [incoming];\n      }\n    });\n  }\n\n  private updateTypePolicy(typename: string, incoming: TypePolicy) {\n    const existing = this.getTypePolicy(typename);\n    const { keyFields, fields } = incoming;\n\n    function setMerge(\n      existing: { merge?: FieldMergeFunction | boolean },\n      merge?: FieldMergeFunction | boolean\n    ) {\n      existing.merge =\n        typeof merge === \"function\" ? merge\n          // Pass merge:true as a shorthand for a merge implementation\n          // that returns options.mergeObjects(existing, incoming).\n        : merge === true ? mergeTrueFn\n          // Pass merge:false to make incoming always replace existing\n          // without any warnings about data clobbering.\n        : merge === false ? mergeFalseFn\n        : existing.merge;\n    }\n\n    // Type policies can define merge functions, as an alternative to\n    // using field policies to merge child objects.\n    setMerge(existing, incoming.merge);\n\n    existing.keyFn =\n      // Pass false to disable normalization for this typename.\n      keyFields === false ? nullKeyFieldsFn\n        // Pass an array of strings to use those fields to compute a\n        // composite ID for objects of this typename.\n      : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields)\n        // Pass a function to take full control over identification.\n      : typeof keyFields === \"function\" ? keyFields\n        // Leave existing.keyFn unchanged if above cases fail.\n      : existing.keyFn;\n\n    if (fields) {\n      Object.keys(fields).forEach((fieldName) => {\n        const existing = this.getFieldPolicy(typename, fieldName, true)!;\n        const incoming = fields[fieldName];\n\n        if (typeof incoming === \"function\") {\n          existing.read = incoming;\n        } else {\n          const { keyArgs, read, merge } = incoming;\n\n          existing.keyFn =\n            // Pass false to disable argument-based differentiation of\n            // field identities.\n            keyArgs === false ? simpleKeyArgsFn\n              // Pass an array of strings to use named arguments to\n              // compute a composite identity for the field.\n            : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs)\n              // Pass a function to take full control over field identity.\n            : typeof keyArgs === \"function\" ? keyArgs\n              // Leave existing.keyFn unchanged if above cases fail.\n            : existing.keyFn;\n\n          if (typeof read === \"function\") {\n            existing.read = read;\n          }\n\n          setMerge(existing, merge);\n        }\n\n        if (existing.read && existing.merge) {\n          // If we have both a read and a merge function, assume\n          // keyArgs:false, because read and merge together can take\n          // responsibility for interpreting arguments in and out. This\n          // default assumption can always be overridden by specifying\n          // keyArgs explicitly in the FieldPolicy.\n          existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n        }\n      });\n    }\n  }\n\n  private setRootTypename(\n    which: \"Query\" | \"Mutation\" | \"Subscription\",\n    typename: string = which\n  ) {\n    const rootId = \"ROOT_\" + which.toUpperCase();\n    const old = this.rootTypenamesById[rootId];\n    if (typename !== old) {\n      invariant(\n        !old || old === which,\n        `Cannot change root %s __typename more than once`,\n        which\n      );\n      // First, delete any old __typename associated with this rootId from\n      // rootIdsByTypename.\n      if (old) delete this.rootIdsByTypename[old];\n      // Now make this the only __typename that maps to this rootId.\n      this.rootIdsByTypename[typename] = rootId;\n      // Finally, update the __typename associated with this rootId.\n      this.rootTypenamesById[rootId] = typename;\n    }\n  }\n\n  public addPossibleTypes(possibleTypes: PossibleTypesMap) {\n    (this.usingPossibleTypes as boolean) = true;\n    Object.keys(possibleTypes).forEach((supertype) => {\n      // Make sure all types have an entry in this.supertypeMap, even if\n      // their supertype set is empty, so we can return false immediately\n      // from policies.fragmentMatches for unknown supertypes.\n      this.getSupertypeSet(supertype, true);\n\n      possibleTypes[supertype].forEach((subtype) => {\n        this.getSupertypeSet(subtype, true)!.add(supertype);\n        const match = subtype.match(TypeOrFieldNameRegExp);\n        if (!match || match[0] !== subtype) {\n          // TODO Don't interpret just any invalid typename as a RegExp.\n          this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n        }\n      });\n    });\n  }\n\n  private getTypePolicy(typename: string): Policies[\"typePolicies\"][string] {\n    if (!hasOwn.call(this.typePolicies, typename)) {\n      const policy: Policies[\"typePolicies\"][string] = (this.typePolicies[\n        typename\n      ] = Object.create(null));\n      policy.fields = Object.create(null);\n\n      // When the TypePolicy for typename is first accessed, instead of\n      // starting with an empty policy object, inherit any properties or\n      // fields from the type policies of the supertypes of typename.\n      //\n      // Any properties or fields defined explicitly within the TypePolicy\n      // for typename will take precedence, and if there are multiple\n      // supertypes, the properties of policies whose types were added\n      // later via addPossibleTypes will take precedence over those of\n      // earlier supertypes. TODO Perhaps we should warn about these\n      // conflicts in development, and recommend defining the property\n      // explicitly in the subtype policy?\n      //\n      // Field policy inheritance is atomic/shallow: you can't inherit a\n      // field policy and then override just its read function, since read\n      // and merge functions often need to cooperate, so changing only one\n      // of them would be a recipe for inconsistency.\n      //\n      // Once the TypePolicy for typename has been accessed, its properties can\n      // still be updated directly using addTypePolicies, but future changes to\n      // inherited supertype policies will not be reflected in this subtype\n      // policy, because this code runs at most once per typename.\n      let supertypes = this.supertypeMap.get(typename);\n      if (!supertypes && this.fuzzySubtypes.size) {\n        // To make the inheritance logic work for unknown typename strings that\n        // may have fuzzy supertypes, we give this typename an empty supertype\n        // set and then populate it with any fuzzy supertypes that match.\n        supertypes = this.getSupertypeSet(typename, true)!;\n        // This only works for typenames that are directly matched by a fuzzy\n        // supertype. What if there is an intermediate chain of supertypes?\n        // While possible, that situation can only be solved effectively by\n        // specifying the intermediate relationships via possibleTypes, manually\n        // and in a non-fuzzy way.\n        this.fuzzySubtypes.forEach((regExp, fuzzy) => {\n          if (regExp.test(typename)) {\n            // The fuzzy parameter is just the original string version of regExp\n            // (not a valid __typename string), but we can look up the\n            // associated supertype(s) in this.supertypeMap.\n            const fuzzySupertypes = this.supertypeMap.get(fuzzy);\n            if (fuzzySupertypes) {\n              fuzzySupertypes.forEach((supertype) =>\n                supertypes!.add(supertype)\n              );\n            }\n          }\n        });\n      }\n      if (supertypes && supertypes.size) {\n        supertypes.forEach((supertype) => {\n          const { fields, ...rest } = this.getTypePolicy(supertype);\n          Object.assign(policy, rest);\n          Object.assign(policy.fields, fields);\n        });\n      }\n    }\n\n    const inbox = this.toBeAdded[typename];\n    if (inbox && inbox.length) {\n      // Merge the pending policies into this.typePolicies, in the order they\n      // were originally passed to addTypePolicy.\n      inbox.splice(0).forEach((policy) => {\n        this.updateTypePolicy(typename, policy);\n      });\n    }\n\n    return this.typePolicies[typename];\n  }\n\n  private getFieldPolicy(\n    typename: string | undefined,\n    fieldName: string,\n    createIfMissing: boolean\n  ):\n    | {\n        keyFn?: KeyArgsFunction;\n        read?: FieldReadFunction<any>;\n        merge?: FieldMergeFunction<any>;\n      }\n    | undefined {\n    if (typename) {\n      const fieldPolicies = this.getTypePolicy(typename).fields;\n      return (\n        fieldPolicies[fieldName] ||\n        (createIfMissing && (fieldPolicies[fieldName] = Object.create(null)))\n      );\n    }\n  }\n\n  private getSupertypeSet(\n    subtype: string,\n    createIfMissing: boolean\n  ): Set<string> | undefined {\n    let supertypeSet = this.supertypeMap.get(subtype);\n    if (!supertypeSet && createIfMissing) {\n      this.supertypeMap.set(subtype, (supertypeSet = new Set<string>()));\n    }\n    return supertypeSet;\n  }\n\n  public fragmentMatches(\n    fragment: InlineFragmentNode | FragmentDefinitionNode,\n    typename: string | undefined,\n    result?: Record<string, any>,\n    variables?: Record<string, any>\n  ): boolean {\n    if (!fragment.typeCondition) return true;\n\n    // If the fragment has a type condition but the object we're matching\n    // against does not have a __typename, the fragment cannot match.\n    if (!typename) return false;\n\n    const supertype = fragment.typeCondition.name.value;\n    // Common case: fragment type condition and __typename are the same.\n    if (typename === supertype) return true;\n\n    if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {\n      const typenameSupertypeSet = this.getSupertypeSet(typename, true)!;\n      const workQueue = [typenameSupertypeSet];\n      const maybeEnqueue = (subtype: string) => {\n        const supertypeSet = this.getSupertypeSet(subtype, false);\n        if (\n          supertypeSet &&\n          supertypeSet.size &&\n          workQueue.indexOf(supertypeSet) < 0\n        ) {\n          workQueue.push(supertypeSet);\n        }\n      };\n\n      // We need to check fuzzy subtypes only if we encountered fuzzy\n      // subtype strings in addPossibleTypes, and only while writing to\n      // the cache, since that's when selectionSetMatchesResult gives a\n      // strong signal of fragment matching. The StoreReader class calls\n      // policies.fragmentMatches without passing a result object, so\n      // needToCheckFuzzySubtypes is always false while reading.\n      let needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n      let checkingFuzzySubtypes = false;\n\n      // It's important to keep evaluating workQueue.length each time through\n      // the loop, because the queue can grow while we're iterating over it.\n      for (let i = 0; i < workQueue.length; ++i) {\n        const supertypeSet = workQueue[i];\n\n        if (supertypeSet.has(supertype)) {\n          if (!typenameSupertypeSet.has(supertype)) {\n            if (checkingFuzzySubtypes) {\n              invariant.warn(\n                `Inferring subtype %s of supertype %s`,\n                typename,\n                supertype\n              );\n            }\n            // Record positive results for faster future lookup.\n            // Unfortunately, we cannot safely cache negative results,\n            // because new possibleTypes data could always be added to the\n            // Policies class.\n            typenameSupertypeSet.add(supertype);\n          }\n          return true;\n        }\n\n        supertypeSet.forEach(maybeEnqueue);\n\n        if (\n          needToCheckFuzzySubtypes &&\n          // Start checking fuzzy subtypes only after exhausting all\n          // non-fuzzy subtypes (after the final iteration of the loop).\n          i === workQueue.length - 1 &&\n          // We could wait to compare fragment.selectionSet to result\n          // after we verify the supertype, but this check is often less\n          // expensive than that search, and we will have to do the\n          // comparison anyway whenever we find a potential match.\n          selectionSetMatchesResult(fragment.selectionSet, result!, variables)\n        ) {\n          // We don't always need to check fuzzy subtypes (if no result\n          // was provided, or !this.fuzzySubtypes.size), but, when we do,\n          // we only want to check them once.\n          needToCheckFuzzySubtypes = false;\n          checkingFuzzySubtypes = true;\n\n          // If we find any fuzzy subtypes that match typename, extend the\n          // workQueue to search through the supertypes of those fuzzy\n          // subtypes. Otherwise the for-loop will terminate and we'll\n          // return false below.\n          this.fuzzySubtypes.forEach((regExp, fuzzyString) => {\n            const match = typename.match(regExp);\n            if (match && match[0] === typename) {\n              maybeEnqueue(fuzzyString);\n            }\n          });\n        }\n      }\n    }\n\n    return false;\n  }\n\n  public hasKeyArgs(typename: string | undefined, fieldName: string) {\n    const policy = this.getFieldPolicy(typename, fieldName, false);\n    return !!(policy && policy.keyFn);\n  }\n\n  public getStoreFieldName(fieldSpec: FieldSpecifier): string {\n    const { typename, fieldName } = fieldSpec;\n    const policy = this.getFieldPolicy(typename, fieldName, false);\n    let storeFieldName: Exclude<ReturnType<KeyArgsFunction>, KeySpecifier>;\n\n    let keyFn = policy && policy.keyFn;\n    if (keyFn && typename) {\n      const context: Parameters<KeyArgsFunction>[1] = {\n        typename,\n        fieldName,\n        field: fieldSpec.field || null,\n        variables: fieldSpec.variables,\n      };\n      const args = argsFromFieldSpecifier(fieldSpec);\n      while (keyFn) {\n        const specifierOrString = keyFn(args, context);\n        if (isArray(specifierOrString)) {\n          keyFn = keyArgsFnFromSpecifier(specifierOrString);\n        } else {\n          // If the custom keyFn returns a falsy value, fall back to\n          // fieldName instead.\n          storeFieldName = specifierOrString || fieldName;\n          break;\n        }\n      }\n    }\n\n    if (storeFieldName === void 0) {\n      storeFieldName =\n        fieldSpec.field ?\n          storeKeyNameFromField(fieldSpec.field, fieldSpec.variables)\n        : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n    }\n\n    // Returning false from a keyArgs function is like configuring\n    // keyArgs: false, but more dynamic.\n    if (storeFieldName === false) {\n      return fieldName;\n    }\n\n    // Make sure custom field names start with the actual field.name.value\n    // of the field, so we can always figure out which properties of a\n    // StoreObject correspond to which original field names.\n    return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName\n      : fieldName + \":\" + storeFieldName;\n  }\n\n  public readField<V = StoreValue>(\n    options: ReadFieldOptions,\n    context: ReadMergeModifyContext\n  ): SafeReadonly<V> | undefined {\n    const objectOrReference = options.from;\n    if (!objectOrReference) return;\n\n    const nameOrField = options.field || options.fieldName;\n    if (!nameOrField) return;\n\n    if (options.typename === void 0) {\n      const typename = context.store.getFieldValue<string>(\n        objectOrReference,\n        \"__typename\"\n      );\n      if (typename) options.typename = typename;\n    }\n\n    const storeFieldName = this.getStoreFieldName(options);\n    const fieldName = fieldNameFromStoreName(storeFieldName);\n    const existing = context.store.getFieldValue<V>(\n      objectOrReference,\n      storeFieldName\n    );\n    const policy = this.getFieldPolicy(options.typename, fieldName, false);\n    const read = policy && policy.read;\n\n    if (read) {\n      const readOptions = makeFieldFunctionOptions(\n        this,\n        objectOrReference,\n        options,\n        context,\n        context.store.getStorage(\n          isReference(objectOrReference) ?\n            objectOrReference.__ref\n          : objectOrReference,\n          storeFieldName\n        )\n      );\n\n      // Call read(existing, readOptions) with cacheSlot holding this.cache.\n      return cacheSlot.withValue(this.cache, read, [\n        existing,\n        readOptions,\n      ]) as SafeReadonly<V>;\n    }\n\n    return existing;\n  }\n\n  public getReadFunction(\n    typename: string | undefined,\n    fieldName: string\n  ): FieldReadFunction | undefined {\n    const policy = this.getFieldPolicy(typename, fieldName, false);\n    return policy && policy.read;\n  }\n\n  public getMergeFunction(\n    parentTypename: string | undefined,\n    fieldName: string,\n    childTypename: string | undefined\n  ): FieldMergeFunction | undefined {\n    let policy:\n      | Policies[\"typePolicies\"][string]\n      | Policies[\"typePolicies\"][string][\"fields\"][string]\n      | undefined = this.getFieldPolicy(parentTypename, fieldName, false);\n    let merge = policy && policy.merge;\n    if (!merge && childTypename) {\n      policy = this.getTypePolicy(childTypename);\n      merge = policy && policy.merge;\n    }\n    return merge;\n  }\n\n  public runMergeFunction(\n    existing: StoreValue,\n    incoming: StoreValue,\n    { field, typename, merge }: MergeInfo,\n    context: WriteContext,\n    storage?: StorageType\n  ) {\n    if (merge === mergeTrueFn) {\n      // Instead of going to the trouble of creating a full\n      // FieldFunctionOptions object and calling mergeTrueFn, we can\n      // simply call mergeObjects, as mergeTrueFn would.\n      return makeMergeObjectsFunction(context.store)(\n        existing as StoreObject,\n        incoming as StoreObject\n      );\n    }\n\n    if (merge === mergeFalseFn) {\n      // Likewise for mergeFalseFn, whose implementation is even simpler.\n      return incoming;\n    }\n\n    // If cache.writeQuery or cache.writeFragment was called with\n    // options.overwrite set to true, we still call merge functions, but\n    // the existing data is always undefined, so the merge function will\n    // not attempt to combine the incoming data with the existing data.\n    if (context.overwrite) {\n      existing = void 0;\n    }\n\n    return merge(\n      existing,\n      incoming,\n      makeFieldFunctionOptions(\n        this,\n        // Unlike options.readField for read functions, we do not fall\n        // back to the current object if no foreignObjOrRef is provided,\n        // because it's not clear what the current object should be for\n        // merge functions: the (possibly undefined) existing object, or\n        // the incoming object? If you think your merge function needs\n        // to read sibling fields in order to produce a new value for\n        // the current field, you might want to rethink your strategy,\n        // because that's a recipe for making merge behavior sensitive\n        // to the order in which fields are written into the cache.\n        // However, readField(name, ref) is useful for merge functions\n        // that need to deduplicate child objects and references.\n        void 0,\n        {\n          typename,\n          fieldName: field.name.value,\n          field,\n          variables: context.variables,\n        },\n        context,\n        storage || Object.create(null)\n      )\n    );\n  }\n}\n\nfunction makeFieldFunctionOptions(\n  policies: Policies,\n  objectOrReference: StoreObject | Reference | undefined,\n  fieldSpec: FieldSpecifier,\n  context: ReadMergeModifyContext,\n  storage: StorageType\n): FieldFunctionOptions {\n  const storeFieldName = policies.getStoreFieldName(fieldSpec);\n  const fieldName = fieldNameFromStoreName(storeFieldName);\n  const variables = fieldSpec.variables || context.variables;\n  const { toReference, canRead } = context.store;\n\n  return {\n    args: argsFromFieldSpecifier(fieldSpec),\n    field: fieldSpec.field || null,\n    fieldName,\n    storeFieldName,\n    variables,\n    isReference,\n    toReference,\n    storage,\n    cache: policies.cache,\n    canRead,\n    readField<T>() {\n      return policies.readField<T>(\n        normalizeReadFieldOptions(arguments, objectOrReference, variables),\n        context\n      );\n    },\n    mergeObjects: makeMergeObjectsFunction(context.store),\n  };\n}\n\nexport function normalizeReadFieldOptions(\n  readFieldArgs: IArguments,\n  objectOrReference: StoreObject | Reference | undefined,\n  variables?: ReadMergeModifyContext[\"variables\"]\n): ReadFieldOptions {\n  const { 0: fieldNameOrOptions, 1: from, length: argc } = readFieldArgs;\n\n  let options: ReadFieldOptions;\n\n  if (typeof fieldNameOrOptions === \"string\") {\n    options = {\n      fieldName: fieldNameOrOptions,\n      // Default to objectOrReference only when no second argument was\n      // passed for the from parameter, not when undefined is explicitly\n      // passed as the second argument.\n      from: argc > 1 ? from : objectOrReference,\n    };\n  } else {\n    options = { ...fieldNameOrOptions };\n    // Default to objectOrReference only when fieldNameOrOptions.from is\n    // actually omitted, rather than just undefined.\n    if (!hasOwn.call(options, \"from\")) {\n      options.from = objectOrReference;\n    }\n  }\n\n  if (__DEV__ && options.from === void 0) {\n    invariant.warn(\n      `Undefined 'from' passed to readField with arguments %s`,\n      stringifyForDisplay(Array.from(readFieldArgs))\n    );\n  }\n\n  if (void 0 === options.variables) {\n    options.variables = variables;\n  }\n\n  return options;\n}\n\nfunction makeMergeObjectsFunction(\n  store: NormalizedCache\n): MergeObjectsFunction {\n  return function mergeObjects(existing, incoming) {\n    if (isArray(existing) || isArray(incoming)) {\n      throw newInvariantError(\"Cannot automatically merge arrays\");\n    }\n\n    // These dynamic checks are necessary because the parameters of a\n    // custom merge function can easily have the any type, so the type\n    // system cannot always enforce the StoreObject | Reference parameter\n    // types of options.mergeObjects.\n    if (isNonNullObject(existing) && isNonNullObject(incoming)) {\n      const eType = store.getFieldValue(existing, \"__typename\");\n      const iType = store.getFieldValue(incoming, \"__typename\");\n      const typesDiffer = eType && iType && eType !== iType;\n\n      if (typesDiffer) {\n        return incoming;\n      }\n\n      if (isReference(existing) && storeValueIsStoreObject(incoming)) {\n        // Update the normalized EntityStore for the entity identified by\n        // existing.__ref, preferring/overwriting any fields contributed by the\n        // newer incoming StoreObject.\n        store.merge(existing.__ref, incoming);\n        return existing;\n      }\n\n      if (storeValueIsStoreObject(existing) && isReference(incoming)) {\n        // Update the normalized EntityStore for the entity identified by\n        // incoming.__ref, taking fields from the older existing object only if\n        // those fields are not already present in the newer StoreObject\n        // identified by incoming.__ref.\n        store.merge(existing, incoming.__ref);\n        return incoming;\n      }\n\n      if (\n        storeValueIsStoreObject(existing) &&\n        storeValueIsStoreObject(incoming)\n      ) {\n        return { ...existing, ...incoming };\n      }\n    }\n\n    return incoming;\n  };\n}\n", "import { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { Trie } from \"@wry/trie\";\nimport type { SelectionSetNode, FieldNode } from \"graphql\";\nimport { Kind } from \"graphql\";\n\nimport type {\n  FragmentMap,\n  FragmentMapFunction,\n  StoreValue,\n  StoreObject,\n  Reference,\n} from \"../../utilities/index.js\";\nimport {\n  getFragmentFromSelection,\n  getDefaultValues,\n  getOperationDefinition,\n  getTypenameFromResult,\n  makeReference,\n  isField,\n  resultKeyNameFromField,\n  isReference,\n  shouldInclude,\n  cloneDeep,\n  addTypenameToDocument,\n  isNonEmptyArray,\n  argumentsObjectFromField,\n  canonicalStringify,\n} from \"../../utilities/index.js\";\n\nimport type {\n  NormalizedCache,\n  ReadMergeModifyContext,\n  MergeTree,\n  InMemoryCacheConfig,\n} from \"./types.js\";\nimport {\n  isArray,\n  makeProcessedFieldsMerger,\n  fieldNameFromStoreName,\n  storeValueIsStoreObject,\n  extractFragmentContext,\n} from \"./helpers.js\";\nimport type { StoreReader } from \"./readFromStore.js\";\nimport type { InMemoryCache } from \"./inMemoryCache.js\";\nimport type { EntityStore } from \"./entityStore.js\";\nimport type { Cache } from \"../../core/index.js\";\nimport { normalizeReadFieldOptions } from \"./policies.js\";\nimport type { ReadFieldFunction } from \"../core/types/common.js\";\n\nexport interface WriteContext extends ReadMergeModifyContext {\n  readonly written: {\n    [dataId: string]: SelectionSetNode[];\n  };\n  readonly fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n  // General-purpose deep-merge function for use during writes.\n  merge<T>(existing: T, incoming: T): T;\n  // If true, merge functions will be called with undefined existing data.\n  overwrite: boolean;\n  incomingById: Map<\n    string,\n    {\n      storeObject: StoreObject;\n      mergeTree?: MergeTree;\n      fieldNodeSet: Set<FieldNode>;\n    }\n  >;\n  // Directive metadata for @client and @defer. We could use a bitfield for this\n  // information to save some space, and use that bitfield number as the keys in\n  // the context.flavors Map.\n  clientOnly: boolean;\n  deferred: boolean;\n  flavors: Map<string, FlavorableWriteContext>;\n}\n\ntype FlavorableWriteContext = Pick<\n  WriteContext,\n  \"clientOnly\" | \"deferred\" | \"flavors\"\n>;\n\n// Since there are only four possible combinations of context.clientOnly and\n// context.deferred values, we should need at most four \"flavors\" of any given\n// WriteContext. To avoid creating multiple copies of the same context, we cache\n// the contexts in the context.flavors Map (shared by all flavors) according to\n// their clientOnly and deferred values (always in that order).\nfunction getContextFlavor<TContext extends FlavorableWriteContext>(\n  context: TContext,\n  clientOnly: TContext[\"clientOnly\"],\n  deferred: TContext[\"deferred\"]\n): TContext {\n  const key = `${clientOnly}${deferred}`;\n  let flavored = context.flavors.get(key);\n  if (!flavored) {\n    context.flavors.set(\n      key,\n      (flavored =\n        context.clientOnly === clientOnly && context.deferred === deferred ?\n          context\n        : {\n            ...context,\n            clientOnly,\n            deferred,\n          })\n    );\n  }\n  return flavored as TContext;\n}\n\ninterface ProcessSelectionSetOptions {\n  dataId?: string;\n  result: Record<string, any>;\n  selectionSet: SelectionSetNode;\n  context: WriteContext;\n  mergeTree: MergeTree;\n}\n\nexport class StoreWriter {\n  constructor(\n    public readonly cache: InMemoryCache,\n    private reader?: StoreReader,\n    private fragments?: InMemoryCacheConfig[\"fragments\"]\n  ) {}\n\n  public writeToStore(\n    store: NormalizedCache,\n    { query, result, dataId, variables, overwrite }: Cache.WriteOptions\n  ): Reference | undefined {\n    const operationDefinition = getOperationDefinition(query)!;\n    const merger = makeProcessedFieldsMerger();\n\n    variables = {\n      ...getDefaultValues(operationDefinition),\n      ...variables!,\n    };\n\n    const context: WriteContext = {\n      store,\n      written: Object.create(null),\n      merge<T>(existing: T, incoming: T) {\n        return merger.merge(existing, incoming) as T;\n      },\n      variables,\n      varString: canonicalStringify(variables),\n      ...extractFragmentContext(query, this.fragments),\n      overwrite: !!overwrite,\n      incomingById: new Map(),\n      clientOnly: false,\n      deferred: false,\n      flavors: new Map(),\n    };\n\n    const ref = this.processSelectionSet({\n      result: result || Object.create(null),\n      dataId,\n      selectionSet: operationDefinition.selectionSet,\n      mergeTree: { map: new Map() },\n      context,\n    });\n\n    if (!isReference(ref)) {\n      throw newInvariantError(`Could not identify object %s`, result);\n    }\n\n    // So far, the store has not been modified, so now it's time to process\n    // context.incomingById and merge those incoming fields into context.store.\n    context.incomingById.forEach(\n      ({ storeObject, mergeTree, fieldNodeSet }, dataId) => {\n        const entityRef = makeReference(dataId);\n\n        if (mergeTree && mergeTree.map.size) {\n          const applied = this.applyMerges(\n            mergeTree,\n            entityRef,\n            storeObject,\n            context\n          );\n          if (isReference(applied)) {\n            // Assume References returned by applyMerges have already been merged\n            // into the store. See makeMergeObjectsFunction in policies.ts for an\n            // example of how this can happen.\n            return;\n          }\n          // Otherwise, applyMerges returned a StoreObject, whose fields we should\n          // merge into the store (see store.merge statement below).\n          storeObject = applied;\n        }\n\n        if (__DEV__ && !context.overwrite) {\n          const fieldsWithSelectionSets: Record<string, true> =\n            Object.create(null);\n          fieldNodeSet.forEach((field) => {\n            if (field.selectionSet) {\n              fieldsWithSelectionSets[field.name.value] = true;\n            }\n          });\n\n          const hasSelectionSet = (storeFieldName: string) =>\n            fieldsWithSelectionSets[fieldNameFromStoreName(storeFieldName)] ===\n            true;\n\n          const hasMergeFunction = (storeFieldName: string) => {\n            const childTree = mergeTree && mergeTree.map.get(storeFieldName);\n            return Boolean(childTree && childTree.info && childTree.info.merge);\n          };\n\n          Object.keys(storeObject).forEach((storeFieldName) => {\n            // If a merge function was defined for this field, trust that it\n            // did the right thing about (not) clobbering data. If the field\n            // has no selection set, it's a scalar field, so it doesn't need\n            // a merge function (even if it's an object, like JSON data).\n            if (\n              hasSelectionSet(storeFieldName) &&\n              !hasMergeFunction(storeFieldName)\n            ) {\n              warnAboutDataLoss(\n                entityRef,\n                storeObject,\n                storeFieldName,\n                context.store\n              );\n            }\n          });\n        }\n\n        store.merge(dataId, storeObject);\n      }\n    );\n\n    // Any IDs written explicitly to the cache will be retained as\n    // reachable root IDs for garbage collection purposes. Although this\n    // logic includes root IDs like ROOT_QUERY and ROOT_MUTATION, their\n    // retainment counts are effectively ignored because cache.gc() always\n    // includes them in its root ID set.\n    store.retain(ref.__ref);\n\n    return ref;\n  }\n\n  private processSelectionSet({\n    dataId,\n    result,\n    selectionSet,\n    context,\n    // This object allows processSelectionSet to report useful information\n    // to its callers without explicitly returning that information.\n    mergeTree,\n  }: ProcessSelectionSetOptions): StoreObject | Reference {\n    const { policies } = this.cache;\n\n    // This variable will be repeatedly updated using context.merge to\n    // accumulate all fields that need to be written into the store.\n    let incoming: StoreObject = Object.create(null);\n\n    // If typename was not passed in, infer it. Note that typename is\n    // always passed in for tricky-to-infer cases such as \"Query\" for\n    // ROOT_QUERY.\n    const typename: string | undefined =\n      (dataId && policies.rootTypenamesById[dataId]) ||\n      getTypenameFromResult(result, selectionSet, context.fragmentMap) ||\n      (dataId && (context.store.get(dataId, \"__typename\") as string));\n\n    if (\"string\" === typeof typename) {\n      incoming.__typename = typename;\n    }\n\n    // This readField function will be passed as context.readField in the\n    // KeyFieldsContext object created within policies.identify (called below).\n    // In addition to reading from the existing context.store (thanks to the\n    // policies.readField(options, context) line at the very bottom), this\n    // version of readField can read from Reference objects that are currently\n    // pending in context.incomingById, which is important whenever keyFields\n    // need to be extracted from a child object that processSelectionSet has\n    // turned into a Reference.\n    const readField: ReadFieldFunction = function (this: void) {\n      const options = normalizeReadFieldOptions(\n        arguments,\n        incoming,\n        context.variables\n      );\n\n      if (isReference(options.from)) {\n        const info = context.incomingById.get(options.from.__ref);\n        if (info) {\n          const result = policies.readField(\n            {\n              ...options,\n              from: info.storeObject,\n            },\n            context\n          );\n\n          if (result !== void 0) {\n            return result;\n          }\n        }\n      }\n\n      return policies.readField(options, context);\n    };\n\n    const fieldNodeSet = new Set<FieldNode>();\n\n    this.flattenFields(\n      selectionSet,\n      result,\n      // This WriteContext will be the default context value for fields returned\n      // by the flattenFields method, but some fields may be assigned a modified\n      // context, depending on the presence of @client and other directives.\n      context,\n      typename\n    ).forEach((context, field) => {\n      const resultFieldKey = resultKeyNameFromField(field);\n      const value = result[resultFieldKey];\n\n      fieldNodeSet.add(field);\n\n      if (value !== void 0) {\n        const storeFieldName = policies.getStoreFieldName({\n          typename,\n          fieldName: field.name.value,\n          field,\n          variables: context.variables,\n        });\n\n        const childTree = getChildMergeTree(mergeTree, storeFieldName);\n\n        let incomingValue = this.processFieldValue(\n          value,\n          field,\n          // Reset context.clientOnly and context.deferred to their default\n          // values before processing nested selection sets.\n          field.selectionSet ?\n            getContextFlavor(context, false, false)\n          : context,\n          childTree\n        );\n\n        // To determine if this field holds a child object with a merge function\n        // defined in its type policy (see PR #7070), we need to figure out the\n        // child object's __typename.\n        let childTypename: string | undefined;\n\n        // The field's value can be an object that has a __typename only if the\n        // field has a selection set. Otherwise incomingValue is scalar.\n        if (\n          field.selectionSet &&\n          (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))\n        ) {\n          childTypename = readField<string>(\"__typename\", incomingValue);\n        }\n\n        const merge = policies.getMergeFunction(\n          typename,\n          field.name.value,\n          childTypename\n        );\n\n        if (merge) {\n          childTree.info = {\n            // TODO Check compatibility against any existing childTree.field?\n            field,\n            typename,\n            merge,\n          };\n        } else {\n          maybeRecycleChildMergeTree(mergeTree, storeFieldName);\n        }\n\n        incoming = context.merge(incoming, {\n          [storeFieldName]: incomingValue,\n        });\n      } else if (\n        __DEV__ &&\n        !context.clientOnly &&\n        !context.deferred &&\n        !addTypenameToDocument.added(field) &&\n        // If the field has a read function, it may be a synthetic field or\n        // provide a default value, so its absence from the written data should\n        // not be cause for alarm.\n        !policies.getReadFunction(typename, field.name.value)\n      ) {\n        invariant.error(\n          `Missing field '%s' while writing result %o`,\n          resultKeyNameFromField(field),\n          result\n        );\n      }\n    });\n\n    // Identify the result object, even if dataId was already provided,\n    // since we always need keyObject below.\n    try {\n      const [id, keyObject] = policies.identify(result, {\n        typename,\n        selectionSet,\n        fragmentMap: context.fragmentMap,\n        storeObject: incoming,\n        readField,\n      });\n\n      // If dataId was not provided, fall back to the id just generated by\n      // policies.identify.\n      dataId = dataId || id;\n\n      // Write any key fields that were used during identification, even if\n      // they were not mentioned in the original query.\n      if (keyObject) {\n        // TODO Reverse the order of the arguments?\n        incoming = context.merge(incoming, keyObject);\n      }\n    } catch (e) {\n      // If dataId was provided, tolerate failure of policies.identify.\n      if (!dataId) throw e;\n    }\n\n    if (\"string\" === typeof dataId) {\n      const dataRef = makeReference(dataId);\n\n      // Avoid processing the same entity object using the same selection\n      // set more than once. We use an array instead of a Set since most\n      // entity IDs will be written using only one selection set, so the\n      // size of this array is likely to be very small, meaning indexOf is\n      // likely to be faster than Set.prototype.has.\n      const sets = context.written[dataId] || (context.written[dataId] = []);\n      if (sets.indexOf(selectionSet) >= 0) return dataRef;\n      sets.push(selectionSet);\n\n      // If we're about to write a result object into the store, but we\n      // happen to know that the exact same (===) result object would be\n      // returned if we were to reread the result with the same inputs,\n      // then we can skip the rest of the processSelectionSet work for\n      // this object, and immediately return a Reference to it.\n      if (\n        this.reader &&\n        this.reader.isFresh(result, dataRef, selectionSet, context)\n      ) {\n        return dataRef;\n      }\n\n      const previous = context.incomingById.get(dataId);\n      if (previous) {\n        previous.storeObject = context.merge(previous.storeObject, incoming);\n        previous.mergeTree = mergeMergeTrees(previous.mergeTree, mergeTree);\n        fieldNodeSet.forEach((field) => previous.fieldNodeSet.add(field));\n      } else {\n        context.incomingById.set(dataId, {\n          storeObject: incoming,\n          // Save a reference to mergeTree only if it is not empty, because\n          // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and\n          // reused for entirely different parts of the result tree.\n          mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,\n          fieldNodeSet,\n        });\n      }\n\n      return dataRef;\n    }\n\n    return incoming;\n  }\n\n  private processFieldValue(\n    value: any,\n    field: FieldNode,\n    context: WriteContext,\n    mergeTree: MergeTree\n  ): StoreValue {\n    if (!field.selectionSet || value === null) {\n      // In development, we need to clone scalar values so that they can be\n      // safely frozen with maybeDeepFreeze in readFromStore.ts. In production,\n      // it's cheaper to store the scalar values directly in the cache.\n      return __DEV__ ? cloneDeep(value) : value;\n    }\n\n    if (isArray(value)) {\n      return value.map((item, i) => {\n        const value = this.processFieldValue(\n          item,\n          field,\n          context,\n          getChildMergeTree(mergeTree, i)\n        );\n        maybeRecycleChildMergeTree(mergeTree, i);\n        return value;\n      });\n    }\n\n    return this.processSelectionSet({\n      result: value,\n      selectionSet: field.selectionSet,\n      context,\n      mergeTree,\n    });\n  }\n\n  // Implements https://spec.graphql.org/draft/#sec-Field-Collection, but with\n  // some additions for tracking @client and @defer directives.\n  private flattenFields<\n    TContext extends Pick<\n      WriteContext,\n      | \"clientOnly\"\n      | \"deferred\"\n      | \"flavors\"\n      | \"fragmentMap\"\n      | \"lookupFragment\"\n      | \"variables\"\n    >,\n  >(\n    selectionSet: SelectionSetNode,\n    result: Record<string, any>,\n    context: TContext,\n    typename = getTypenameFromResult(result, selectionSet, context.fragmentMap)\n  ): Map<FieldNode, TContext> {\n    const fieldMap = new Map<FieldNode, TContext>();\n    const { policies } = this.cache;\n\n    const limitingTrie = new Trie<{\n      // Tracks whether (selectionSet, clientOnly, deferred) has been flattened\n      // before. The GraphQL specification only uses the fragment name for\n      // skipping previously visited fragments, but the top-level fragment\n      // selection set corresponds 1:1 with the fagment name (and is slightly\n      // easier too work with), and we need to consider clientOnly and deferred\n      // values as well, potentially revisiting selection sets that were\n      // previously visited with different inherited configurations of those\n      // directives.\n      visited?: boolean;\n    }>(false); // No need for WeakMap, since limitingTrie does not escape.\n\n    (function flatten(\n      this: void,\n      selectionSet: SelectionSetNode,\n      inheritedContext: TContext\n    ) {\n      const visitedNode = limitingTrie.lookup(\n        selectionSet,\n        // Because we take inheritedClientOnly and inheritedDeferred into\n        // consideration here (in addition to selectionSet), it's possible for\n        // the same selection set to be flattened more than once, if it appears\n        // in the query with different @client and/or @directive configurations.\n        inheritedContext.clientOnly,\n        inheritedContext.deferred\n      );\n      if (visitedNode.visited) return;\n      visitedNode.visited = true;\n\n      selectionSet.selections.forEach((selection) => {\n        if (!shouldInclude(selection, context.variables)) return;\n\n        let { clientOnly, deferred } = inheritedContext;\n        if (\n          // Since the presence of @client or @defer on this field can only\n          // cause clientOnly or deferred to become true, we can skip the\n          // forEach loop if both clientOnly and deferred are already true.\n          !(clientOnly && deferred) &&\n          isNonEmptyArray(selection.directives)\n        ) {\n          selection.directives.forEach((dir) => {\n            const name = dir.name.value;\n            if (name === \"client\") clientOnly = true;\n            if (name === \"defer\") {\n              const args = argumentsObjectFromField(dir, context.variables);\n              // The @defer directive takes an optional args.if boolean\n              // argument, similar to @include(if: boolean). Note that\n              // @defer(if: false) does not make context.deferred false, but\n              // instead behaves as if there was no @defer directive.\n              if (!args || (args as { if?: boolean }).if !== false) {\n                deferred = true;\n              }\n              // TODO In the future, we may want to record args.label using\n              // context.deferred, if a label is specified.\n            }\n          });\n        }\n\n        if (isField(selection)) {\n          const existing = fieldMap.get(selection);\n          if (existing) {\n            // If this field has been visited along another recursive path\n            // before, the final context should have clientOnly or deferred set\n            // to true only if *all* paths have the directive (hence the &&).\n            clientOnly = clientOnly && existing.clientOnly;\n            deferred = deferred && existing.deferred;\n          }\n\n          fieldMap.set(\n            selection,\n            getContextFlavor(context, clientOnly, deferred)\n          );\n        } else {\n          const fragment = getFragmentFromSelection(\n            selection,\n            context.lookupFragment\n          );\n\n          if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n            throw newInvariantError(\n              `No fragment named %s`,\n              selection.name.value\n            );\n          }\n\n          if (\n            fragment &&\n            policies.fragmentMatches(\n              fragment,\n              typename,\n              result,\n              context.variables\n            )\n          ) {\n            flatten(\n              fragment.selectionSet,\n              getContextFlavor(context, clientOnly, deferred)\n            );\n          }\n        }\n      });\n    })(selectionSet, context);\n\n    return fieldMap;\n  }\n\n  private applyMerges<T extends StoreValue>(\n    mergeTree: MergeTree,\n    existing: StoreValue,\n    incoming: T,\n    context: WriteContext,\n    getStorageArgs?: Parameters<EntityStore[\"getStorage\"]>\n  ): T | Reference {\n    if (mergeTree.map.size && !isReference(incoming)) {\n      const e: StoreObject | Reference | undefined =\n        // Items in the same position in different arrays are not\n        // necessarily related to each other, so when incoming is an array\n        // we process its elements as if there was no existing data.\n        (\n          !isArray(incoming) &&\n          // Likewise, existing must be either a Reference or a StoreObject\n          // in order for its fields to be safe to merge with the fields of\n          // the incoming object.\n          (isReference(existing) || storeValueIsStoreObject(existing))\n        ) ?\n          existing\n        : void 0;\n\n      // This narrowing is implied by mergeTree.map.size > 0 and\n      // !isReference(incoming), though TypeScript understandably cannot\n      // hope to infer this type.\n      const i = incoming as StoreObject | StoreValue[];\n\n      // The options.storage objects provided to read and merge functions\n      // are derived from the identity of the parent object plus a\n      // sequence of storeFieldName strings/numbers identifying the nested\n      // field name path of each field value to be merged.\n      if (e && !getStorageArgs) {\n        getStorageArgs = [isReference(e) ? e.__ref : e];\n      }\n\n      // It's possible that applying merge functions to this subtree will\n      // not change the incoming data, so this variable tracks the fields\n      // that did change, so we can create a new incoming object when (and\n      // only when) at least one incoming field has changed. We use a Map\n      // to preserve the type of numeric keys.\n      let changedFields: Map<string | number, StoreValue> | undefined;\n\n      const getValue = (\n        from: typeof e | typeof i,\n        name: string | number\n      ): StoreValue => {\n        return (\n          isArray(from) ?\n            typeof name === \"number\" ?\n              from[name]\n            : void 0\n          : context.store.getFieldValue(from, String(name))\n        );\n      };\n\n      mergeTree.map.forEach((childTree, storeFieldName) => {\n        const eVal = getValue(e, storeFieldName);\n        const iVal = getValue(i, storeFieldName);\n        // If we have no incoming data, leave any existing data untouched.\n        if (void 0 === iVal) return;\n        if (getStorageArgs) {\n          getStorageArgs.push(storeFieldName);\n        }\n        const aVal = this.applyMerges(\n          childTree,\n          eVal,\n          iVal,\n          context,\n          getStorageArgs\n        );\n        if (aVal !== iVal) {\n          changedFields = changedFields || new Map();\n          changedFields.set(storeFieldName, aVal);\n        }\n        if (getStorageArgs) {\n          invariant(getStorageArgs.pop() === storeFieldName);\n        }\n      });\n\n      if (changedFields) {\n        // Shallow clone i so we can add changed fields to it.\n        incoming = (isArray(i) ? i.slice(0) : { ...i }) as T;\n        changedFields.forEach((value, name) => {\n          (incoming as any)[name] = value;\n        });\n      }\n    }\n\n    if (mergeTree.info) {\n      return this.cache.policies.runMergeFunction(\n        existing,\n        incoming,\n        mergeTree.info,\n        context,\n        getStorageArgs && context.store.getStorage(...getStorageArgs)\n      );\n    }\n\n    return incoming;\n  }\n}\n\nconst emptyMergeTreePool: MergeTree[] = [];\n\nfunction getChildMergeTree(\n  { map }: MergeTree,\n  name: string | number\n): MergeTree {\n  if (!map.has(name)) {\n    map.set(name, emptyMergeTreePool.pop() || { map: new Map() });\n  }\n  return map.get(name)!;\n}\n\nfunction mergeMergeTrees(\n  left: MergeTree | undefined,\n  right: MergeTree | undefined\n): MergeTree {\n  if (left === right || !right || mergeTreeIsEmpty(right)) return left!;\n  if (!left || mergeTreeIsEmpty(left)) return right;\n\n  const info =\n    left.info && right.info ?\n      {\n        ...left.info,\n        ...right.info,\n      }\n    : left.info || right.info;\n\n  const needToMergeMaps = left.map.size && right.map.size;\n  const map =\n    needToMergeMaps ? new Map()\n    : left.map.size ? left.map\n    : right.map;\n\n  const merged = { info, map };\n\n  if (needToMergeMaps) {\n    const remainingRightKeys = new Set(right.map.keys());\n\n    left.map.forEach((leftTree, key) => {\n      merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));\n      remainingRightKeys.delete(key);\n    });\n\n    remainingRightKeys.forEach((key) => {\n      merged.map.set(\n        key,\n        mergeMergeTrees(right.map.get(key), left.map.get(key))\n      );\n    });\n  }\n\n  return merged;\n}\n\nfunction mergeTreeIsEmpty(tree: MergeTree | undefined): boolean {\n  return !tree || !(tree.info || tree.map.size);\n}\n\nfunction maybeRecycleChildMergeTree({ map }: MergeTree, name: string | number) {\n  const childTree = map.get(name);\n  if (childTree && mergeTreeIsEmpty(childTree)) {\n    emptyMergeTreePool.push(childTree);\n    map.delete(name);\n  }\n}\n\nconst warnings = new Set<string>();\n\n// Note that this function is unused in production, and thus should be\n// pruned by any well-configured minifier.\nfunction warnAboutDataLoss(\n  existingRef: Reference,\n  incomingObj: StoreObject,\n  storeFieldName: string,\n  store: NormalizedCache\n) {\n  const getChild = (objOrRef: StoreObject | Reference): StoreObject | false => {\n    const child = store.getFieldValue<StoreObject>(objOrRef, storeFieldName);\n    return typeof child === \"object\" && child;\n  };\n\n  const existing = getChild(existingRef);\n  if (!existing) return;\n\n  const incoming = getChild(incomingObj);\n  if (!incoming) return;\n\n  // It's always safe to replace a reference, since it refers to data\n  // safely stored elsewhere.\n  if (isReference(existing)) return;\n\n  // If the values are structurally equivalent, we do not need to worry\n  // about incoming replacing existing.\n  if (equal(existing, incoming)) return;\n\n  // If we're replacing every key of the existing object, then the\n  // existing data would be overwritten even if the objects were\n  // normalized, so warning would not be helpful here.\n  if (\n    Object.keys(existing).every(\n      (key) => store.getFieldValue(incoming, key) !== void 0\n    )\n  ) {\n    return;\n  }\n\n  const parentType =\n    store.getFieldValue<string>(existingRef, \"__typename\") ||\n    store.getFieldValue<string>(incomingObj, \"__typename\");\n  const fieldName = fieldNameFromStoreName(storeFieldName);\n  const typeDotName = `${parentType}.${fieldName}`;\n  // Avoid warning more than once for the same type and field name.\n  if (warnings.has(typeDotName)) return;\n  warnings.add(typeDotName);\n\n  const childTypenames: string[] = [];\n  // Arrays do not have __typename fields, and always need a custom merge\n  // function, even if their elements are normalized entities.\n  if (!isArray(existing) && !isArray(incoming)) {\n    [existing, incoming].forEach((child) => {\n      const typename = store.getFieldValue(child, \"__typename\");\n      if (typeof typename === \"string\" && !childTypenames.includes(typename)) {\n        childTypenames.push(typename);\n      }\n    });\n  }\n\n  invariant.warn(\n    `Cache data may be lost when replacing the %s field of a %s object.\n\nThis could cause additional (usually avoidable) network requests to fetch data that were otherwise cached.\n\nTo address this problem (which is not a bug in Apollo Client), %sdefine a custom merge function for the %s field, so InMemoryCache can safely merge these objects:\n\n  existing: %o\n  incoming: %o\n\nFor more information about these options, please refer to the documentation:\n\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\n`,\n    fieldName,\n    parentType,\n    childTypenames.length ?\n      \"either ensure all objects of type \" +\n        childTypenames.join(\" and \") +\n        \" have an ID or a custom merge function, or \"\n    : \"\",\n    typeDotName,\n    { ...existing },\n    { ...incoming }\n  );\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\n\n// Make builtins like Map and Set safe to use with non-extensible objects.\nimport \"./fixPolyfills.js\";\n\nimport type {\n  DocumentNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n} from \"graphql\";\nimport type { OptimisticWrapperFunction } from \"optimism\";\nimport { wrap } from \"optimism\";\nimport { equal } from \"@wry/equality\";\n\nimport { ApolloCache } from \"../core/cache.js\";\nimport type { Cache } from \"../core/types/Cache.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport type { StoreObject, Reference } from \"../../utilities/index.js\";\nimport {\n  addTypenameToDocument,\n  isReference,\n  DocumentTransform,\n  canonicalStringify,\n  print,\n  cacheSizes,\n  defaultCacheSizes,\n} from \"../../utilities/index.js\";\nimport type { InMemoryCacheConfig, NormalizedCacheObject } from \"./types.js\";\nimport { StoreReader } from \"./readFromStore.js\";\nimport { StoreWriter } from \"./writeToStore.js\";\nimport { EntityStore, supportsResultCaching } from \"./entityStore.js\";\nimport { makeVar, forgetCache, recallCache } from \"./reactiveVars.js\";\nimport { Policies } from \"./policies.js\";\nimport { hasOwn, normalizeConfig, shouldCanonizeResults } from \"./helpers.js\";\nimport type { OperationVariables } from \"../../core/index.js\";\nimport { getInMemoryCacheMemoryInternals } from \"../../utilities/caching/getMemoryInternals.js\";\n\ntype BroadcastOptions = Pick<\n  Cache.BatchOptions<InMemoryCache>,\n  \"optimistic\" | \"onWatchUpdated\"\n>;\n\nexport class InMemoryCache extends ApolloCache<NormalizedCacheObject> {\n  private data!: EntityStore;\n  private optimisticData!: EntityStore;\n\n  protected config: InMemoryCacheConfig;\n  private watches = new Set<Cache.WatchOptions>();\n  private addTypename: boolean;\n\n  private storeReader!: StoreReader;\n  private storeWriter!: StoreWriter;\n  private addTypenameTransform = new DocumentTransform(addTypenameToDocument);\n\n  private maybeBroadcastWatch!: OptimisticWrapperFunction<\n    [Cache.WatchOptions, BroadcastOptions?],\n    any,\n    [Cache.WatchOptions]\n  >;\n\n  // Override the default value, since InMemoryCache result objects are frozen\n  // in development and expected to remain logically immutable in production.\n  public readonly assumeImmutableResults = true;\n\n  // Dynamically imported code can augment existing typePolicies or\n  // possibleTypes by calling cache.policies.addTypePolicies or\n  // cache.policies.addPossibletypes.\n  public readonly policies: Policies;\n\n  public readonly makeVar = makeVar;\n\n  constructor(config: InMemoryCacheConfig = {}) {\n    super();\n    this.config = normalizeConfig(config);\n    this.addTypename = !!this.config.addTypename;\n\n    this.policies = new Policies({\n      cache: this,\n      dataIdFromObject: this.config.dataIdFromObject,\n      possibleTypes: this.config.possibleTypes,\n      typePolicies: this.config.typePolicies,\n    });\n\n    this.init();\n  }\n\n  private init() {\n    // Passing { resultCaching: false } in the InMemoryCache constructor options\n    // will completely disable dependency tracking, which will improve memory\n    // usage but worsen the performance of repeated reads.\n    const rootStore = (this.data = new EntityStore.Root({\n      policies: this.policies,\n      resultCaching: this.config.resultCaching,\n    }));\n\n    // When no optimistic writes are currently active, cache.optimisticData ===\n    // cache.data, so there are no additional layers on top of the actual data.\n    // When an optimistic update happens, this.optimisticData will become a\n    // linked list of EntityStore Layer objects that terminates with the\n    // original this.data cache object.\n    this.optimisticData = rootStore.stump;\n\n    this.resetResultCache();\n  }\n\n  private resetResultCache(resetResultIdentities?: boolean) {\n    const previousReader = this.storeReader;\n    const { fragments } = this.config;\n\n    // The StoreWriter is mostly stateless and so doesn't really need to be\n    // reset, but it does need to have its writer.storeReader reference updated,\n    // so it's simpler to update this.storeWriter as well.\n    this.storeWriter = new StoreWriter(\n      this,\n      (this.storeReader = new StoreReader({\n        cache: this,\n        addTypename: this.addTypename,\n        resultCacheMaxSize: this.config.resultCacheMaxSize,\n        canonizeResults: shouldCanonizeResults(this.config),\n        canon:\n          resetResultIdentities ? void 0 : (\n            previousReader && previousReader.canon\n          ),\n        fragments,\n      })),\n      fragments\n    );\n\n    this.maybeBroadcastWatch = wrap(\n      (c: Cache.WatchOptions, options?: BroadcastOptions) => {\n        return this.broadcastWatch(c, options);\n      },\n      {\n        max:\n          this.config.resultCacheMaxSize ||\n          cacheSizes[\"inMemoryCache.maybeBroadcastWatch\"] ||\n          defaultCacheSizes[\"inMemoryCache.maybeBroadcastWatch\"],\n        makeCacheKey: (c: Cache.WatchOptions) => {\n          // Return a cache key (thus enabling result caching) only if we're\n          // currently using a data store that can track cache dependencies.\n          const store = c.optimistic ? this.optimisticData : this.data;\n          if (supportsResultCaching(store)) {\n            const { optimistic, id, variables } = c;\n            return store.makeCacheKey(\n              c.query,\n              // Different watches can have the same query, optimistic\n              // status, rootId, and variables, but if their callbacks are\n              // different, the (identical) result needs to be delivered to\n              // each distinct callback. The easiest way to achieve that\n              // separation is to include c.callback in the cache key for\n              // maybeBroadcastWatch calls. See issue #5733.\n              c.callback,\n              canonicalStringify({ optimistic, id, variables })\n            );\n          }\n        },\n      }\n    );\n\n    // Since we have thrown away all the cached functions that depend on the\n    // CacheGroup dependencies maintained by EntityStore, we should also reset\n    // all CacheGroup dependency information.\n    new Set([this.data.group, this.optimisticData.group]).forEach((group) =>\n      group.resetCaching()\n    );\n  }\n\n  public restore(data: NormalizedCacheObject): this {\n    this.init();\n    // Since calling this.init() discards/replaces the entire StoreReader, along\n    // with the result caches it maintains, this.data.replace(data) won't have\n    // to bother deleting the old data.\n    if (data) this.data.replace(data);\n    return this;\n  }\n\n  public extract(optimistic: boolean = false): NormalizedCacheObject {\n    return (optimistic ? this.optimisticData : this.data).extract();\n  }\n\n  public read<T>(options: Cache.ReadOptions): T | null {\n    const {\n      // Since read returns data or null, without any additional metadata\n      // about whether/where there might have been missing fields, the\n      // default behavior cannot be returnPartialData = true (like it is\n      // for the diff method), since defaulting to true would violate the\n      // integrity of the T in the return type. However, partial data may\n      // be useful in some cases, so returnPartialData:true may be\n      // specified explicitly.\n      returnPartialData = false,\n    } = options;\n    try {\n      return (\n        this.storeReader.diffQueryAgainstStore<T>({\n          ...options,\n          store: options.optimistic ? this.optimisticData : this.data,\n          config: this.config,\n          returnPartialData,\n        }).result || null\n      );\n    } catch (e) {\n      if (e instanceof MissingFieldError) {\n        // Swallow MissingFieldError and return null, so callers do not need to\n        // worry about catching \"normal\" exceptions resulting from incomplete\n        // cache data. Unexpected errors will be re-thrown. If you need more\n        // information about which fields were missing, use cache.diff instead,\n        // and examine diffResult.missing.\n        return null;\n      }\n      throw e;\n    }\n  }\n\n  public write(options: Cache.WriteOptions): Reference | undefined {\n    try {\n      ++this.txCount;\n      return this.storeWriter.writeToStore(this.data, options);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public modify<Entity extends Record<string, any> = Record<string, any>>(\n    options: Cache.ModifyOptions<Entity>\n  ): boolean {\n    if (hasOwn.call(options, \"id\") && !options.id) {\n      // To my knowledge, TypeScript does not currently provide a way to\n      // enforce that an optional property?:type must *not* be undefined\n      // when present. That ability would be useful here, because we want\n      // options.id to default to ROOT_QUERY only when no options.id was\n      // provided. If the caller attempts to pass options.id with a\n      // falsy/undefined value (perhaps because cache.identify failed), we\n      // should not assume the goal was to modify the ROOT_QUERY object.\n      // We could throw, but it seems natural to return false to indicate\n      // that nothing was modified.\n      return false;\n    }\n    const store =\n      (\n        options.optimistic // Defaults to false.\n      ) ?\n        this.optimisticData\n      : this.data;\n    try {\n      ++this.txCount;\n      return store.modify(options.id || \"ROOT_QUERY\", options.fields);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public diff<TData, TVariables extends OperationVariables = any>(\n    options: Cache.DiffOptions<TData, TVariables>\n  ): Cache.DiffResult<TData> {\n    return this.storeReader.diffQueryAgainstStore({\n      ...options,\n      store: options.optimistic ? this.optimisticData : this.data,\n      rootId: options.id || \"ROOT_QUERY\",\n      config: this.config,\n    });\n  }\n\n  public watch<TData = any, TVariables = any>(\n    watch: Cache.WatchOptions<TData, TVariables>\n  ): () => void {\n    if (!this.watches.size) {\n      // In case we previously called forgetCache(this) because\n      // this.watches became empty (see below), reattach this cache to any\n      // reactive variables on which it previously depended. It might seem\n      // paradoxical that we're able to recall something we supposedly\n      // forgot, but the point of calling forgetCache(this) is to silence\n      // useless broadcasts while this.watches is empty, and to allow the\n      // cache to be garbage collected. If, however, we manage to call\n      // recallCache(this) here, this cache object must not have been\n      // garbage collected yet, and should resume receiving updates from\n      // reactive variables, now that it has a watcher to notify.\n      recallCache(this);\n    }\n    this.watches.add(watch);\n    if (watch.immediate) {\n      this.maybeBroadcastWatch(watch);\n    }\n    return () => {\n      // Once we remove the last watch from this.watches, cache.broadcastWatches\n      // no longer does anything, so we preemptively tell the reactive variable\n      // system to exclude this cache from future broadcasts.\n      if (this.watches.delete(watch) && !this.watches.size) {\n        forgetCache(this);\n      }\n      // Remove this watch from the LRU cache managed by the\n      // maybeBroadcastWatch OptimisticWrapperFunction, to prevent memory\n      // leaks involving the closure of watch.callback.\n      this.maybeBroadcastWatch.forget(watch);\n    };\n  }\n\n  public gc(options?: {\n    // If true, also free non-essential result cache memory by bulk-releasing\n    // this.{store{Reader,Writer},maybeBroadcastWatch}. Defaults to false.\n    resetResultCache?: boolean;\n    // If resetResultCache is true, this.storeReader.canon will be preserved by\n    // default, but can also be discarded by passing resetResultIdentities:true.\n    // Defaults to false.\n    resetResultIdentities?: boolean;\n  }) {\n    canonicalStringify.reset();\n    print.reset();\n    this.addTypenameTransform.resetCache();\n    this.config.fragments?.resetCaches();\n    const ids = this.optimisticData.gc();\n    if (options && !this.txCount) {\n      if (options.resetResultCache) {\n        this.resetResultCache(options.resetResultIdentities);\n      } else if (options.resetResultIdentities) {\n        this.storeReader.resetCanon();\n      }\n    }\n    return ids;\n  }\n\n  // Call this method to ensure the given root ID remains in the cache after\n  // garbage collection, along with its transitive child entities. Note that\n  // the cache automatically retains all directly written entities. By default,\n  // the retainment persists after optimistic updates are removed. Pass true\n  // for the optimistic argument if you would prefer for the retainment to be\n  // discarded when the top-most optimistic layer is removed. Returns the\n  // resulting (non-negative) retainment count.\n  public retain(rootId: string, optimistic?: boolean): number {\n    return (optimistic ? this.optimisticData : this.data).retain(rootId);\n  }\n\n  // Call this method to undo the effect of the retain method, above. Once the\n  // retainment count falls to zero, the given ID will no longer be preserved\n  // during garbage collection, though it may still be preserved by other safe\n  // entities that refer to it. Returns the resulting (non-negative) retainment\n  // count, in case that's useful.\n  public release(rootId: string, optimistic?: boolean): number {\n    return (optimistic ? this.optimisticData : this.data).release(rootId);\n  }\n\n  // Returns the canonical ID for a given StoreObject, obeying typePolicies\n  // and keyFields (and dataIdFromObject, if you still use that). At minimum,\n  // the object must contain a __typename and any primary key fields required\n  // to identify entities of that type. If you pass a query result object, be\n  // sure that none of the primary key fields have been renamed by aliasing.\n  // If you pass a Reference object, its __ref ID string will be returned.\n  public identify(object: StoreObject | Reference): string | undefined {\n    if (isReference(object)) return object.__ref;\n    try {\n      return this.policies.identify(object)[0];\n    } catch (e) {\n      invariant.warn(e);\n    }\n  }\n\n  public evict(options: Cache.EvictOptions): boolean {\n    if (!options.id) {\n      if (hasOwn.call(options, \"id\")) {\n        // See comment in modify method about why we return false when\n        // options.id exists but is falsy/undefined.\n        return false;\n      }\n      options = { ...options, id: \"ROOT_QUERY\" };\n    }\n    try {\n      // It's unlikely that the eviction will end up invoking any other\n      // cache update operations while it's running, but {in,de}crementing\n      // this.txCount still seems like a good idea, for uniformity with\n      // the other update methods.\n      ++this.txCount;\n      // Pass this.data as a limit on the depth of the eviction, so evictions\n      // during optimistic updates (when this.data is temporarily set equal to\n      // this.optimisticData) do not escape their optimistic Layer.\n      return this.optimisticData.evict(options, this.data);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public reset(options?: Cache.ResetOptions): Promise<void> {\n    this.init();\n\n    canonicalStringify.reset();\n\n    if (options && options.discardWatches) {\n      // Similar to what happens in the unsubscribe function returned by\n      // cache.watch, applied to all current watches.\n      this.watches.forEach((watch) => this.maybeBroadcastWatch.forget(watch));\n      this.watches.clear();\n      forgetCache(this);\n    } else {\n      // Calling this.init() above unblocks all maybeBroadcastWatch caching, so\n      // this.broadcastWatches() triggers a broadcast to every current watcher\n      // (letting them know their data is now missing). This default behavior is\n      // convenient because it means the watches do not have to be manually\n      // reestablished after resetting the cache. To prevent this broadcast and\n      // cancel all watches, pass true for options.discardWatches.\n      this.broadcastWatches();\n    }\n\n    return Promise.resolve();\n  }\n\n  public removeOptimistic(idToRemove: string) {\n    const newOptimisticData = this.optimisticData.removeLayer(idToRemove);\n    if (newOptimisticData !== this.optimisticData) {\n      this.optimisticData = newOptimisticData;\n      this.broadcastWatches();\n    }\n  }\n\n  private txCount = 0;\n\n  public batch<TUpdateResult>(\n    options: Cache.BatchOptions<InMemoryCache, TUpdateResult>\n  ): TUpdateResult {\n    const {\n      update,\n      optimistic = true,\n      removeOptimistic,\n      onWatchUpdated,\n    } = options;\n\n    let updateResult: TUpdateResult;\n    const perform = (layer?: EntityStore): TUpdateResult => {\n      const { data, optimisticData } = this;\n      ++this.txCount;\n      if (layer) {\n        this.data = this.optimisticData = layer;\n      }\n      try {\n        return (updateResult = update(this));\n      } finally {\n        --this.txCount;\n        this.data = data;\n        this.optimisticData = optimisticData;\n      }\n    };\n\n    const alreadyDirty = new Set<Cache.WatchOptions>();\n\n    if (onWatchUpdated && !this.txCount) {\n      // If an options.onWatchUpdated callback is provided, we want to call it\n      // with only the Cache.WatchOptions objects affected by options.update,\n      // but there might be dirty watchers already waiting to be broadcast that\n      // have nothing to do with the update. To prevent including those watchers\n      // in the post-update broadcast, we perform this initial broadcast to\n      // collect the dirty watchers, so we can re-dirty them later, after the\n      // post-update broadcast, allowing them to receive their pending\n      // broadcasts the next time broadcastWatches is called, just as they would\n      // if we never called cache.batch.\n      this.broadcastWatches({\n        ...options,\n        onWatchUpdated(watch) {\n          alreadyDirty.add(watch);\n          return false;\n        },\n      });\n    }\n\n    if (typeof optimistic === \"string\") {\n      // Note that there can be multiple layers with the same optimistic ID.\n      // When removeOptimistic(id) is called for that id, all matching layers\n      // will be removed, and the remaining layers will be reapplied.\n      this.optimisticData = this.optimisticData.addLayer(optimistic, perform);\n    } else if (optimistic === false) {\n      // Ensure both this.data and this.optimisticData refer to the root\n      // (non-optimistic) layer of the cache during the update. Note that\n      // this.data could be a Layer if we are currently executing an optimistic\n      // update function, but otherwise will always be an EntityStore.Root\n      // instance.\n      perform(this.data);\n    } else {\n      // Otherwise, leave this.data and this.optimisticData unchanged and run\n      // the update with broadcast batching.\n      perform();\n    }\n\n    if (typeof removeOptimistic === \"string\") {\n      this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);\n    }\n\n    // Note: if this.txCount > 0, then alreadyDirty.size === 0, so this code\n    // takes the else branch and calls this.broadcastWatches(options), which\n    // does nothing when this.txCount > 0.\n    if (onWatchUpdated && alreadyDirty.size) {\n      this.broadcastWatches({\n        ...options,\n        onWatchUpdated(watch, diff) {\n          const result = onWatchUpdated.call(this, watch, diff);\n          if (result !== false) {\n            // Since onWatchUpdated did not return false, this diff is\n            // about to be broadcast to watch.callback, so we don't need\n            // to re-dirty it with the other alreadyDirty watches below.\n            alreadyDirty.delete(watch);\n          }\n          return result;\n        },\n      });\n      // Silently re-dirty any watches that were already dirty before the update\n      // was performed, and were not broadcast just now.\n      if (alreadyDirty.size) {\n        alreadyDirty.forEach((watch) => this.maybeBroadcastWatch.dirty(watch));\n      }\n    } else {\n      // If alreadyDirty is empty or we don't have an onWatchUpdated\n      // function, we don't need to go to the trouble of wrapping\n      // options.onWatchUpdated.\n      this.broadcastWatches(options);\n    }\n\n    return updateResult!;\n  }\n\n  public performTransaction(\n    update: (cache: InMemoryCache) => any,\n    optimisticId?: string | null\n  ) {\n    return this.batch({\n      update,\n      optimistic: optimisticId || optimisticId !== null,\n    });\n  }\n\n  public transformDocument(document: DocumentNode): DocumentNode {\n    return this.addTypenameToDocument(this.addFragmentsToDocument(document));\n  }\n\n  public fragmentMatches(\n    fragment: InlineFragmentNode,\n    typename: string\n  ): boolean {\n    return this.policies.fragmentMatches(fragment, typename);\n  }\n\n  public lookupFragment(fragmentName: string): FragmentDefinitionNode | null {\n    return this.config.fragments?.lookup(fragmentName) || null;\n  }\n\n  protected broadcastWatches(options?: BroadcastOptions) {\n    if (!this.txCount) {\n      this.watches.forEach((c) => this.maybeBroadcastWatch(c, options));\n    }\n  }\n\n  private addFragmentsToDocument(document: DocumentNode) {\n    const { fragments } = this.config;\n    return fragments ? fragments.transform(document) : document;\n  }\n\n  private addTypenameToDocument(document: DocumentNode) {\n    if (this.addTypename) {\n      return this.addTypenameTransform.transformDocument(document);\n    }\n    return document;\n  }\n\n  // This method is wrapped by maybeBroadcastWatch, which is called by\n  // broadcastWatches, so that we compute and broadcast results only when\n  // the data that would be broadcast might have changed. It would be\n  // simpler to check for changes after recomputing a result but before\n  // broadcasting it, but this wrapping approach allows us to skip both\n  // the recomputation and the broadcast, in most cases.\n  private broadcastWatch(c: Cache.WatchOptions, options?: BroadcastOptions) {\n    const { lastDiff } = c;\n\n    // Both WatchOptions and DiffOptions extend ReadOptions, and DiffOptions\n    // currently requires no additional properties, so we can use c (a\n    // WatchOptions object) as DiffOptions, without having to allocate a new\n    // object, and without having to enumerate the relevant properties (query,\n    // variables, etc.) explicitly. There will be some additional properties\n    // (lastDiff, callback, etc.), but cache.diff ignores them.\n    const diff = this.diff<any>(c);\n\n    if (options) {\n      if (c.optimistic && typeof options.optimistic === \"string\") {\n        diff.fromOptimisticTransaction = true;\n      }\n\n      if (\n        options.onWatchUpdated &&\n        options.onWatchUpdated.call(this, c, diff, lastDiff) === false\n      ) {\n        // Returning false from the onWatchUpdated callback will prevent\n        // calling c.callback(diff) for this watcher.\n        return;\n      }\n    }\n\n    if (!lastDiff || !equal(lastDiff.result, diff.result)) {\n      c.callback((c.lastDiff = diff), lastDiff);\n    }\n  }\n\n  /**\n   * @experimental\n   * @internal\n   * This is not a stable API - it is used in development builds to expose\n   * information to the DevTools.\n   * Use at your own risk!\n   */\n  public getMemoryInternals?: typeof getInMemoryCacheMemoryInternals;\n}\n\nif (__DEV__) {\n  InMemoryCache.prototype.getMemoryInternals = getInMemoryCacheMemoryInternals;\n}\n", "import type {\n  DocumentNode,\n  ASTNode,\n  FragmentDefinitionNode,\n  FragmentSpreadNode,\n} from \"graphql\";\nimport { visit } from \"graphql\";\n\nimport { wrap } from \"optimism\";\n\nimport type { FragmentMap } from \"../../utilities/index.js\";\nimport {\n  cacheSizes,\n  defaultCacheSizes,\n  getFragmentDefinitions,\n} from \"../../utilities/index.js\";\nimport { WeakCache } from \"@wry/caches\";\n\nexport interface FragmentRegistryAPI {\n  register(...fragments: DocumentNode[]): this;\n  lookup(fragmentName: string): FragmentDefinitionNode | null;\n  transform<D extends DocumentNode>(document: D): D;\n  resetCaches(): void;\n}\n\n// As long as createFragmentRegistry is not imported or used, the\n// FragmentRegistry example implementation provided below should not be bundled\n// (by tree-shaking bundlers like Rollup), because the implementation of\n// InMemoryCache refers only to the TypeScript interface FragmentRegistryAPI,\n// never the concrete implementation FragmentRegistry (which is deliberately not\n// exported from this module).\nexport function createFragmentRegistry(\n  ...fragments: DocumentNode[]\n): FragmentRegistryAPI {\n  return new FragmentRegistry(...fragments);\n}\n\nclass FragmentRegistry implements FragmentRegistryAPI {\n  private registry: FragmentMap = Object.create(null);\n\n  // Call `createFragmentRegistry` instead of invoking the\n  // FragmentRegistry constructor directly. This reserves the constructor for\n  // future configuration of the FragmentRegistry.\n  constructor(...fragments: DocumentNode[]) {\n    this.resetCaches();\n    if (fragments.length) {\n      this.register(...fragments);\n    }\n  }\n\n  public register(...fragments: DocumentNode[]): this {\n    const definitions = new Map<string, FragmentDefinitionNode>();\n    fragments.forEach((doc: DocumentNode) => {\n      getFragmentDefinitions(doc).forEach((node) => {\n        definitions.set(node.name.value, node);\n      });\n    });\n\n    definitions.forEach((node, name) => {\n      if (node !== this.registry[name]) {\n        this.registry[name] = node;\n        this.invalidate(name);\n      }\n    });\n\n    return this;\n  }\n\n  // Overridden in the resetCaches method below.\n  private invalidate(name: string) {}\n\n  public resetCaches() {\n    const proto = FragmentRegistry.prototype;\n    this.invalidate = (this.lookup = wrap(proto.lookup.bind(this), {\n      makeCacheKey: (arg) => arg,\n      max:\n        cacheSizes[\"fragmentRegistry.lookup\"] ||\n        defaultCacheSizes[\"fragmentRegistry.lookup\"],\n    })).dirty; // This dirty function is bound to the wrapped lookup method.\n    this.transform = wrap(proto.transform.bind(this), {\n      cache: WeakCache,\n      max:\n        cacheSizes[\"fragmentRegistry.transform\"] ||\n        defaultCacheSizes[\"fragmentRegistry.transform\"],\n    });\n    this.findFragmentSpreads = wrap(proto.findFragmentSpreads.bind(this), {\n      cache: WeakCache,\n      max:\n        cacheSizes[\"fragmentRegistry.findFragmentSpreads\"] ||\n        defaultCacheSizes[\"fragmentRegistry.findFragmentSpreads\"],\n    });\n  }\n\n  /*\n   * Note:\n   * This method is only memoized so it can serve as a dependency to `tranform`,\n   * so calling `invalidate` will invalidate cache entries for `transform`.\n   */\n  public lookup(fragmentName: string): FragmentDefinitionNode | null {\n    return this.registry[fragmentName] || null;\n  }\n\n  public transform<D extends DocumentNode>(document: D): D {\n    const defined = new Map<string, FragmentDefinitionNode>();\n    getFragmentDefinitions(document).forEach((def) => {\n      defined.set(def.name.value, def);\n    });\n\n    const unbound = new Set<string>();\n    const enqueue = (spreadName: string) => {\n      if (!defined.has(spreadName)) {\n        unbound.add(spreadName);\n      }\n    };\n\n    const enqueueChildSpreads = (node: ASTNode) =>\n      Object.keys(this.findFragmentSpreads(node)).forEach(enqueue);\n\n    enqueueChildSpreads(document);\n\n    const missing: string[] = [];\n    const map: FragmentMap = Object.create(null);\n\n    // This Set forEach loop can be extended during iteration by adding\n    // additional strings to the unbound set.\n    unbound.forEach((fragmentName) => {\n      const knownFragmentDef = defined.get(fragmentName);\n      if (knownFragmentDef) {\n        enqueueChildSpreads((map[fragmentName] = knownFragmentDef));\n      } else {\n        missing.push(fragmentName);\n        const def = this.lookup(fragmentName);\n        if (def) {\n          enqueueChildSpreads((map[fragmentName] = def));\n        }\n      }\n    });\n\n    if (missing.length) {\n      const defsToAppend: FragmentDefinitionNode[] = [];\n      missing.forEach((name) => {\n        const def = map[name];\n        if (def) {\n          defsToAppend.push(def);\n        }\n      });\n\n      if (defsToAppend.length) {\n        document = {\n          ...document,\n          definitions: document.definitions.concat(defsToAppend),\n        };\n      }\n    }\n\n    return document;\n  }\n\n  public findFragmentSpreads(root: ASTNode): FragmentSpreadMap {\n    const spreads: FragmentSpreadMap = Object.create(null);\n\n    visit(root, {\n      FragmentSpread(node) {\n        spreads[node.name.value] = node;\n      },\n    });\n\n    return spreads;\n  }\n}\n\ninterface FragmentSpreadMap {\n  [fragmentSpreadName: string]: FragmentSpreadNode;\n}\n", "import \"../utilities/globals/index.js\";\n\nexport type {\n  Transaction,\n  WatchFragmentOptions,\n  WatchFragmentResult,\n} from \"./core/cache.js\";\nexport { ApolloCache } from \"./core/cache.js\";\nexport { Cache } from \"./core/types/Cache.js\";\nexport type { DataProxy } from \"./core/types/DataProxy.js\";\nexport type {\n  MissingTree,\n  Modifier,\n  Modifiers,\n  ModifierDetails,\n  ReadFieldOptions,\n} from \"./core/types/common.js\";\nexport { MissingFieldError } from \"./core/types/common.js\";\n\nexport type { Reference } from \"../utilities/index.js\";\nexport {\n  isReference,\n  makeReference,\n  canonicalStringify,\n} from \"../utilities/index.js\";\n\nexport { EntityStore } from \"./inmemory/entityStore.js\";\nexport {\n  fieldNameFromStoreName,\n  defaultDataIdFromObject,\n} from \"./inmemory/helpers.js\";\n\nexport { InMemoryCache } from \"./inmemory/inMemoryCache.js\";\n\nexport type { ReactiveVar } from \"./inmemory/reactiveVars.js\";\nexport { makeVar, cacheSlot } from \"./inmemory/reactiveVars.js\";\n\nexport type {\n  TypePolicies,\n  TypePolicy,\n  FieldPolicy,\n  FieldReadFunction,\n  FieldMergeFunction,\n  FieldFunctionOptions,\n  PossibleTypesMap,\n} from \"./inmemory/policies.js\";\nexport { Policies } from \"./inmemory/policies.js\";\n\nexport type { FragmentRegistryAPI } from \"./inmemory/fragmentRegistry.js\";\nexport { createFragmentRegistry } from \"./inmemory/fragmentRegistry.js\";\n\nexport type * from \"./inmemory/types.js\";\n", "/**\n * The current status of a query’s execution in our system.\n */\nexport enum NetworkStatus {\n  /**\n   * The query has never been run before and the query is now currently running. A query will still\n   * have this network status even if a partial data result was returned from the cache, but a\n   * query was dispatched anyway.\n   */\n  loading = 1,\n\n  /**\n   * If `setVariables` was called and a query was fired because of that then the network status\n   * will be `setVariables` until the result of that query comes back.\n   */\n  setVariables = 2,\n\n  /**\n   * Indicates that `fetchMore` was called on this query and that the query created is currently in\n   * flight.\n   */\n  fetchMore = 3,\n\n  /**\n   * Similar to the `setVariables` network status. It means that `refetch` was called on a query\n   * and the refetch request is currently in flight.\n   */\n  refetch = 4,\n\n  /**\n   * Indicates that a polling query is currently in flight. So for example if you are polling a\n   * query every 10 seconds then the network status will switch to `poll` every 10 seconds whenever\n   * a poll request has been sent but not resolved.\n   */\n  poll = 6,\n\n  /**\n   * No request is in flight for this query, and no errors happened. Everything is OK.\n   */\n  ready = 7,\n\n  /**\n   * No request is in flight for this query, but one or more errors were detected.\n   */\n  error = 8,\n}\n\n/**\n * Returns true if there is currently a network request in flight according to a given network\n * status.\n */\nexport function isNetworkRequestInFlight(\n  networkStatus?: NetworkStatus\n): boolean {\n  return networkStatus ? networkStatus < 7 : false;\n}\n\n/**\n * Returns true if the network request is in ready or error state according to a given network\n * status.\n */\nexport function isNetworkRequestSettled(\n  networkStatus?: NetworkStatus\n): boolean {\n  return networkStatus === 7 || networkStatus === 8;\n}\n", "import { invariant } from \"../utilities/globals/index.js\";\nimport type { DocumentNode } from \"graphql\";\nimport { equal } from \"@wry/equality\";\n\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport type {\n  Concast,\n  Observer,\n  ObservableSubscription,\n} from \"../utilities/index.js\";\nimport {\n  cloneDeep,\n  compact,\n  getOperationDefinition,\n  Observable,\n  iterateObserversSafely,\n  fixObservableSubclass,\n  getQueryDefinition,\n  preventUnhandledRejection,\n} from \"../utilities/index.js\";\nimport { ApolloError, isApolloError } from \"../errors/index.js\";\nimport type { QueryManager } from \"./QueryManager.js\";\nimport type {\n  ApolloQueryResult,\n  OperationVariables,\n  TypedDocumentNode,\n} from \"./types.js\";\nimport type {\n  WatchQueryOptions,\n  FetchMoreQueryOptions,\n  SubscribeToMoreOptions,\n  NextFetchPolicyContext,\n  WatchQueryFetchPolicy,\n  UpdateQueryMapFn,\n  UpdateQueryOptions,\n} from \"./watchQueryOptions.js\";\nimport type { QueryInfo } from \"./QueryInfo.js\";\nimport type { MissingFieldError } from \"../cache/index.js\";\nimport type { MissingTree } from \"../cache/core/types/common.js\";\nimport { equalByQuery } from \"./equalByQuery.js\";\nimport type { TODO } from \"../utilities/types/TODO.js\";\nimport type { MaybeMasked, Unmasked } from \"../masking/index.js\";\n\nconst { assign, hasOwnProperty } = Object;\n\nexport interface FetchMoreOptions<\n  TData = any,\n  TVariables = OperationVariables,\n> {\n  updateQuery?: (\n    previousQueryResult: TData,\n    options: {\n      fetchMoreResult?: TData;\n      variables?: TVariables;\n    }\n  ) => TData;\n}\n\ninterface Last<TData, TVariables> {\n  result: ApolloQueryResult<TData>;\n  variables?: TVariables;\n  error?: ApolloError;\n}\n\nexport class ObservableQuery<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n> extends Observable<ApolloQueryResult<MaybeMasked<TData>>> {\n  public readonly options: WatchQueryOptions<TVariables, TData>;\n  public readonly queryId: string;\n  public readonly queryName?: string;\n\n  // The `query` computed property will always reflect the document transformed\n  // by the last run query. `this.options.query` will always reflect the raw\n  // untransformed query to ensure document transforms with runtime conditionals\n  // are run on the original document.\n  public get query(): TypedDocumentNode<TData, TVariables> {\n    return this.lastQuery || this.options.query;\n  }\n\n  // Computed shorthand for this.options.variables, preserved for\n  // backwards compatibility.\n  /**\n   * An object containing the variables that were provided for the query.\n   */\n  public get variables(): TVariables | undefined {\n    return this.options.variables;\n  }\n\n  private isTornDown: boolean;\n  private queryManager: QueryManager<any>;\n  private observers = new Set<\n    Observer<ApolloQueryResult<MaybeMasked<TData>>>\n  >();\n  private subscriptions = new Set<ObservableSubscription>();\n\n  private waitForOwnResult: boolean;\n  private last?: Last<TData, TVariables>;\n  private lastQuery?: DocumentNode;\n\n  private queryInfo: QueryInfo;\n\n  // When this.concast is defined, this.observer is the Observer currently\n  // subscribed to that Concast.\n  private concast?: Concast<ApolloQueryResult<TData>>;\n  private observer?: Observer<ApolloQueryResult<TData>>;\n\n  private pollingInfo?: {\n    interval: number;\n    timeout: ReturnType<typeof setTimeout>;\n  };\n\n  constructor({\n    queryManager,\n    queryInfo,\n    options,\n  }: {\n    queryManager: QueryManager<any>;\n    queryInfo: QueryInfo;\n    options: WatchQueryOptions<TVariables, TData>;\n  }) {\n    super((observer: Observer<ApolloQueryResult<MaybeMasked<TData>>>) => {\n      // Zen Observable has its own error function, so in order to log correctly\n      // we need to provide a custom error callback.\n      try {\n        var subObserver = (observer as any)._subscription._observer;\n        if (subObserver && !subObserver.error) {\n          subObserver.error = defaultSubscriptionObserverErrorCallback;\n        }\n      } catch {}\n\n      const first = !this.observers.size;\n      this.observers.add(observer);\n\n      // Deliver most recent error or result.\n      const last = this.last;\n      if (last && last.error) {\n        observer.error && observer.error(last.error);\n      } else if (last && last.result) {\n        observer.next && observer.next(this.maskResult(last.result));\n      }\n\n      // Initiate observation of this query if it hasn't been reported to\n      // the QueryManager yet.\n      if (first) {\n        // Blindly catching here prevents unhandled promise rejections,\n        // and is safe because the ObservableQuery handles this error with\n        // this.observer.error, so we're not just swallowing the error by\n        // ignoring it here.\n        this.reobserve().catch(() => {});\n      }\n\n      return () => {\n        if (this.observers.delete(observer) && !this.observers.size) {\n          this.tearDownQuery();\n        }\n      };\n    });\n\n    // related classes\n    this.queryInfo = queryInfo;\n    this.queryManager = queryManager;\n\n    // active state\n    this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy);\n    this.isTornDown = false;\n\n    this.subscribeToMore = this.subscribeToMore.bind(this);\n    this.maskResult = this.maskResult.bind(this);\n\n    const {\n      watchQuery: { fetchPolicy: defaultFetchPolicy = \"cache-first\" } = {},\n    } = queryManager.defaultOptions;\n\n    const {\n      fetchPolicy = defaultFetchPolicy,\n      // Make sure we don't store \"standby\" as the initialFetchPolicy.\n      initialFetchPolicy = fetchPolicy === \"standby\" ? defaultFetchPolicy : (\n        fetchPolicy\n      ),\n    } = options;\n\n    this.options = {\n      ...options,\n\n      // Remember the initial options.fetchPolicy so we can revert back to this\n      // policy when variables change. This information can also be specified\n      // (or overridden) by providing options.initialFetchPolicy explicitly.\n      initialFetchPolicy,\n\n      // This ensures this.options.fetchPolicy always has a string value, in\n      // case options.fetchPolicy was not provided.\n      fetchPolicy,\n    };\n\n    this.queryId = queryInfo.queryId || queryManager.generateQueryId();\n\n    const opDef = getOperationDefinition(this.query);\n    this.queryName = opDef && opDef.name && opDef.name.value;\n  }\n\n  public result(): Promise<ApolloQueryResult<MaybeMasked<TData>>> {\n    return new Promise((resolve, reject) => {\n      // TODO: this code doesn’t actually make sense insofar as the observer\n      // will never exist in this.observers due how zen-observable wraps observables.\n      // https://github.com/zenparsing/zen-observable/blob/master/src/Observable.js#L169\n      const observer: Observer<ApolloQueryResult<MaybeMasked<TData>>> = {\n        next: (result) => {\n          resolve(result);\n\n          // Stop the query within the QueryManager if we can before\n          // this function returns.\n          //\n          // We do this in order to prevent observers piling up within\n          // the QueryManager. Notice that we only fully unsubscribe\n          // from the subscription in a setTimeout(..., 0)  call. This call can\n          // actually be handled by the browser at a much later time. If queries\n          // are fired in the meantime, observers that should have been removed\n          // from the QueryManager will continue to fire, causing an unnecessary\n          // performance hit.\n          this.observers.delete(observer);\n          if (!this.observers.size) {\n            this.queryManager.removeQuery(this.queryId);\n          }\n\n          setTimeout(() => {\n            subscription.unsubscribe();\n          }, 0);\n        },\n        error: reject,\n      };\n      const subscription = this.subscribe(observer);\n    });\n  }\n\n  /** @internal */\n  public resetDiff() {\n    this.queryInfo.resetDiff();\n  }\n\n  private getCurrentFullResult(\n    saveAsLastResult = true\n  ): ApolloQueryResult<TData> {\n    // Use the last result as long as the variables match this.variables.\n    const lastResult = this.getLastResult(true);\n\n    const networkStatus =\n      this.queryInfo.networkStatus ||\n      (lastResult && lastResult.networkStatus) ||\n      NetworkStatus.ready;\n\n    const result = {\n      ...lastResult,\n      loading: isNetworkRequestInFlight(networkStatus),\n      networkStatus,\n    } as ApolloQueryResult<TData>;\n\n    const { fetchPolicy = \"cache-first\" } = this.options;\n    if (\n      // These fetch policies should never deliver data from the cache, unless\n      // redelivering a previously delivered result.\n      skipCacheDataFor(fetchPolicy) ||\n      // If this.options.query has @client(always: true) fields, we cannot\n      // trust diff.result, since it was read from the cache without running\n      // local resolvers (and it's too late to run resolvers now, since we must\n      // return a result synchronously).\n      this.queryManager.getDocumentInfo(this.query).hasForcedResolvers\n    ) {\n      // Fall through.\n    } else if (this.waitForOwnResult) {\n      // This would usually be a part of `QueryInfo.getDiff()`.\n      // which we skip in the waitForOwnResult case since we are not\n      // interested in the diff.\n      this.queryInfo[\"updateWatch\"]();\n    } else {\n      const diff = this.queryInfo.getDiff();\n\n      if (diff.complete || this.options.returnPartialData) {\n        result.data = diff.result;\n      }\n\n      if (equal(result.data, {})) {\n        result.data = void 0 as any;\n      }\n\n      if (diff.complete) {\n        // Similar to setting result.partial to false, but taking advantage of the\n        // falsiness of missing fields.\n        delete result.partial;\n\n        // If the diff is complete, and we're using a FetchPolicy that\n        // terminates after a complete cache read, we can assume the next result\n        // we receive will have NetworkStatus.ready and !loading.\n        if (\n          diff.complete &&\n          result.networkStatus === NetworkStatus.loading &&\n          (fetchPolicy === \"cache-first\" || fetchPolicy === \"cache-only\")\n        ) {\n          result.networkStatus = NetworkStatus.ready;\n          result.loading = false;\n        }\n      } else {\n        result.partial = true;\n      }\n\n      // We need to check for both both `error` and `errors` field because there\n      // are cases where sometimes `error` is set, but not `errors` and\n      // vice-versa. This will be updated in the next major version when\n      // `errors` is deprecated in favor of `error`.\n      if (\n        result.networkStatus === NetworkStatus.ready &&\n        (result.error || result.errors)\n      ) {\n        result.networkStatus = NetworkStatus.error;\n      }\n\n      if (\n        __DEV__ &&\n        !diff.complete &&\n        !this.options.partialRefetch &&\n        !result.loading &&\n        !result.data &&\n        !result.error\n      ) {\n        logMissingFieldErrors(diff.missing);\n      }\n    }\n\n    if (saveAsLastResult) {\n      this.updateLastResult(result);\n    }\n\n    return result;\n  }\n\n  public getCurrentResult(\n    saveAsLastResult = true\n  ): ApolloQueryResult<MaybeMasked<TData>> {\n    return this.maskResult(this.getCurrentFullResult(saveAsLastResult));\n  }\n\n  // Compares newResult to the snapshot we took of this.lastResult when it was\n  // first received.\n  public isDifferentFromLastResult(\n    newResult: ApolloQueryResult<TData>,\n    variables?: TVariables\n  ) {\n    if (!this.last) {\n      return true;\n    }\n\n    const documentInfo = this.queryManager.getDocumentInfo(this.query);\n    const dataMasking = this.queryManager.dataMasking;\n    const query = dataMasking ? documentInfo.nonReactiveQuery : this.query;\n\n    const resultIsDifferent =\n      dataMasking || documentInfo.hasNonreactiveDirective ?\n        !equalByQuery(query, this.last.result, newResult, this.variables)\n      : !equal(this.last.result, newResult);\n\n    return (\n      resultIsDifferent || (variables && !equal(this.last.variables, variables))\n    );\n  }\n\n  private getLast<K extends keyof Last<TData, TVariables>>(\n    key: K,\n    variablesMustMatch?: boolean\n  ) {\n    const last = this.last;\n    if (\n      last &&\n      last[key] &&\n      (!variablesMustMatch || equal(last.variables, this.variables))\n    ) {\n      return last[key];\n    }\n  }\n\n  public getLastResult(\n    variablesMustMatch?: boolean\n  ): ApolloQueryResult<TData> | undefined {\n    return this.getLast(\"result\", variablesMustMatch);\n  }\n\n  public getLastError(variablesMustMatch?: boolean): ApolloError | undefined {\n    return this.getLast(\"error\", variablesMustMatch);\n  }\n\n  public resetLastResults(): void {\n    delete this.last;\n    this.isTornDown = false;\n  }\n\n  public resetQueryStoreErrors() {\n    this.queryManager.resetErrors(this.queryId);\n  }\n\n  /**\n   * Update the variables of this observable query, and fetch the new results.\n   * This method should be preferred over `setVariables` in most use cases.\n   *\n   * @param variables - The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  public refetch(\n    variables?: Partial<TVariables>\n  ): Promise<ApolloQueryResult<MaybeMasked<TData>>> {\n    const reobserveOptions: Partial<WatchQueryOptions<TVariables, TData>> = {\n      // Always disable polling for refetches.\n      pollInterval: 0,\n    };\n\n    // Unless the provided fetchPolicy always consults the network\n    // (no-cache, network-only, or cache-and-network), override it with\n    // network-only to force the refetch for this fetchQuery call.\n    const { fetchPolicy } = this.options;\n    if (fetchPolicy === \"no-cache\") {\n      reobserveOptions.fetchPolicy = \"no-cache\";\n    } else {\n      reobserveOptions.fetchPolicy = \"network-only\";\n    }\n\n    if (__DEV__ && variables && hasOwnProperty.call(variables, \"variables\")) {\n      const queryDef = getQueryDefinition(this.query);\n      const vars = queryDef.variableDefinitions;\n      if (!vars || !vars.some((v) => v.variable.name.value === \"variables\")) {\n        invariant.warn(\n          `Called refetch(%o) for query %o, which does not declare a $variables variable.\nDid you mean to call refetch(variables) instead of refetch({ variables })?`,\n          variables,\n          queryDef.name?.value || queryDef\n        );\n      }\n    }\n\n    if (variables && !equal(this.options.variables, variables)) {\n      // Update the existing options with new variables\n      reobserveOptions.variables = this.options.variables = {\n        ...this.options.variables,\n        ...variables,\n      } as TVariables;\n    }\n\n    this.queryInfo.resetLastWrite();\n    return this.reobserve(reobserveOptions, NetworkStatus.refetch);\n  }\n\n  /**\n   * A function that helps you fetch the next set of results for a [paginated list field](https://www.apollographql.com/docs/react/pagination/core-api/).\n   */\n  public fetchMore<\n    TFetchData = TData,\n    TFetchVars extends OperationVariables = TVariables,\n  >(\n    fetchMoreOptions: FetchMoreQueryOptions<TFetchVars, TFetchData> & {\n      updateQuery?: (\n        previousQueryResult: Unmasked<TData>,\n        options: {\n          fetchMoreResult: Unmasked<TFetchData>;\n          variables: TFetchVars;\n        }\n      ) => Unmasked<TData>;\n    }\n  ): Promise<ApolloQueryResult<MaybeMasked<TFetchData>>> {\n    const combinedOptions = {\n      ...(fetchMoreOptions.query ? fetchMoreOptions : (\n        {\n          ...this.options,\n          query: this.options.query,\n          ...fetchMoreOptions,\n          variables: {\n            ...this.options.variables,\n            ...fetchMoreOptions.variables,\n          },\n        }\n      )),\n      // The fetchMore request goes immediately to the network and does\n      // not automatically write its result to the cache (hence no-cache\n      // instead of network-only), because we allow the caller of\n      // fetchMore to provide an updateQuery callback that determines how\n      // the data gets written to the cache.\n      fetchPolicy: \"no-cache\",\n    } as WatchQueryOptions<TFetchVars, TFetchData>;\n\n    combinedOptions.query = this.transformDocument(combinedOptions.query);\n\n    const qid = this.queryManager.generateQueryId();\n\n    // If a temporary query is passed to `fetchMore`, we don't want to store\n    // it as the last query result since it may be an optimized query for\n    // pagination. We will however run the transforms on the original document\n    // as well as the document passed in `fetchMoreOptions` to ensure the cache\n    // uses the most up-to-date document which may rely on runtime conditionals.\n    this.lastQuery =\n      fetchMoreOptions.query ?\n        this.transformDocument(this.options.query)\n      : combinedOptions.query;\n\n    // Simulate a loading result for the original query with\n    // result.networkStatus === NetworkStatus.fetchMore.\n    const { queryInfo } = this;\n    const originalNetworkStatus = queryInfo.networkStatus;\n    queryInfo.networkStatus = NetworkStatus.fetchMore;\n    if (combinedOptions.notifyOnNetworkStatusChange) {\n      this.observe();\n    }\n\n    const updatedQuerySet = new Set<DocumentNode>();\n\n    const updateQuery = fetchMoreOptions?.updateQuery;\n    const isCached = this.options.fetchPolicy !== \"no-cache\";\n\n    if (!isCached) {\n      invariant(\n        updateQuery,\n        \"You must provide an `updateQuery` function when using `fetchMore` with a `no-cache` fetch policy.\"\n      );\n    }\n\n    return this.queryManager\n      .fetchQuery(qid, combinedOptions, NetworkStatus.fetchMore)\n      .then((fetchMoreResult) => {\n        this.queryManager.removeQuery(qid);\n\n        if (queryInfo.networkStatus === NetworkStatus.fetchMore) {\n          queryInfo.networkStatus = originalNetworkStatus;\n        }\n\n        if (isCached) {\n          // Performing this cache update inside a cache.batch transaction ensures\n          // any affected cache.watch watchers are notified at most once about any\n          // updates. Most watchers will be using the QueryInfo class, which\n          // responds to notifications by calling reobserveCacheFirst to deliver\n          // fetchMore cache results back to this ObservableQuery.\n          this.queryManager.cache.batch({\n            update: (cache) => {\n              const { updateQuery } = fetchMoreOptions;\n              if (updateQuery) {\n                cache.updateQuery(\n                  {\n                    query: this.query,\n                    variables: this.variables,\n                    returnPartialData: true,\n                    optimistic: false,\n                  },\n                  (previous) =>\n                    updateQuery(previous! as any, {\n                      fetchMoreResult: fetchMoreResult.data as any,\n                      variables: combinedOptions.variables as TFetchVars,\n                    })\n                );\n              } else {\n                // If we're using a field policy instead of updateQuery, the only\n                // thing we need to do is write the new data to the cache using\n                // combinedOptions.variables (instead of this.variables, which is\n                // what this.updateQuery uses, because it works by abusing the\n                // original field value, keyed by the original variables).\n                cache.writeQuery({\n                  query: combinedOptions.query,\n                  variables: combinedOptions.variables,\n                  data: fetchMoreResult.data as Unmasked<TFetchData>,\n                });\n              }\n            },\n\n            onWatchUpdated: (watch) => {\n              // Record the DocumentNode associated with any watched query whose\n              // data were updated by the cache writes above.\n              updatedQuerySet.add(watch.query);\n            },\n          });\n        } else {\n          // There is a possibility `lastResult` may not be set when\n          // `fetchMore` is called which would cause this to crash. This should\n          // only happen if we haven't previously reported a result. We don't\n          // quite know what the right behavior should be here since this block\n          // of code runs after the fetch result has executed on the network.\n          // We plan to let it crash in the meantime.\n          //\n          // If we get bug reports due to the `data` property access on\n          // undefined, this should give us a real-world scenario that we can\n          // use to test against and determine the right behavior. If we do end\n          // up changing this behavior, this may require, for example, an\n          // adjustment to the types on `updateQuery` since that function\n          // expects that the first argument always contains previous result\n          // data, but not `undefined`.\n          const lastResult = this.getLast(\"result\")!;\n          const data = updateQuery!(lastResult.data as Unmasked<TData>, {\n            fetchMoreResult: fetchMoreResult.data as Unmasked<TFetchData>,\n            variables: combinedOptions.variables as TFetchVars,\n          });\n\n          this.reportResult(\n            {\n              ...lastResult,\n              networkStatus: originalNetworkStatus!,\n              loading: isNetworkRequestInFlight(originalNetworkStatus),\n              data: data as TData,\n            },\n            this.variables\n          );\n        }\n\n        return this.maskResult(fetchMoreResult);\n      })\n      .finally(() => {\n        // In case the cache writes above did not generate a broadcast\n        // notification (which would have been intercepted by onWatchUpdated),\n        // likely because the written data were the same as what was already in\n        // the cache, we still want fetchMore to deliver its final loading:false\n        // result with the unchanged data.\n        if (isCached && !updatedQuerySet.has(this.query)) {\n          reobserveCacheFirst(this);\n        }\n      });\n  }\n\n  // XXX the subscription variables are separate from the query variables.\n  // if you want to update subscription variables, right now you have to do that separately,\n  // and you can only do it by stopping the subscription and then subscribing again with new variables.\n  /**\n   * A function that enables you to execute a [subscription](https://www.apollographql.com/docs/react/data/subscriptions/), usually to subscribe to specific fields that were included in the query.\n   *\n   * This function returns _another_ function that you can call to terminate the subscription.\n   */\n  public subscribeToMore<\n    TSubscriptionData = TData,\n    TSubscriptionVariables extends OperationVariables = TVariables,\n  >(\n    options: SubscribeToMoreOptions<\n      TData,\n      TSubscriptionVariables,\n      TSubscriptionData,\n      TVariables\n    >\n  ): () => void {\n    const subscription = this.queryManager\n      .startGraphQLSubscription({\n        query: options.document,\n        variables: options.variables,\n        context: options.context,\n      })\n      .subscribe({\n        next: (subscriptionData: { data: Unmasked<TSubscriptionData> }) => {\n          const { updateQuery } = options;\n          if (updateQuery) {\n            this.updateQuery((previous, updateOptions) =>\n              updateQuery(previous, {\n                subscriptionData,\n                ...updateOptions,\n              })\n            );\n          }\n        },\n        error: (err: any) => {\n          if (options.onError) {\n            options.onError(err);\n            return;\n          }\n          invariant.error(\"Unhandled GraphQL subscription error\", err);\n        },\n      });\n\n    this.subscriptions.add(subscription);\n\n    return () => {\n      if (this.subscriptions.delete(subscription)) {\n        subscription.unsubscribe();\n      }\n    };\n  }\n\n  public setOptions(\n    newOptions: Partial<WatchQueryOptions<TVariables, TData>>\n  ): Promise<ApolloQueryResult<MaybeMasked<TData>>> {\n    return this.reobserve(newOptions);\n  }\n\n  public silentSetOptions(\n    newOptions: Partial<WatchQueryOptions<TVariables, TData>>\n  ) {\n    const mergedOptions = compact(this.options, newOptions || {});\n    assign(this.options, mergedOptions);\n  }\n\n  /**\n   * Update the variables of this observable query, and fetch the new results\n   * if they've changed. Most users should prefer `refetch` instead of\n   * `setVariables` in order to to be properly notified of results even when\n   * they come from the cache.\n   *\n   * Note: the `next` callback will *not* fire if the variables have not changed\n   * or if the result is coming from cache.\n   *\n   * Note: the promise will return the old results immediately if the variables\n   * have not changed.\n   *\n   * Note: the promise will return null immediately if the query is not active\n   * (there are no subscribers).\n   *\n   * @param variables - The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  public setVariables(\n    variables: TVariables\n  ): Promise<ApolloQueryResult<MaybeMasked<TData>> | void> {\n    if (equal(this.variables, variables)) {\n      // If we have no observers, then we don't actually want to make a network\n      // request. As soon as someone observes the query, the request will kick\n      // off. For now, we just store any changes. (See #1077)\n      return this.observers.size ? this.result() : Promise.resolve();\n    }\n\n    this.options.variables = variables;\n\n    // See comment above\n    if (!this.observers.size) {\n      return Promise.resolve();\n    }\n\n    return this.reobserve(\n      {\n        // Reset options.fetchPolicy to its original value.\n        fetchPolicy: this.options.initialFetchPolicy,\n        variables,\n      },\n      NetworkStatus.setVariables\n    );\n  }\n\n  /**\n   * A function that enables you to update the query's cached result without executing a followup GraphQL operation.\n   *\n   * See [using updateQuery and updateFragment](https://www.apollographql.com/docs/react/caching/cache-interaction/#using-updatequery-and-updatefragment) for additional information.\n   */\n  public updateQuery(mapFn: UpdateQueryMapFn<TData, TVariables>): void {\n    const { queryManager } = this;\n    const { result, complete } = queryManager.cache.diff<TData>({\n      query: this.options.query,\n      variables: this.variables,\n      returnPartialData: true,\n      optimistic: false,\n    });\n\n    const newResult = mapFn(\n      result! as Unmasked<TData>,\n      {\n        variables: this.variables,\n        complete: !!complete,\n        previousData: result,\n      } as UpdateQueryOptions<TData, TVariables>\n    );\n\n    if (newResult) {\n      queryManager.cache.writeQuery({\n        query: this.options.query,\n        data: newResult,\n        variables: this.variables,\n      });\n\n      queryManager.broadcastQueries();\n    }\n  }\n\n  /**\n   * A function that instructs the query to begin re-executing at a specified interval (in milliseconds).\n   */\n  public startPolling(pollInterval: number) {\n    this.options.pollInterval = pollInterval;\n    this.updatePolling();\n  }\n\n  /**\n   * A function that instructs the query to stop polling after a previous call to `startPolling`.\n   */\n  public stopPolling() {\n    this.options.pollInterval = 0;\n    this.updatePolling();\n  }\n\n  // Update options.fetchPolicy according to options.nextFetchPolicy.\n  private applyNextFetchPolicy(\n    reason: NextFetchPolicyContext<TData, TVariables>[\"reason\"],\n    // It's possible to use this method to apply options.nextFetchPolicy to\n    // options.fetchPolicy even if options !== this.options, though that happens\n    // most often when the options are temporary, used for only one request and\n    // then thrown away, so nextFetchPolicy may not end up mattering.\n    options: WatchQueryOptions<TVariables, TData>\n  ) {\n    if (options.nextFetchPolicy) {\n      const { fetchPolicy = \"cache-first\", initialFetchPolicy = fetchPolicy } =\n        options;\n\n      if (fetchPolicy === \"standby\") {\n        // Do nothing, leaving options.fetchPolicy unchanged.\n      } else if (typeof options.nextFetchPolicy === \"function\") {\n        // When someone chooses \"cache-and-network\" or \"network-only\" as their\n        // initial FetchPolicy, they often do not want future cache updates to\n        // trigger unconditional network requests, which is what repeatedly\n        // applying the \"cache-and-network\" or \"network-only\" policies would\n        // seem to imply. Instead, when the cache reports an update after the\n        // initial network request, it may be desirable for subsequent network\n        // requests to be triggered only if the cache result is incomplete. To\n        // that end, the options.nextFetchPolicy option provides an easy way to\n        // update options.fetchPolicy after the initial network request, without\n        // having to call observableQuery.setOptions.\n        options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {\n          reason,\n          options,\n          observable: this,\n          initialFetchPolicy,\n        });\n      } else if (reason === \"variables-changed\") {\n        options.fetchPolicy = initialFetchPolicy;\n      } else {\n        options.fetchPolicy = options.nextFetchPolicy;\n      }\n    }\n\n    return options.fetchPolicy;\n  }\n\n  private fetch(\n    options: WatchQueryOptions<TVariables, TData>,\n    newNetworkStatus?: NetworkStatus,\n    query?: DocumentNode\n  ) {\n    // TODO Make sure we update the networkStatus (and infer fetchVariables)\n    // before actually committing to the fetch.\n    this.queryManager.setObservableQuery(this);\n    return this.queryManager[\"fetchConcastWithInfo\"](\n      this.queryId,\n      options,\n      newNetworkStatus,\n      query\n    );\n  }\n\n  // Turns polling on or off based on this.options.pollInterval.\n  private updatePolling() {\n    // Avoid polling in SSR mode\n    if (this.queryManager.ssrMode) {\n      return;\n    }\n\n    const {\n      pollingInfo,\n      options: { pollInterval },\n    } = this;\n\n    if (!pollInterval || !this.hasObservers()) {\n      if (pollingInfo) {\n        clearTimeout(pollingInfo.timeout);\n        delete this.pollingInfo;\n      }\n      return;\n    }\n\n    if (pollingInfo && pollingInfo.interval === pollInterval) {\n      return;\n    }\n\n    invariant(\n      pollInterval,\n      \"Attempted to start a polling query without a polling interval.\"\n    );\n\n    const info = pollingInfo || (this.pollingInfo = {} as any);\n    info.interval = pollInterval;\n\n    const maybeFetch = () => {\n      if (this.pollingInfo) {\n        if (\n          !isNetworkRequestInFlight(this.queryInfo.networkStatus) &&\n          !this.options.skipPollAttempt?.()\n        ) {\n          this.reobserve(\n            {\n              // Most fetchPolicy options don't make sense to use in a polling context, as\n              // users wouldn't want to be polling the cache directly. However, network-only and\n              // no-cache are both useful for when the user wants to control whether or not the\n              // polled results are written to the cache.\n              fetchPolicy:\n                this.options.initialFetchPolicy === \"no-cache\" ?\n                  \"no-cache\"\n                : \"network-only\",\n            },\n            NetworkStatus.poll\n          ).then(poll, poll);\n        } else {\n          poll();\n        }\n      }\n    };\n\n    const poll = () => {\n      const info = this.pollingInfo;\n      if (info) {\n        clearTimeout(info.timeout);\n        info.timeout = setTimeout(maybeFetch, info.interval);\n      }\n    };\n\n    poll();\n  }\n\n  private updateLastResult(\n    newResult: ApolloQueryResult<TData>,\n    variables = this.variables\n  ) {\n    let error: ApolloError | undefined = this.getLastError();\n    // Preserve this.last.error unless the variables have changed.\n    if (error && this.last && !equal(variables, this.last.variables)) {\n      error = void 0;\n    }\n    return (this.last = {\n      result:\n        this.queryManager.assumeImmutableResults ?\n          newResult\n        : cloneDeep(newResult),\n      variables,\n      ...(error ? { error } : null),\n    });\n  }\n\n  public reobserveAsConcast(\n    newOptions?: Partial<WatchQueryOptions<TVariables, TData>>,\n    newNetworkStatus?: NetworkStatus\n  ): Concast<ApolloQueryResult<TData>> {\n    this.isTornDown = false;\n\n    const useDisposableConcast =\n      // Refetching uses a disposable Concast to allow refetches using different\n      // options/variables, without permanently altering the options of the\n      // original ObservableQuery.\n      newNetworkStatus === NetworkStatus.refetch ||\n      // The fetchMore method does not actually call the reobserve method, but,\n      // if it did, it would definitely use a disposable Concast.\n      newNetworkStatus === NetworkStatus.fetchMore ||\n      // Polling uses a disposable Concast so the polling options (which force\n      // fetchPolicy to be \"network-only\" or \"no-cache\") won't override the original options.\n      newNetworkStatus === NetworkStatus.poll;\n\n    // Save the old variables, since Object.assign may modify them below.\n    const oldVariables = this.options.variables;\n    const oldFetchPolicy = this.options.fetchPolicy;\n\n    const mergedOptions = compact(this.options, newOptions || {});\n    const options =\n      useDisposableConcast ?\n        // Disposable Concast fetches receive a shallow copy of this.options\n        // (merged with newOptions), leaving this.options unmodified.\n        mergedOptions\n      : assign(this.options, mergedOptions);\n\n    // Don't update options.query with the transformed query to avoid\n    // overwriting this.options.query when we aren't using a disposable concast.\n    // We want to ensure we can re-run the custom document transforms the next\n    // time a request is made against the original query.\n    const query = this.transformDocument(options.query);\n\n    this.lastQuery = query;\n\n    if (!useDisposableConcast) {\n      // We can skip calling updatePolling if we're not changing this.options.\n      this.updatePolling();\n\n      // Reset options.fetchPolicy to its original value when variables change,\n      // unless a new fetchPolicy was provided by newOptions.\n      if (\n        newOptions &&\n        newOptions.variables &&\n        !equal(newOptions.variables, oldVariables) &&\n        // Don't mess with the fetchPolicy if it's currently \"standby\".\n        options.fetchPolicy !== \"standby\" &&\n        // If we're changing the fetchPolicy anyway, don't try to change it here\n        // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.\n        (options.fetchPolicy === oldFetchPolicy ||\n          // A `nextFetchPolicy` function has even higher priority, though,\n          // so in that case `applyNextFetchPolicy` must be called.\n          typeof options.nextFetchPolicy === \"function\")\n      ) {\n        this.applyNextFetchPolicy(\"variables-changed\", options);\n        if (newNetworkStatus === void 0) {\n          newNetworkStatus = NetworkStatus.setVariables;\n        }\n      }\n    }\n\n    this.waitForOwnResult &&= skipCacheDataFor(options.fetchPolicy);\n    const finishWaitingForOwnResult = () => {\n      if (this.concast === concast) {\n        this.waitForOwnResult = false;\n      }\n    };\n\n    const variables = options.variables && { ...options.variables };\n    const { concast, fromLink } = this.fetch(options, newNetworkStatus, query);\n    const observer: Observer<ApolloQueryResult<TData>> = {\n      next: (result) => {\n        if (equal(this.variables, variables)) {\n          finishWaitingForOwnResult();\n          this.reportResult(result, variables);\n        }\n      },\n      error: (error) => {\n        if (equal(this.variables, variables)) {\n          // Coming from `getResultsFromLink`, `error` here should always be an `ApolloError`.\n          // However, calling `concast.cancel` can inject another type of error, so we have to\n          // wrap it again here.\n          if (!isApolloError(error)) {\n            error = new ApolloError({ networkError: error });\n          }\n          finishWaitingForOwnResult();\n          this.reportError(error, variables);\n        }\n      },\n    };\n\n    if (!useDisposableConcast && (fromLink || !this.concast)) {\n      // We use the {add,remove}Observer methods directly to avoid wrapping\n      // observer with an unnecessary SubscriptionObserver object.\n      if (this.concast && this.observer) {\n        this.concast.removeObserver(this.observer);\n      }\n\n      this.concast = concast;\n      this.observer = observer;\n    }\n\n    concast.addObserver(observer);\n\n    return concast;\n  }\n\n  public reobserve(\n    newOptions?: Partial<WatchQueryOptions<TVariables, TData>>,\n    newNetworkStatus?: NetworkStatus\n  ): Promise<ApolloQueryResult<MaybeMasked<TData>>> {\n    return preventUnhandledRejection(\n      this.reobserveAsConcast(newOptions, newNetworkStatus).promise.then(\n        this.maskResult as TODO\n      )\n    );\n  }\n\n  public resubscribeAfterError(\n    onNext: (value: ApolloQueryResult<MaybeMasked<TData>>) => void,\n    onError?: (error: any) => void,\n    onComplete?: () => void\n  ): ObservableSubscription;\n\n  public resubscribeAfterError(\n    observer: Observer<ApolloQueryResult<TData>>\n  ): ObservableSubscription;\n\n  public resubscribeAfterError(...args: [any, any?, any?]) {\n    // If `lastError` is set in the current when the subscription is re-created,\n    // the subscription will immediately receive the error, which will\n    // cause it to terminate again. To avoid this, we first clear\n    // the last error/result from the `observableQuery` before re-starting\n    // the subscription, and restore the last value afterwards so that the\n    // subscription has a chance to stay open.\n    const last = this.last;\n    this.resetLastResults();\n\n    const subscription = this.subscribe(...args);\n    this.last = last;\n\n    return subscription;\n  }\n\n  // (Re)deliver the current result to this.observers without applying fetch\n  // policies or making network requests.\n  private observe() {\n    this.reportResult(\n      // Passing false is important so that this.getCurrentResult doesn't\n      // save the fetchMore result as this.lastResult, causing it to be\n      // ignored due to the this.isDifferentFromLastResult check in\n      // this.reportResult.\n      this.getCurrentFullResult(false),\n      this.variables\n    );\n  }\n\n  private reportResult(\n    result: ApolloQueryResult<TData>,\n    variables: TVariables | undefined\n  ) {\n    const lastError = this.getLastError();\n    const isDifferent = this.isDifferentFromLastResult(result, variables);\n    // Update the last result even when isDifferentFromLastResult returns false,\n    // because the query may be using the @nonreactive directive, and we want to\n    // save the the latest version of any nonreactive subtrees (in case\n    // getCurrentResult is called), even though we skip broadcasting changes.\n    if (lastError || !result.partial || this.options.returnPartialData) {\n      this.updateLastResult(result, variables);\n    }\n    if (lastError || isDifferent) {\n      iterateObserversSafely(this.observers, \"next\", this.maskResult(result));\n    }\n  }\n\n  private reportError(error: ApolloError, variables: TVariables | undefined) {\n    // Since we don't get the current result on errors, only the error, we\n    // must mirror the updates that occur in QueryStore.markQueryError here\n    const errorResult = {\n      ...this.getLastResult(),\n      error,\n      errors: error.graphQLErrors,\n      networkStatus: NetworkStatus.error,\n      loading: false,\n    } as ApolloQueryResult<TData>;\n\n    this.updateLastResult(errorResult, variables);\n\n    iterateObserversSafely(this.observers, \"error\", (this.last!.error = error));\n  }\n\n  public hasObservers() {\n    return this.observers.size > 0;\n  }\n\n  private tearDownQuery() {\n    if (this.isTornDown) return;\n    if (this.concast && this.observer) {\n      this.concast.removeObserver(this.observer);\n      delete this.concast;\n      delete this.observer;\n    }\n\n    this.stopPolling();\n    // stop all active GraphQL subscriptions\n    this.subscriptions.forEach((sub) => sub.unsubscribe());\n    this.subscriptions.clear();\n    this.queryManager.stopQuery(this.queryId);\n    this.observers.clear();\n    this.isTornDown = true;\n  }\n\n  private transformDocument(document: DocumentNode) {\n    return this.queryManager.transform(document);\n  }\n\n  private maskResult<T = TData>(\n    result: ApolloQueryResult<T>\n  ): ApolloQueryResult<MaybeMasked<T>> {\n    return result && \"data\" in result ?\n        {\n          ...result,\n          data: this.queryManager.maskOperation({\n            document: this.query,\n            data: result.data,\n            fetchPolicy: this.options.fetchPolicy,\n            id: this.queryId,\n          }),\n        }\n      : result;\n  }\n}\n\n// Necessary because the ObservableQuery constructor has a different\n// signature than the Observable constructor.\nfixObservableSubclass(ObservableQuery);\n\n// Reobserve with fetchPolicy effectively set to \"cache-first\", triggering\n// delivery of any new data from the cache, possibly falling back to the network\n// if any cache data are missing. This allows _complete_ cache results to be\n// delivered without also kicking off unnecessary network requests when\n// this.options.fetchPolicy is \"cache-and-network\" or \"network-only\". When\n// this.options.fetchPolicy is any other policy (\"cache-first\", \"cache-only\",\n// \"standby\", or \"no-cache\"), we call this.reobserve() as usual.\nexport function reobserveCacheFirst<TData, TVars extends OperationVariables>(\n  obsQuery: ObservableQuery<TData, TVars>\n) {\n  const { fetchPolicy, nextFetchPolicy } = obsQuery.options;\n\n  if (fetchPolicy === \"cache-and-network\" || fetchPolicy === \"network-only\") {\n    return obsQuery.reobserve({\n      fetchPolicy: \"cache-first\",\n      // Use a temporary nextFetchPolicy function that replaces itself with the\n      // previous nextFetchPolicy value and returns the original fetchPolicy.\n      nextFetchPolicy(\n        this: WatchQueryOptions<TVars, TData>,\n        currentFetchPolicy: WatchQueryFetchPolicy,\n        context: NextFetchPolicyContext<TData, TVars>\n      ) {\n        // Replace this nextFetchPolicy function in the options object with the\n        // original this.options.nextFetchPolicy value.\n        this.nextFetchPolicy = nextFetchPolicy;\n        // If the original nextFetchPolicy value was a function, give it a\n        // chance to decide what happens here.\n        if (typeof this.nextFetchPolicy === \"function\") {\n          return this.nextFetchPolicy(currentFetchPolicy, context);\n        }\n        // Otherwise go back to the original this.options.fetchPolicy.\n        return fetchPolicy!;\n      },\n    });\n  }\n\n  return obsQuery.reobserve();\n}\n\nfunction defaultSubscriptionObserverErrorCallback(error: ApolloError) {\n  invariant.error(\"Unhandled error\", error.message, error.stack);\n}\n\nexport function logMissingFieldErrors(\n  missing: MissingFieldError[] | MissingTree | undefined\n) {\n  if (__DEV__ && missing) {\n    invariant.debug(`Missing cache result fields: %o`, missing);\n  }\n}\n\nfunction skipCacheDataFor(\n  fetchPolicy?: WatchQueryFetchPolicy /* `undefined` would mean `\"cache-first\"` */\n) {\n  return (\n    fetchPolicy === \"network-only\" ||\n    fetchPolicy === \"no-cache\" ||\n    fetchPolicy === \"standby\"\n  );\n}\n", "import type { DocumentNode, GraphQLFormattedError } from \"graphql\";\nimport { equal } from \"@wry/equality\";\n\nimport type { Cache, ApolloCache } from \"../cache/index.js\";\nimport { DeepMerger } from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/index.js\";\nimport type { WatchQueryOptions, ErrorPolicy } from \"./watchQueryOptions.js\";\nimport type { ObservableQuery } from \"./ObservableQuery.js\";\nimport { reobserveCacheFirst } from \"./ObservableQuery.js\";\nimport type { QueryListener } from \"./types.js\";\nimport type { FetchResult } from \"../link/core/index.js\";\nimport {\n  isNonEmptyArray,\n  graphQLResultHasError,\n  canUseWeakMap,\n} from \"../utilities/index.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport type { ApolloError } from \"../errors/index.js\";\nimport type { QueryManager } from \"./QueryManager.js\";\nimport type { Unmasked } from \"../masking/index.js\";\n\nexport type QueryStoreValue = Pick<\n  QueryInfo,\n  \"variables\" | \"networkStatus\" | \"networkError\" | \"graphQLErrors\"\n>;\n\nexport const enum CacheWriteBehavior {\n  FORBID,\n  OVERWRITE,\n  MERGE,\n}\n\nconst destructiveMethodCounts = new (canUseWeakMap ? WeakMap : Map)<\n  ApolloCache<any>,\n  number\n>();\n\nfunction wrapDestructiveCacheMethod(\n  cache: ApolloCache<any>,\n  methodName: \"evict\" | \"modify\" | \"reset\"\n) {\n  const original = cache[methodName];\n  if (typeof original === \"function\") {\n    // @ts-expect-error this is just too generic to be typed correctly\n    cache[methodName] = function () {\n      destructiveMethodCounts.set(\n        cache,\n        // The %1e15 allows the count to wrap around to 0 safely every\n        // quadrillion evictions, so there's no risk of overflow. To be\n        // clear, this is more of a pedantic principle than something\n        // that matters in any conceivable practical scenario.\n        (destructiveMethodCounts.get(cache)! + 1) % 1e15\n      );\n      // @ts-expect-error this is just too generic to be typed correctly\n      return original.apply(this, arguments);\n    };\n  }\n}\n\nfunction cancelNotifyTimeout(info: QueryInfo) {\n  if (info[\"notifyTimeout\"]) {\n    clearTimeout(info[\"notifyTimeout\"]);\n    info[\"notifyTimeout\"] = void 0;\n  }\n}\n\n// A QueryInfo object represents a single query managed by the\n// QueryManager, which tracks all QueryInfo objects by queryId in its\n// this.queries Map. QueryInfo objects store the latest results and errors\n// for the given query, and are responsible for reporting those results to\n// the corresponding ObservableQuery, via the QueryInfo.notify method.\n// Results are reported asynchronously whenever setDiff marks the\n// QueryInfo object as dirty, though a call to the QueryManager's\n// broadcastQueries method may trigger the notification before it happens\n// automatically. This class used to be a simple interface type without\n// any field privacy or meaningful methods, which is why it still has so\n// many public fields. The effort to lock down and simplify the QueryInfo\n// interface is ongoing, and further improvements are welcome.\nexport class QueryInfo {\n  listeners = new Set<QueryListener>();\n  document: DocumentNode | null = null;\n  lastRequestId = 1;\n  variables?: Record<string, any>;\n  networkStatus?: NetworkStatus;\n  networkError?: Error | null;\n  graphQLErrors?: ReadonlyArray<GraphQLFormattedError>;\n  stopped = false;\n\n  private cache: ApolloCache<any>;\n\n  constructor(\n    queryManager: QueryManager<any>,\n    public readonly queryId = queryManager.generateQueryId()\n  ) {\n    const cache = (this.cache = queryManager.cache);\n\n    // Track how often cache.evict is called, since we want eviction to\n    // override the feud-stopping logic in the markResult method, by\n    // causing shouldWrite to return true. Wrapping the cache.evict method\n    // is a bit of a hack, but it saves us from having to make eviction\n    // counting an official part of the ApolloCache API.\n    if (!destructiveMethodCounts.has(cache)) {\n      destructiveMethodCounts.set(cache, 0);\n      wrapDestructiveCacheMethod(cache, \"evict\");\n      wrapDestructiveCacheMethod(cache, \"modify\");\n      wrapDestructiveCacheMethod(cache, \"reset\");\n    }\n  }\n\n  public init(query: {\n    document: DocumentNode;\n    variables: Record<string, any> | undefined;\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus?: NetworkStatus;\n    observableQuery?: ObservableQuery<any, any>;\n    lastRequestId?: number;\n  }): this {\n    let networkStatus = query.networkStatus || NetworkStatus.loading;\n    if (\n      this.variables &&\n      this.networkStatus !== NetworkStatus.loading &&\n      !equal(this.variables, query.variables)\n    ) {\n      networkStatus = NetworkStatus.setVariables;\n    }\n\n    if (!equal(query.variables, this.variables)) {\n      this.lastDiff = void 0;\n    }\n\n    Object.assign(this, {\n      document: query.document,\n      variables: query.variables,\n      networkError: null,\n      graphQLErrors: this.graphQLErrors || [],\n      networkStatus,\n    });\n\n    if (query.observableQuery) {\n      this.setObservableQuery(query.observableQuery);\n    }\n\n    if (query.lastRequestId) {\n      this.lastRequestId = query.lastRequestId;\n    }\n\n    return this;\n  }\n\n  private dirty: boolean = false;\n\n  private notifyTimeout?: ReturnType<typeof setTimeout>;\n\n  reset() {\n    cancelNotifyTimeout(this);\n    this.dirty = false;\n  }\n\n  resetDiff() {\n    this.lastDiff = void 0;\n  }\n\n  getDiff(): Cache.DiffResult<any> {\n    const options = this.getDiffOptions();\n\n    if (this.lastDiff && equal(options, this.lastDiff.options)) {\n      return this.lastDiff.diff;\n    }\n\n    this.updateWatch(this.variables);\n\n    const oq = this.observableQuery;\n    if (oq && oq.options.fetchPolicy === \"no-cache\") {\n      return { complete: false };\n    }\n\n    const diff = this.cache.diff(options);\n    this.updateLastDiff(diff, options);\n    return diff;\n  }\n\n  private lastDiff?: {\n    diff: Cache.DiffResult<any>;\n    options: Cache.DiffOptions;\n  };\n\n  private updateLastDiff(\n    diff: Cache.DiffResult<any> | null,\n    options?: Cache.DiffOptions\n  ) {\n    this.lastDiff =\n      diff ?\n        {\n          diff,\n          options: options || this.getDiffOptions(),\n        }\n      : void 0;\n  }\n\n  private getDiffOptions(variables = this.variables): Cache.DiffOptions {\n    return {\n      query: this.document!,\n      variables,\n      returnPartialData: true,\n      optimistic: true,\n      canonizeResults: this.observableQuery?.options.canonizeResults,\n    };\n  }\n\n  setDiff(diff: Cache.DiffResult<any> | null) {\n    const oldDiff = this.lastDiff && this.lastDiff.diff;\n\n    // If we are trying to deliver an incomplete cache result, we avoid\n    // reporting it if the query has errored, otherwise we let the broadcast try\n    // and repair the partial result by refetching the query. This check avoids\n    // a situation where a query that errors and another succeeds with\n    // overlapping data does not report the partial data result to the errored\n    // query.\n    //\n    // See https://github.com/apollographql/apollo-client/issues/11400 for more\n    // information on this issue.\n    if (diff && !diff.complete && this.observableQuery?.getLastError()) {\n      return;\n    }\n\n    this.updateLastDiff(diff);\n\n    if (!this.dirty && !equal(oldDiff && oldDiff.result, diff && diff.result)) {\n      this.dirty = true;\n      if (!this.notifyTimeout) {\n        this.notifyTimeout = setTimeout(() => this.notify(), 0);\n      }\n    }\n  }\n\n  public readonly observableQuery: ObservableQuery<any, any> | null = null;\n  private oqListener?: QueryListener;\n\n  setObservableQuery(oq: ObservableQuery<any, any> | null) {\n    if (oq === this.observableQuery) return;\n\n    if (this.oqListener) {\n      this.listeners.delete(this.oqListener);\n    }\n\n    (this as any).observableQuery = oq;\n\n    if (oq) {\n      oq[\"queryInfo\"] = this;\n      this.listeners.add(\n        (this.oqListener = () => {\n          const diff = this.getDiff();\n          if (diff.fromOptimisticTransaction) {\n            // If this diff came from an optimistic transaction, deliver the\n            // current cache data to the ObservableQuery, but don't perform a\n            // reobservation, since oq.reobserveCacheFirst might make a network\n            // request, and we never want to trigger network requests in the\n            // middle of optimistic updates.\n            oq[\"observe\"]();\n          } else {\n            // Otherwise, make the ObservableQuery \"reobserve\" the latest data\n            // using a temporary fetch policy of \"cache-first\", so complete cache\n            // results have a chance to be delivered without triggering additional\n            // network requests, even when options.fetchPolicy is \"network-only\"\n            // or \"cache-and-network\". All other fetch policies are preserved by\n            // this method, and are handled by calling oq.reobserve(). If this\n            // reobservation is spurious, isDifferentFromLastResult still has a\n            // chance to catch it before delivery to ObservableQuery subscribers.\n            reobserveCacheFirst(oq);\n          }\n        })\n      );\n    } else {\n      delete this.oqListener;\n    }\n  }\n\n  notify() {\n    cancelNotifyTimeout(this);\n\n    if (this.shouldNotify()) {\n      this.listeners.forEach((listener) => listener(this));\n    }\n\n    this.dirty = false;\n  }\n\n  private shouldNotify() {\n    if (!this.dirty || !this.listeners.size) {\n      return false;\n    }\n\n    if (isNetworkRequestInFlight(this.networkStatus) && this.observableQuery) {\n      const { fetchPolicy } = this.observableQuery.options;\n      if (fetchPolicy !== \"cache-only\" && fetchPolicy !== \"cache-and-network\") {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  public stop() {\n    if (!this.stopped) {\n      this.stopped = true;\n\n      // Cancel the pending notify timeout\n      this.reset();\n\n      this.cancel();\n      // Revert back to the no-op version of cancel inherited from\n      // QueryInfo.prototype.\n      this.cancel = QueryInfo.prototype.cancel;\n\n      const oq = this.observableQuery;\n      if (oq) oq.stopPolling();\n    }\n  }\n\n  // This method is a no-op by default, until/unless overridden by the\n  // updateWatch method.\n  private cancel() {}\n\n  private lastWatch?: Cache.WatchOptions;\n\n  private updateWatch(variables = this.variables) {\n    const oq = this.observableQuery;\n    if (oq && oq.options.fetchPolicy === \"no-cache\") {\n      return;\n    }\n\n    const watchOptions: Cache.WatchOptions = {\n      // Although this.getDiffOptions returns Cache.DiffOptions instead of\n      // Cache.WatchOptions, all the overlapping options should be the same, so\n      // we can reuse getDiffOptions here, for consistency.\n      ...this.getDiffOptions(variables),\n      watcher: this,\n      callback: (diff) => this.setDiff(diff),\n    };\n\n    if (!this.lastWatch || !equal(watchOptions, this.lastWatch)) {\n      this.cancel();\n      this.cancel = this.cache.watch((this.lastWatch = watchOptions));\n    }\n  }\n\n  private lastWrite?: {\n    result: FetchResult<any>;\n    variables: WatchQueryOptions[\"variables\"];\n    dmCount: number | undefined;\n  };\n\n  public resetLastWrite() {\n    this.lastWrite = void 0;\n  }\n\n  private shouldWrite(\n    result: FetchResult<any>,\n    variables: WatchQueryOptions[\"variables\"]\n  ) {\n    const { lastWrite } = this;\n    return !(\n      lastWrite &&\n      // If cache.evict has been called since the last time we wrote this\n      // data into the cache, there's a chance writing this result into\n      // the cache will repair what was evicted.\n      lastWrite.dmCount === destructiveMethodCounts.get(this.cache) &&\n      equal(variables, lastWrite.variables) &&\n      equal(result.data, lastWrite.result.data)\n    );\n  }\n\n  public markResult<T>(\n    result: FetchResult<T>,\n    document: DocumentNode,\n    options: Pick<\n      WatchQueryOptions,\n      \"variables\" | \"fetchPolicy\" | \"errorPolicy\"\n    >,\n    cacheWriteBehavior: CacheWriteBehavior\n  ) {\n    const merger = new DeepMerger();\n    const graphQLErrors =\n      isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];\n\n    // Cancel the pending notify timeout (if it exists) to prevent extraneous network\n    // requests. To allow future notify timeouts, diff and dirty are reset as well.\n    this.reset();\n\n    if (\"incremental\" in result && isNonEmptyArray(result.incremental)) {\n      const mergedData = mergeIncrementalData(this.getDiff().result, result);\n      result.data = mergedData;\n\n      // Detect the first chunk of a deferred query and merge it with existing\n      // cache data. This ensures a `cache-first` fetch policy that returns\n      // partial cache data or a `cache-and-network` fetch policy that already\n      // has full data in the cache does not complain when trying to merge the\n      // initial deferred server data with existing cache data.\n    } else if (\"hasNext\" in result && result.hasNext) {\n      const diff = this.getDiff();\n      result.data = merger.merge(diff.result, result.data);\n    }\n\n    this.graphQLErrors = graphQLErrors;\n\n    if (options.fetchPolicy === \"no-cache\") {\n      this.updateLastDiff(\n        { result: result.data, complete: true },\n        this.getDiffOptions(options.variables)\n      );\n    } else if (cacheWriteBehavior !== CacheWriteBehavior.FORBID) {\n      if (shouldWriteResult(result, options.errorPolicy)) {\n        // Using a transaction here so we have a chance to read the result\n        // back from the cache before the watch callback fires as a result\n        // of writeQuery, so we can store the new diff quietly and ignore\n        // it when we receive it redundantly from the watch callback.\n        this.cache.performTransaction((cache) => {\n          if (this.shouldWrite(result, options.variables)) {\n            cache.writeQuery({\n              query: document,\n              data: result.data as Unmasked<T>,\n              variables: options.variables,\n              overwrite: cacheWriteBehavior === CacheWriteBehavior.OVERWRITE,\n            });\n\n            this.lastWrite = {\n              result,\n              variables: options.variables,\n              dmCount: destructiveMethodCounts.get(this.cache),\n            };\n          } else {\n            // If result is the same as the last result we received from\n            // the network (and the variables match too), avoid writing\n            // result into the cache again. The wisdom of skipping this\n            // cache write is far from obvious, since any cache write\n            // could be the one that puts the cache back into a desired\n            // state, fixing corruption or missing data. However, if we\n            // always write every network result into the cache, we enable\n            // feuds between queries competing to update the same data in\n            // incompatible ways, which can lead to an endless cycle of\n            // cache broadcasts and useless network requests. As with any\n            // feud, eventually one side must step back from the brink,\n            // letting the other side(s) have the last word(s). There may\n            // be other points where we could break this cycle, such as\n            // silencing the broadcast for cache.writeQuery (not a good\n            // idea, since it just delays the feud a bit) or somehow\n            // avoiding the network request that just happened (also bad,\n            // because the server could return useful new data). All\n            // options considered, skipping this cache write seems to be\n            // the least damaging place to break the cycle, because it\n            // reflects the intuition that we recently wrote this exact\n            // result into the cache, so the cache *should* already/still\n            // contain this data. If some other query has clobbered that\n            // data in the meantime, that's too bad, but there will be no\n            // winners if every query blindly reverts to its own version\n            // of the data. This approach also gives the network a chance\n            // to return new data, which will be written into the cache as\n            // usual, notifying only those queries that are directly\n            // affected by the cache updates, as usual. In the future, an\n            // even more sophisticated cache could perhaps prevent or\n            // mitigate the clobbering somehow, but that would make this\n            // particular cache write even less important, and thus\n            // skipping it would be even safer than it is today.\n            if (this.lastDiff && this.lastDiff.diff.complete) {\n              // Reuse data from the last good (complete) diff that we\n              // received, when possible.\n              result.data = this.lastDiff.diff.result;\n              return;\n            }\n            // If the previous this.diff was incomplete, fall through to\n            // re-reading the latest data with cache.diff, below.\n          }\n\n          const diffOptions = this.getDiffOptions(options.variables);\n          const diff = cache.diff<T>(diffOptions);\n\n          // In case the QueryManager stops this QueryInfo before its\n          // results are delivered, it's important to avoid restarting the\n          // cache watch when markResult is called. We also avoid updating\n          // the watch if we are writing a result that doesn't match the current\n          // variables to avoid race conditions from broadcasting the wrong\n          // result.\n          if (!this.stopped && equal(this.variables, options.variables)) {\n            // Any time we're about to update this.diff, we need to make\n            // sure we've started watching the cache.\n            this.updateWatch(options.variables);\n          }\n\n          // If we're allowed to write to the cache, and we can read a\n          // complete result from the cache, update result.data to be the\n          // result from the cache, rather than the raw network result.\n          // Set without setDiff to avoid triggering a notify call, since\n          // we have other ways of notifying for this result.\n          this.updateLastDiff(diff, diffOptions);\n          if (diff.complete) {\n            result.data = diff.result;\n          }\n        });\n      } else {\n        this.lastWrite = void 0;\n      }\n    }\n  }\n\n  public markReady() {\n    this.networkError = null;\n    return (this.networkStatus = NetworkStatus.ready);\n  }\n\n  public markError(error: ApolloError) {\n    this.networkStatus = NetworkStatus.error;\n    this.lastWrite = void 0;\n\n    this.reset();\n\n    if (error.graphQLErrors) {\n      this.graphQLErrors = error.graphQLErrors;\n    }\n\n    if (error.networkError) {\n      this.networkError = error.networkError;\n    }\n\n    return error;\n  }\n}\n\nexport function shouldWriteResult<T>(\n  result: FetchResult<T>,\n  errorPolicy: ErrorPolicy = \"none\"\n) {\n  const ignoreErrors = errorPolicy === \"ignore\" || errorPolicy === \"all\";\n  let writeWithErrors = !graphQLResultHasError(result);\n  if (!writeWithErrors && ignoreErrors && result.data) {\n    writeWithErrors = true;\n  }\n  return writeWithErrors;\n}\n", "import { invariant, newInvariantError } from \"../utilities/globals/index.js\";\n\nimport type { DocumentNode } from \"graphql\";\n// TODO(brian): A hack until this issue is resolved (https://github.com/graphql/graphql-js/issues/3356)\ntype OperationTypeNode = any;\nimport { equal } from \"@wry/equality\";\n\nimport type { ApolloLink, FetchResult } from \"../link/core/index.js\";\nimport { execute } from \"../link/core/index.js\";\nimport {\n  addNonReactiveToNamedFragments,\n  defaultCacheSizes,\n  hasDirectives,\n  isExecutionPatchIncrementalResult,\n  isExecutionPatchResult,\n  isFullyUnmaskedOperation,\n  removeDirectivesFromDocument,\n} from \"../utilities/index.js\";\nimport type { Cache, ApolloCache } from \"../cache/index.js\";\nimport { canonicalStringify } from \"../cache/index.js\";\n\nimport type {\n  ObservableSubscription,\n  ConcastSourcesArray,\n} from \"../utilities/index.js\";\nimport {\n  getDefaultValues,\n  getOperationDefinition,\n  getOperationName,\n  hasClientExports,\n  graphQLResultHasError,\n  getGraphQLErrorsFromResult,\n  Observable,\n  asyncMap,\n  isNonEmptyArray,\n  Concast,\n  makeUniqueId,\n  isDocumentNode,\n  isNonNullObject,\n  DocumentTransform,\n} from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/common/incrementalResult.js\";\nimport {\n  ApolloError,\n  isApolloError,\n  graphQLResultHasProtocolErrors,\n} from \"../errors/index.js\";\nimport type {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  ErrorPolicy,\n  MutationFetchPolicy,\n  WatchQueryFetchPolicy,\n} from \"./watchQueryOptions.js\";\nimport { ObservableQuery, logMissingFieldErrors } from \"./ObservableQuery.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport type {\n  ApolloQueryResult,\n  OperationVariables,\n  MutationUpdaterFunction,\n  OnQueryUpdated,\n  InternalRefetchQueriesInclude,\n  InternalRefetchQueriesOptions,\n  InternalRefetchQueriesResult,\n  InternalRefetchQueriesMap,\n  DefaultContext,\n} from \"./types.js\";\nimport type { LocalState } from \"./LocalState.js\";\n\nimport type { QueryStoreValue } from \"./QueryInfo.js\";\nimport {\n  QueryInfo,\n  shouldWriteResult,\n  CacheWriteBehavior,\n} from \"./QueryInfo.js\";\nimport type { ApolloErrorOptions } from \"../errors/index.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../errors/index.js\";\nimport { print } from \"../utilities/index.js\";\nimport type { IgnoreModifier } from \"../cache/core/types/common.js\";\nimport type { TODO } from \"../utilities/types/TODO.js\";\n\nconst { hasOwnProperty } = Object.prototype;\n\nconst IGNORE: IgnoreModifier = Object.create(null);\n\ninterface MutationStoreValue {\n  mutation: DocumentNode;\n  variables: Record<string, any>;\n  loading: boolean;\n  error: Error | null;\n}\n\ntype UpdateQueries<TData> = MutationOptions<TData, any, any>[\"updateQueries\"];\n\ninterface TransformCacheEntry {\n  hasClientExports: boolean;\n  hasForcedResolvers: boolean;\n  hasNonreactiveDirective: boolean;\n  nonReactiveQuery: DocumentNode;\n  clientQuery: DocumentNode | null;\n  serverQuery: DocumentNode | null;\n  defaultVars: OperationVariables;\n  asQuery: DocumentNode;\n}\n\nimport type { DefaultOptions } from \"./ApolloClient.js\";\nimport { Trie } from \"@wry/trie\";\nimport { AutoCleanedWeakCache, cacheSizes } from \"../utilities/index.js\";\nimport { maskFragment, maskOperation } from \"../masking/index.js\";\nimport type { MaybeMasked, Unmasked } from \"../masking/index.js\";\n\ninterface MaskFragmentOptions<TData> {\n  fragment: DocumentNode;\n  data: TData;\n  fragmentName?: string;\n}\n\ninterface MaskOperationOptions<TData> {\n  document: DocumentNode;\n  data: TData;\n  id: string;\n  fetchPolicy?: WatchQueryFetchPolicy;\n}\n\nexport interface QueryManagerOptions<TStore> {\n  cache: ApolloCache<TStore>;\n  link: ApolloLink;\n  defaultOptions: DefaultOptions;\n  documentTransform: DocumentTransform | null | undefined;\n  queryDeduplication: boolean;\n  onBroadcast: undefined | (() => void);\n  ssrMode: boolean;\n  clientAwareness: Record<string, string>;\n  localState: LocalState<TStore>;\n  assumeImmutableResults: boolean;\n  defaultContext: Partial<DefaultContext> | undefined;\n  dataMasking: boolean;\n}\n\nexport class QueryManager<TStore> {\n  public cache: ApolloCache<TStore>;\n  public link: ApolloLink;\n  public defaultOptions: DefaultOptions;\n\n  public readonly assumeImmutableResults: boolean;\n  public readonly documentTransform: DocumentTransform;\n  public readonly ssrMode: boolean;\n  public readonly defaultContext: Partial<DefaultContext>;\n  public readonly dataMasking: boolean;\n\n  private queryDeduplication: boolean;\n  private clientAwareness: Record<string, string> = {};\n  private localState: LocalState<TStore>;\n\n  private onBroadcast?: () => void;\n  public mutationStore?: {\n    [mutationId: string]: MutationStoreValue;\n  };\n\n  // All the queries that the QueryManager is currently managing (not\n  // including mutations and subscriptions).\n  private queries = new Map<string, QueryInfo>();\n\n  // Maps from queryId strings to Promise rejection functions for\n  // currently active queries and fetches.\n  // Use protected instead of private field so\n  // @apollo/experimental-nextjs-app-support can access type info.\n  protected fetchCancelFns = new Map<string, (error: any) => any>();\n\n  constructor(options: QueryManagerOptions<TStore>) {\n    const defaultDocumentTransform = new DocumentTransform(\n      (document) => this.cache.transformDocument(document),\n      // Allow the apollo cache to manage its own transform caches\n      { cache: false }\n    );\n\n    this.cache = options.cache;\n    this.link = options.link;\n    this.defaultOptions = options.defaultOptions;\n    this.queryDeduplication = options.queryDeduplication;\n    this.clientAwareness = options.clientAwareness;\n    this.localState = options.localState;\n    this.ssrMode = options.ssrMode;\n    this.assumeImmutableResults = options.assumeImmutableResults;\n    this.dataMasking = options.dataMasking;\n    const documentTransform = options.documentTransform;\n    this.documentTransform =\n      documentTransform ?\n        defaultDocumentTransform\n          .concat(documentTransform)\n          // The custom document transform may add new fragment spreads or new\n          // field selections, so we want to give the cache a chance to run\n          // again. For example, the InMemoryCache adds __typename to field\n          // selections and fragments from the fragment registry.\n          .concat(defaultDocumentTransform)\n      : defaultDocumentTransform;\n    this.defaultContext = options.defaultContext || Object.create(null);\n\n    if ((this.onBroadcast = options.onBroadcast)) {\n      this.mutationStore = Object.create(null);\n    }\n  }\n\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  public stop() {\n    this.queries.forEach((_info, queryId) => {\n      this.stopQueryNoBroadcast(queryId);\n    });\n\n    this.cancelPendingFetches(\n      newInvariantError(\"QueryManager stopped while query was in flight\")\n    );\n  }\n\n  private cancelPendingFetches(error: Error) {\n    this.fetchCancelFns.forEach((cancel) => cancel(error));\n    this.fetchCancelFns.clear();\n  }\n\n  public async mutate<\n    TData,\n    TVariables extends OperationVariables,\n    TContext extends Record<string, any>,\n    TCache extends ApolloCache<any>,\n  >({\n    mutation,\n    variables,\n    optimisticResponse,\n    updateQueries,\n    refetchQueries = [],\n    awaitRefetchQueries = false,\n    update: updateWithProxyFn,\n    onQueryUpdated,\n    fetchPolicy = this.defaultOptions.mutate?.fetchPolicy || \"network-only\",\n    errorPolicy = this.defaultOptions.mutate?.errorPolicy || \"none\",\n    keepRootFields,\n    context,\n  }: MutationOptions<TData, TVariables, TContext>): Promise<\n    FetchResult<MaybeMasked<TData>>\n  > {\n    invariant(\n      mutation,\n      \"mutation option is required. You must specify your GraphQL document in the mutation option.\"\n    );\n\n    invariant(\n      fetchPolicy === \"network-only\" || fetchPolicy === \"no-cache\",\n      \"Mutations support only 'network-only' or 'no-cache' fetchPolicy strings. The default `network-only` behavior automatically writes mutation results to the cache. Passing `no-cache` skips the cache write.\"\n    );\n\n    const mutationId = this.generateMutationId();\n\n    mutation = this.cache.transformForLink(this.transform(mutation));\n    const { hasClientExports } = this.getDocumentInfo(mutation);\n\n    variables = this.getVariables(mutation, variables) as TVariables;\n    if (hasClientExports) {\n      variables = (await this.localState.addExportedVariables(\n        mutation,\n        variables,\n        context\n      )) as TVariables;\n    }\n\n    const mutationStoreValue =\n      this.mutationStore &&\n      (this.mutationStore[mutationId] = {\n        mutation,\n        variables,\n        loading: true,\n        error: null,\n      } as MutationStoreValue);\n\n    const isOptimistic =\n      optimisticResponse &&\n      this.markMutationOptimistic<TData, TVariables, TContext, TCache>(\n        optimisticResponse,\n        {\n          mutationId,\n          document: mutation,\n          variables,\n          fetchPolicy,\n          errorPolicy,\n          context,\n          updateQueries,\n          update: updateWithProxyFn,\n          keepRootFields,\n        }\n      );\n\n    this.broadcastQueries();\n\n    const self = this;\n\n    return new Promise((resolve, reject) => {\n      return asyncMap(\n        self.getObservableFromLink(\n          mutation,\n          {\n            ...context,\n            optimisticResponse: isOptimistic ? optimisticResponse : void 0,\n          },\n          variables,\n          {},\n          false\n        ),\n\n        (result: FetchResult<TData>) => {\n          if (graphQLResultHasError(result) && errorPolicy === \"none\") {\n            throw new ApolloError({\n              graphQLErrors: getGraphQLErrorsFromResult(result),\n            });\n          }\n\n          if (mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = null;\n          }\n\n          const storeResult: typeof result = { ...result };\n\n          if (typeof refetchQueries === \"function\") {\n            refetchQueries = refetchQueries(\n              storeResult as FetchResult<Unmasked<TData>>\n            );\n          }\n\n          if (errorPolicy === \"ignore\" && graphQLResultHasError(storeResult)) {\n            delete storeResult.errors;\n          }\n\n          return self.markMutationResult<TData, TVariables, TContext, TCache>({\n            mutationId,\n            result: storeResult,\n            document: mutation,\n            variables,\n            fetchPolicy,\n            errorPolicy,\n            context,\n            update: updateWithProxyFn,\n            updateQueries,\n            awaitRefetchQueries,\n            refetchQueries,\n            removeOptimistic: isOptimistic ? mutationId : void 0,\n            onQueryUpdated,\n            keepRootFields,\n          });\n        }\n      ).subscribe({\n        next(storeResult) {\n          self.broadcastQueries();\n\n          // Since mutations might receive multiple payloads from the\n          // ApolloLink chain (e.g. when used with @defer),\n          // we resolve with a SingleExecutionResult or after the final\n          // ExecutionPatchResult has arrived and we have assembled the\n          // multipart response into a single result.\n          if (!(\"hasNext\" in storeResult) || storeResult.hasNext === false) {\n            resolve({\n              ...storeResult,\n              data: self.maskOperation({\n                document: mutation,\n                data: storeResult.data,\n                fetchPolicy,\n                id: mutationId,\n              }) as any,\n            });\n          }\n        },\n\n        error(err: Error) {\n          if (mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = err;\n          }\n\n          if (isOptimistic) {\n            self.cache.removeOptimistic(mutationId);\n          }\n\n          self.broadcastQueries();\n\n          reject(\n            err instanceof ApolloError ? err : (\n              new ApolloError({\n                networkError: err,\n              })\n            )\n          );\n        },\n      });\n    });\n  }\n\n  public markMutationResult<\n    TData,\n    TVariables,\n    TContext,\n    TCache extends ApolloCache<any>,\n  >(\n    mutation: {\n      mutationId: string;\n      result: FetchResult<TData>;\n      document: DocumentNode;\n      variables?: TVariables;\n      fetchPolicy?: MutationFetchPolicy;\n      errorPolicy: ErrorPolicy;\n      context?: TContext;\n      updateQueries: UpdateQueries<TData>;\n      update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;\n      awaitRefetchQueries?: boolean;\n      refetchQueries?: InternalRefetchQueriesInclude;\n      removeOptimistic?: string;\n      onQueryUpdated?: OnQueryUpdated<any>;\n      keepRootFields?: boolean;\n    },\n    cache = this.cache\n  ): Promise<FetchResult<TData>> {\n    let { result } = mutation;\n    const cacheWrites: Cache.WriteOptions[] = [];\n    const skipCache = mutation.fetchPolicy === \"no-cache\";\n\n    if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\n      if (!isExecutionPatchIncrementalResult(result)) {\n        cacheWrites.push({\n          result: result.data,\n          dataId: \"ROOT_MUTATION\",\n          query: mutation.document,\n          variables: mutation.variables,\n        });\n      }\n      if (\n        isExecutionPatchIncrementalResult(result) &&\n        isNonEmptyArray(result.incremental)\n      ) {\n        const diff = cache.diff<TData>({\n          id: \"ROOT_MUTATION\",\n          // The cache complains if passed a mutation where it expects a\n          // query, so we transform mutations and subscriptions to queries\n          // (only once, thanks to this.transformCache).\n          query: this.getDocumentInfo(mutation.document).asQuery,\n          variables: mutation.variables,\n          optimistic: false,\n          returnPartialData: true,\n        });\n        let mergedData;\n        if (diff.result) {\n          mergedData = mergeIncrementalData(diff.result, result);\n        }\n        if (typeof mergedData !== \"undefined\") {\n          // cast the ExecutionPatchResult to FetchResult here since\n          // ExecutionPatchResult never has `data` when returned from the server\n          (result as FetchResult).data = mergedData;\n          cacheWrites.push({\n            result: mergedData,\n            dataId: \"ROOT_MUTATION\",\n            query: mutation.document,\n            variables: mutation.variables,\n          });\n        }\n      }\n\n      const { updateQueries } = mutation;\n      if (updateQueries) {\n        this.queries.forEach(({ observableQuery }, queryId) => {\n          const queryName = observableQuery && observableQuery.queryName;\n          if (!queryName || !hasOwnProperty.call(updateQueries, queryName)) {\n            return;\n          }\n          const updater = updateQueries[queryName];\n          const { document, variables } = this.queries.get(queryId)!;\n\n          // Read the current query result from the store.\n          const { result: currentQueryResult, complete } = cache.diff<TData>({\n            query: document!,\n            variables,\n            returnPartialData: true,\n            optimistic: false,\n          });\n\n          if (complete && currentQueryResult) {\n            // Run our reducer using the current query result and the mutation result.\n            const nextQueryResult = updater(currentQueryResult, {\n              mutationResult: result as FetchResult<Unmasked<TData>>,\n              queryName: (document && getOperationName(document)) || void 0,\n              queryVariables: variables!,\n            });\n\n            // Write the modified result back into the store if we got a new result.\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: \"ROOT_QUERY\",\n                query: document!,\n                variables,\n              });\n            }\n          }\n        });\n      }\n    }\n\n    if (\n      cacheWrites.length > 0 ||\n      (mutation.refetchQueries || \"\").length > 0 ||\n      mutation.update ||\n      mutation.onQueryUpdated ||\n      mutation.removeOptimistic\n    ) {\n      const results: any[] = [];\n\n      this.refetchQueries({\n        updateCache: (cache) => {\n          if (!skipCache) {\n            cacheWrites.forEach((write) => cache.write(write));\n          }\n\n          // If the mutation has some writes associated with it then we need to\n          // apply those writes to the store by running this reducer again with\n          // a write action.\n          const { update } = mutation;\n          // Determine whether result is a SingleExecutionResult,\n          // or the final ExecutionPatchResult.\n          const isFinalResult =\n            !isExecutionPatchResult(result) ||\n            (isExecutionPatchIncrementalResult(result) && !result.hasNext);\n\n          if (update) {\n            if (!skipCache) {\n              // Re-read the ROOT_MUTATION data we just wrote into the cache\n              // (the first cache.write call in the cacheWrites.forEach loop\n              // above), so field read functions have a chance to run for\n              // fields within mutation result objects.\n              const diff = cache.diff<TData>({\n                id: \"ROOT_MUTATION\",\n                // The cache complains if passed a mutation where it expects a\n                // query, so we transform mutations and subscriptions to queries\n                // (only once, thanks to this.transformCache).\n                query: this.getDocumentInfo(mutation.document).asQuery,\n                variables: mutation.variables,\n                optimistic: false,\n                returnPartialData: true,\n              });\n\n              if (diff.complete) {\n                result = { ...(result as FetchResult), data: diff.result };\n                if (\"incremental\" in result) {\n                  delete result.incremental;\n                }\n                if (\"hasNext\" in result) {\n                  delete result.hasNext;\n                }\n              }\n            }\n\n            // If we've received the whole response,\n            // either a SingleExecutionResult or the final ExecutionPatchResult,\n            // call the update function.\n            if (isFinalResult) {\n              update(cache as TCache, result as FetchResult<Unmasked<TData>>, {\n                context: mutation.context,\n                variables: mutation.variables,\n              });\n            }\n          }\n\n          // TODO Do this with cache.evict({ id: 'ROOT_MUTATION' }) but make it\n          // shallow to allow rolling back optimistic evictions.\n          if (!skipCache && !mutation.keepRootFields && isFinalResult) {\n            cache.modify({\n              id: \"ROOT_MUTATION\",\n              fields(value, { fieldName, DELETE }) {\n                return fieldName === \"__typename\" ? value : DELETE;\n              },\n            });\n          }\n        },\n\n        include: mutation.refetchQueries,\n\n        // Write the final mutation.result to the root layer of the cache.\n        optimistic: false,\n\n        // Remove the corresponding optimistic layer at the same time as we\n        // write the final non-optimistic result.\n        removeOptimistic: mutation.removeOptimistic,\n\n        // Let the caller of client.mutate optionally determine the refetching\n        // behavior for watched queries after the mutation.update function runs.\n        // If no onQueryUpdated function was provided for this mutation, pass\n        // null instead of undefined to disable the default refetching behavior.\n        onQueryUpdated: mutation.onQueryUpdated || null,\n      }).forEach((result) => results.push(result));\n\n      if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n        // Returning a promise here makes the mutation await that promise, so we\n        // include results in that promise's work if awaitRefetchQueries or an\n        // onQueryUpdated function was specified.\n        return Promise.all(results).then(() => result);\n      }\n    }\n\n    return Promise.resolve(result);\n  }\n\n  public markMutationOptimistic<\n    TData,\n    TVariables,\n    TContext,\n    TCache extends ApolloCache<any>,\n  >(\n    optimisticResponse: any,\n    mutation: {\n      mutationId: string;\n      document: DocumentNode;\n      variables?: TVariables;\n      fetchPolicy?: MutationFetchPolicy;\n      errorPolicy: ErrorPolicy;\n      context?: TContext;\n      updateQueries: UpdateQueries<TData>;\n      update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;\n      keepRootFields?: boolean;\n    }\n  ) {\n    const data =\n      typeof optimisticResponse === \"function\" ?\n        optimisticResponse(mutation.variables, { IGNORE })\n      : optimisticResponse;\n\n    if (data === IGNORE) {\n      return false;\n    }\n\n    this.cache.recordOptimisticTransaction((cache) => {\n      try {\n        this.markMutationResult<TData, TVariables, TContext, TCache>(\n          {\n            ...mutation,\n            result: { data },\n          },\n          cache\n        );\n      } catch (error) {\n        invariant.error(error);\n      }\n    }, mutation.mutationId);\n\n    return true;\n  }\n\n  public fetchQuery<TData, TVars extends OperationVariables>(\n    queryId: string,\n    options: WatchQueryOptions<TVars, TData>,\n    networkStatus?: NetworkStatus\n  ): Promise<ApolloQueryResult<TData>> {\n    return this.fetchConcastWithInfo(queryId, options, networkStatus).concast\n      .promise as TODO;\n  }\n\n  public getQueryStore() {\n    const store: Record<string, QueryStoreValue> = Object.create(null);\n    this.queries.forEach((info, queryId) => {\n      store[queryId] = {\n        variables: info.variables,\n        networkStatus: info.networkStatus,\n        networkError: info.networkError,\n        graphQLErrors: info.graphQLErrors,\n      };\n    });\n    return store;\n  }\n\n  public resetErrors(queryId: string) {\n    const queryInfo = this.queries.get(queryId);\n    if (queryInfo) {\n      queryInfo.networkError = undefined;\n      queryInfo.graphQLErrors = [];\n    }\n  }\n\n  public transform(document: DocumentNode) {\n    return this.documentTransform.transformDocument(document);\n  }\n\n  private transformCache = new AutoCleanedWeakCache<\n    DocumentNode,\n    TransformCacheEntry\n  >(\n    cacheSizes[\"queryManager.getDocumentInfo\"] ||\n      defaultCacheSizes[\"queryManager.getDocumentInfo\"]\n  );\n\n  public getDocumentInfo(document: DocumentNode) {\n    const { transformCache } = this;\n\n    if (!transformCache.has(document)) {\n      const cacheEntry: TransformCacheEntry = {\n        // TODO These three calls (hasClientExports, shouldForceResolvers, and\n        // usesNonreactiveDirective) are performing independent full traversals\n        // of the transformed document. We should consider merging these\n        // traversals into a single pass in the future, though the work is\n        // cached after the first time.\n        hasClientExports: hasClientExports(document),\n        hasForcedResolvers: this.localState.shouldForceResolvers(document),\n        hasNonreactiveDirective: hasDirectives([\"nonreactive\"], document),\n        nonReactiveQuery: addNonReactiveToNamedFragments(document),\n        clientQuery: this.localState.clientQuery(document),\n        serverQuery: removeDirectivesFromDocument(\n          [\n            { name: \"client\", remove: true },\n            { name: \"connection\" },\n            { name: \"nonreactive\" },\n            { name: \"unmask\" },\n          ],\n          document\n        ),\n        defaultVars: getDefaultValues(\n          getOperationDefinition(document)\n        ) as OperationVariables,\n        // Transform any mutation or subscription operations to query operations\n        // so we can read/write them from/to the cache.\n        asQuery: {\n          ...document,\n          definitions: document.definitions.map((def) => {\n            if (\n              def.kind === \"OperationDefinition\" &&\n              def.operation !== \"query\"\n            ) {\n              return { ...def, operation: \"query\" as OperationTypeNode };\n            }\n            return def;\n          }),\n        },\n      };\n\n      transformCache.set(document, cacheEntry);\n    }\n\n    return transformCache.get(document)!;\n  }\n\n  private getVariables<TVariables>(\n    document: DocumentNode,\n    variables?: TVariables\n  ): OperationVariables {\n    return {\n      ...this.getDocumentInfo(document).defaultVars,\n      ...variables,\n    };\n  }\n\n  public watchQuery<\n    T,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: WatchQueryOptions<TVariables, T>): ObservableQuery<T, TVariables> {\n    const query = this.transform(options.query);\n\n    // assign variable default values if supplied\n    // NOTE: We don't modify options.query here with the transformed query to\n    // ensure observable.options.query is set to the raw untransformed query.\n    options = {\n      ...options,\n      variables: this.getVariables(query, options.variables) as TVariables,\n    };\n\n    if (typeof options.notifyOnNetworkStatusChange === \"undefined\") {\n      options.notifyOnNetworkStatusChange = false;\n    }\n\n    const queryInfo = new QueryInfo(this);\n    const observable = new ObservableQuery<T, TVariables>({\n      queryManager: this,\n      queryInfo,\n      options,\n    });\n    observable[\"lastQuery\"] = query;\n\n    this.queries.set(observable.queryId, queryInfo);\n\n    // We give queryInfo the transformed query to ensure the first cache diff\n    // uses the transformed query instead of the raw query\n    queryInfo.init({\n      document: query,\n      observableQuery: observable,\n      variables: observable.variables,\n    });\n\n    return observable;\n  }\n\n  public query<TData, TVars extends OperationVariables = OperationVariables>(\n    options: QueryOptions<TVars, TData>,\n    queryId = this.generateQueryId()\n  ): Promise<ApolloQueryResult<MaybeMasked<TData>>> {\n    invariant(\n      options.query,\n      \"query option is required. You must specify your GraphQL document \" +\n        \"in the query option.\"\n    );\n\n    invariant(\n      options.query.kind === \"Document\",\n      'You must wrap the query string in a \"gql\" tag.'\n    );\n\n    invariant(\n      !(options as any).returnPartialData,\n      \"returnPartialData option only supported on watchQuery.\"\n    );\n\n    invariant(\n      !(options as any).pollInterval,\n      \"pollInterval option only supported on watchQuery.\"\n    );\n\n    const query = this.transform(options.query);\n\n    return this.fetchQuery<TData, TVars>(queryId, { ...options, query })\n      .then(\n        (result) =>\n          result && {\n            ...result,\n            data: this.maskOperation({\n              document: query,\n              data: result.data,\n              fetchPolicy: options.fetchPolicy,\n              id: queryId,\n            }),\n          }\n      )\n      .finally(() => this.stopQuery(queryId));\n  }\n\n  private queryIdCounter = 1;\n  public generateQueryId() {\n    return String(this.queryIdCounter++);\n  }\n\n  private requestIdCounter = 1;\n  public generateRequestId() {\n    return this.requestIdCounter++;\n  }\n\n  private mutationIdCounter = 1;\n  public generateMutationId() {\n    return String(this.mutationIdCounter++);\n  }\n\n  public stopQueryInStore(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryInStoreNoBroadcast(queryId: string) {\n    const queryInfo = this.queries.get(queryId);\n    if (queryInfo) queryInfo.stop();\n  }\n\n  public clearStore(\n    options: Cache.ResetOptions = {\n      discardWatches: true,\n    }\n  ): Promise<void> {\n    // Before we have sent the reset action to the store, we can no longer\n    // rely on the results returned by in-flight requests since these may\n    // depend on values that previously existed in the data portion of the\n    // store. So, we cancel the promises and observers that we have issued\n    // so far and not yet resolved (in the case of queries).\n    this.cancelPendingFetches(\n      newInvariantError(\n        \"Store reset while query was in flight (not completed in link chain)\"\n      )\n    );\n\n    this.queries.forEach((queryInfo) => {\n      if (queryInfo.observableQuery) {\n        // Set loading to true so listeners don't trigger unless they want\n        // results with partial data.\n        queryInfo.networkStatus = NetworkStatus.loading;\n      } else {\n        queryInfo.stop();\n      }\n    });\n\n    if (this.mutationStore) {\n      this.mutationStore = Object.create(null);\n    }\n\n    // begin removing data from the store\n    return this.cache.reset(options);\n  }\n\n  public getObservableQueries(\n    include: InternalRefetchQueriesInclude = \"active\"\n  ) {\n    const queries = new Map<string, ObservableQuery<any>>();\n    const queryNames = new Map<string, string | null>();\n    const queryNamesAndQueryStrings = new Map<string, boolean>();\n    const legacyQueryOptions = new Set<QueryOptions>();\n\n    if (Array.isArray(include)) {\n      include.forEach((desc) => {\n        if (typeof desc === \"string\") {\n          queryNames.set(desc, desc);\n          queryNamesAndQueryStrings.set(desc, false);\n        } else if (isDocumentNode(desc)) {\n          const queryString = print(this.transform(desc));\n          queryNames.set(queryString, getOperationName(desc));\n          queryNamesAndQueryStrings.set(queryString, false);\n        } else if (isNonNullObject(desc) && desc.query) {\n          legacyQueryOptions.add(desc);\n        }\n      });\n    }\n\n    this.queries.forEach(({ observableQuery: oq, document }, queryId) => {\n      if (oq) {\n        if (include === \"all\") {\n          queries.set(queryId, oq);\n          return;\n        }\n\n        const {\n          queryName,\n          options: { fetchPolicy },\n        } = oq;\n\n        if (\n          fetchPolicy === \"standby\" ||\n          (include === \"active\" && !oq.hasObservers())\n        ) {\n          return;\n        }\n\n        if (\n          include === \"active\" ||\n          (queryName && queryNamesAndQueryStrings.has(queryName)) ||\n          (document && queryNamesAndQueryStrings.has(print(document)))\n        ) {\n          queries.set(queryId, oq);\n          if (queryName) queryNamesAndQueryStrings.set(queryName, true);\n          if (document) queryNamesAndQueryStrings.set(print(document), true);\n        }\n      }\n    });\n\n    if (legacyQueryOptions.size) {\n      legacyQueryOptions.forEach((options: QueryOptions) => {\n        // We will be issuing a fresh network request for this query, so we\n        // pre-allocate a new query ID here, using a special prefix to enable\n        // cleaning up these temporary queries later, after fetching.\n        const queryId = makeUniqueId(\"legacyOneTimeQuery\");\n        const queryInfo = this.getQuery(queryId).init({\n          document: options.query,\n          variables: options.variables,\n        });\n        const oq = new ObservableQuery({\n          queryManager: this,\n          queryInfo,\n          options: {\n            ...options,\n            fetchPolicy: \"network-only\",\n          },\n        });\n        invariant(oq.queryId === queryId);\n        queryInfo.setObservableQuery(oq);\n        queries.set(queryId, oq);\n      });\n    }\n\n    if (__DEV__ && queryNamesAndQueryStrings.size) {\n      queryNamesAndQueryStrings.forEach((included, nameOrQueryString) => {\n        if (!included) {\n          const queryName = queryNames.get(nameOrQueryString);\n\n          if (queryName) {\n            invariant.warn(\n              `Unknown query named \"%s\" requested in refetchQueries options.include array`,\n              queryName\n            );\n          } else {\n            invariant.warn(\n              `Unknown anonymous query requested in refetchQueries options.include array`\n            );\n          }\n        }\n      });\n    }\n\n    return queries;\n  }\n\n  public reFetchObservableQueries(\n    includeStandby: boolean = false\n  ): Promise<ApolloQueryResult<any>[]> {\n    const observableQueryPromises: Promise<ApolloQueryResult<any>>[] = [];\n\n    this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach(\n      (observableQuery, queryId) => {\n        const { fetchPolicy } = observableQuery.options;\n        observableQuery.resetLastResults();\n        if (\n          includeStandby ||\n          (fetchPolicy !== \"standby\" && fetchPolicy !== \"cache-only\")\n        ) {\n          observableQueryPromises.push(observableQuery.refetch());\n        }\n        this.getQuery(queryId).setDiff(null);\n      }\n    );\n\n    this.broadcastQueries();\n\n    return Promise.all(observableQueryPromises);\n  }\n\n  public setObservableQuery(observableQuery: ObservableQuery<any, any>) {\n    this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);\n  }\n\n  public startGraphQLSubscription<T = any>(\n    options: SubscriptionOptions\n  ): Observable<FetchResult<T>> {\n    let { query, variables } = options;\n    const {\n      fetchPolicy,\n      errorPolicy = \"none\",\n      context = {},\n      extensions = {},\n    } = options;\n\n    query = this.transform(query);\n    variables = this.getVariables(query, variables);\n\n    const makeObservable = (variables: OperationVariables) =>\n      this.getObservableFromLink<T>(query, context, variables, extensions).map(\n        (result) => {\n          if (fetchPolicy !== \"no-cache\") {\n            // the subscription interface should handle not sending us results we no longer subscribe to.\n            // XXX I don't think we ever send in an object with errors, but we might in the future...\n            if (shouldWriteResult(result, errorPolicy)) {\n              this.cache.write({\n                query,\n                result: result.data,\n                dataId: \"ROOT_SUBSCRIPTION\",\n                variables: variables,\n              });\n            }\n\n            this.broadcastQueries();\n          }\n\n          const hasErrors = graphQLResultHasError(result);\n          const hasProtocolErrors = graphQLResultHasProtocolErrors(result);\n          if (hasErrors || hasProtocolErrors) {\n            const errors: ApolloErrorOptions = {};\n            if (hasErrors) {\n              errors.graphQLErrors = result.errors;\n            }\n            if (hasProtocolErrors) {\n              errors.protocolErrors = result.extensions[PROTOCOL_ERRORS_SYMBOL];\n            }\n\n            // `errorPolicy` is a mechanism for handling GraphQL errors, according\n            // to our documentation, so we throw protocol errors regardless of the\n            // set error policy.\n            if (errorPolicy === \"none\" || hasProtocolErrors) {\n              throw new ApolloError(errors);\n            }\n          }\n\n          if (errorPolicy === \"ignore\") {\n            delete result.errors;\n          }\n\n          return result;\n        }\n      );\n\n    if (this.getDocumentInfo(query).hasClientExports) {\n      const observablePromise = this.localState\n        .addExportedVariables(query, variables, context)\n        .then(makeObservable);\n\n      return new Observable<FetchResult<T>>((observer) => {\n        let sub: ObservableSubscription | null = null;\n        observablePromise.then(\n          (observable) => (sub = observable.subscribe(observer)),\n          observer.error\n        );\n        return () => sub && sub.unsubscribe();\n      });\n    }\n\n    return makeObservable(variables);\n  }\n\n  public stopQuery(queryId: string) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryNoBroadcast(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  }\n\n  public removeQuery(queryId: string) {\n    // teardown all links\n    // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n    // that each add their reject functions to fetchCancelFns.\n    // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n    // The same queryId could have two rejection fns for two promises\n    this.fetchCancelFns.delete(queryId);\n    if (this.queries.has(queryId)) {\n      this.getQuery(queryId).stop();\n      this.queries.delete(queryId);\n    }\n  }\n\n  public broadcastQueries() {\n    if (this.onBroadcast) this.onBroadcast();\n    this.queries.forEach((info) => info.notify());\n  }\n\n  public getLocalState(): LocalState<TStore> {\n    return this.localState;\n  }\n\n  // Use protected instead of private field so\n  // @apollo/experimental-nextjs-app-support can access type info.\n  protected inFlightLinkObservables = new Trie<{\n    observable?: Observable<FetchResult<any>>;\n  }>(false);\n\n  private getObservableFromLink<T = any>(\n    query: DocumentNode,\n    context: any,\n    variables?: OperationVariables,\n    extensions?: Record<string, any>,\n    // Prefer context.queryDeduplication if specified.\n    deduplication: boolean = context?.queryDeduplication ??\n      this.queryDeduplication\n  ): Observable<FetchResult<T>> {\n    let observable: Observable<FetchResult<T>> | undefined;\n\n    const { serverQuery, clientQuery } = this.getDocumentInfo(query);\n    if (serverQuery) {\n      const { inFlightLinkObservables, link } = this;\n\n      const operation = {\n        query: serverQuery,\n        variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext({\n          ...context,\n          forceFetch: !deduplication,\n        }),\n        extensions,\n      };\n\n      context = operation.context;\n\n      if (deduplication) {\n        const printedServerQuery = print(serverQuery);\n        const varJson = canonicalStringify(variables);\n\n        const entry = inFlightLinkObservables.lookup(\n          printedServerQuery,\n          varJson\n        );\n\n        observable = entry.observable;\n        if (!observable) {\n          const concast = new Concast([\n            execute(link, operation) as Observable<FetchResult<T>>,\n          ]);\n          observable = entry.observable = concast;\n\n          concast.beforeNext(function cb(method, arg: FetchResult) {\n            if (method === \"next\" && \"hasNext\" in arg && arg.hasNext) {\n              concast.beforeNext(cb);\n            } else {\n              inFlightLinkObservables.remove(printedServerQuery, varJson);\n            }\n          });\n        }\n      } else {\n        observable = new Concast([\n          execute(link, operation) as Observable<FetchResult<T>>,\n        ]);\n      }\n    } else {\n      observable = new Concast([Observable.of({ data: {} } as FetchResult<T>)]);\n      context = this.prepareContext(context);\n    }\n\n    if (clientQuery) {\n      observable = asyncMap(observable, (result) => {\n        return this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context,\n          variables,\n        });\n      });\n    }\n\n    return observable;\n  }\n\n  private getResultsFromLink<TData, TVars extends OperationVariables>(\n    queryInfo: QueryInfo,\n    cacheWriteBehavior: CacheWriteBehavior,\n    options: Pick<\n      WatchQueryOptions<TVars, TData>,\n      \"query\" | \"variables\" | \"context\" | \"fetchPolicy\" | \"errorPolicy\"\n    >\n  ): Observable<ApolloQueryResult<TData>> {\n    const requestId = (queryInfo.lastRequestId = this.generateRequestId());\n\n    // Performing transformForLink here gives this.cache a chance to fill in\n    // missing fragment definitions (for example) before sending this document\n    // through the link chain.\n    const linkDocument = this.cache.transformForLink(options.query);\n\n    return asyncMap(\n      this.getObservableFromLink(\n        linkDocument,\n        options.context,\n        options.variables\n      ),\n\n      (result) => {\n        const graphQLErrors = getGraphQLErrorsFromResult(result);\n        const hasErrors = graphQLErrors.length > 0;\n        const { errorPolicy } = options;\n\n        // If we interrupted this request by calling getResultsFromLink again\n        // with the same QueryInfo object, we ignore the old results.\n        if (requestId >= queryInfo.lastRequestId) {\n          if (hasErrors && errorPolicy === \"none\") {\n            // Throwing here effectively calls observer.error.\n            throw queryInfo.markError(\n              new ApolloError({\n                graphQLErrors,\n              })\n            );\n          }\n          // Use linkDocument rather than queryInfo.document so the\n          // operation/fragments used to write the result are the same as the\n          // ones used to obtain it from the link.\n          queryInfo.markResult(\n            result,\n            linkDocument,\n            options,\n            cacheWriteBehavior\n          );\n          queryInfo.markReady();\n        }\n\n        const aqr: ApolloQueryResult<TData> = {\n          data: result.data,\n          loading: false,\n          networkStatus: NetworkStatus.ready,\n        };\n\n        // In the case we start multiple network requests simulatenously, we\n        // want to ensure we properly set `data` if we're reporting on an old\n        // result which will not be caught by the conditional above that ends up\n        // throwing the markError result.\n        if (hasErrors && errorPolicy === \"none\") {\n          aqr.data = void 0 as TData;\n        }\n\n        if (hasErrors && errorPolicy !== \"ignore\") {\n          aqr.errors = graphQLErrors;\n          aqr.networkStatus = NetworkStatus.error;\n        }\n\n        return aqr;\n      },\n\n      (networkError) => {\n        const error =\n          isApolloError(networkError) ? networkError : (\n            new ApolloError({ networkError })\n          );\n\n        // Avoid storing errors from older interrupted queries.\n        if (requestId >= queryInfo.lastRequestId) {\n          queryInfo.markError(error);\n        }\n\n        throw error;\n      }\n    );\n  }\n\n  private fetchConcastWithInfo<TData, TVars extends OperationVariables>(\n    queryId: string,\n    options: WatchQueryOptions<TVars, TData>,\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus = NetworkStatus.loading,\n    query = options.query\n  ): ConcastAndInfo<TData> {\n    const variables = this.getVariables(query, options.variables) as TVars;\n    const queryInfo = this.getQuery(queryId);\n\n    const defaults = this.defaultOptions.watchQuery;\n    let {\n      fetchPolicy = (defaults && defaults.fetchPolicy) || \"cache-first\",\n      errorPolicy = (defaults && defaults.errorPolicy) || \"none\",\n      returnPartialData = false,\n      notifyOnNetworkStatusChange = false,\n      context = {},\n    } = options;\n\n    const normalized = Object.assign({}, options, {\n      query,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      returnPartialData,\n      notifyOnNetworkStatusChange,\n      context,\n    });\n\n    const fromVariables = (variables: TVars) => {\n      // Since normalized is always a fresh copy of options, it's safe to\n      // modify its properties here, rather than creating yet another new\n      // WatchQueryOptions object.\n      normalized.variables = variables;\n\n      const sourcesWithInfo = this.fetchQueryByPolicy<TData, TVars>(\n        queryInfo,\n        normalized,\n        networkStatus\n      );\n\n      if (\n        // If we're in standby, postpone advancing options.fetchPolicy using\n        // applyNextFetchPolicy.\n        normalized.fetchPolicy !== \"standby\" &&\n        // The \"standby\" policy currently returns [] from fetchQueryByPolicy, so\n        // this is another way to detect when nothing was done/fetched.\n        sourcesWithInfo.sources.length > 0 &&\n        queryInfo.observableQuery\n      ) {\n        queryInfo.observableQuery[\"applyNextFetchPolicy\"](\n          \"after-fetch\",\n          options\n        );\n      }\n\n      return sourcesWithInfo;\n    };\n\n    // This cancel function needs to be set before the concast is created,\n    // in case concast creation synchronously cancels the request.\n    const cleanupCancelFn = () => this.fetchCancelFns.delete(queryId);\n    this.fetchCancelFns.set(queryId, (reason) => {\n      cleanupCancelFn();\n      // This delay ensures the concast variable has been initialized.\n      setTimeout(() => concast.cancel(reason));\n    });\n\n    let concast: Concast<ApolloQueryResult<TData>>,\n      containsDataFromLink: boolean;\n    // If the query has @export(as: ...) directives, then we need to\n    // process those directives asynchronously. When there are no\n    // @export directives (the common case), we deliberately avoid\n    // wrapping the result of this.fetchQueryByPolicy in a Promise,\n    // since the timing of result delivery is (unfortunately) important\n    // for backwards compatibility. TODO This code could be simpler if\n    // we deprecated and removed LocalState.\n    if (this.getDocumentInfo(normalized.query).hasClientExports) {\n      concast = new Concast(\n        this.localState\n          .addExportedVariables(\n            normalized.query,\n            normalized.variables,\n            normalized.context\n          )\n          .then(fromVariables)\n          .then((sourcesWithInfo) => sourcesWithInfo.sources)\n      );\n      // there is just no way we can synchronously get the *right* value here,\n      // so we will assume `true`, which is the behaviour before the bug fix in\n      // #10597. This means that bug is not fixed in that case, and is probably\n      // un-fixable with reasonable effort for the edge case of @export as\n      // directives.\n      containsDataFromLink = true;\n    } else {\n      const sourcesWithInfo = fromVariables(normalized.variables);\n      containsDataFromLink = sourcesWithInfo.fromLink;\n      concast = new Concast(sourcesWithInfo.sources);\n    }\n\n    concast.promise.then(cleanupCancelFn, cleanupCancelFn);\n\n    return {\n      concast,\n      fromLink: containsDataFromLink,\n    };\n  }\n\n  public refetchQueries<TResult>({\n    updateCache,\n    include,\n    optimistic = false,\n    removeOptimistic = optimistic ? makeUniqueId(\"refetchQueries\") : void 0,\n    onQueryUpdated,\n  }: InternalRefetchQueriesOptions<\n    ApolloCache<TStore>,\n    TResult\n  >): InternalRefetchQueriesMap<TResult> {\n    const includedQueriesById = new Map<\n      string,\n      {\n        oq: ObservableQuery<any>;\n        lastDiff?: Cache.DiffResult<any>;\n        diff?: Cache.DiffResult<any>;\n      }\n    >();\n\n    if (include) {\n      this.getObservableQueries(include).forEach((oq, queryId) => {\n        includedQueriesById.set(queryId, {\n          oq,\n          lastDiff: this.getQuery(queryId).getDiff(),\n        });\n      });\n    }\n\n    const results: InternalRefetchQueriesMap<TResult> = new Map();\n\n    if (updateCache) {\n      this.cache.batch({\n        update: updateCache,\n\n        // Since you can perform any combination of cache reads and/or writes in\n        // the cache.batch update function, its optimistic option can be either\n        // a boolean or a string, representing three distinct modes of\n        // operation:\n        //\n        // * false: read/write only the root layer\n        // * true: read/write the topmost layer\n        // * string: read/write a fresh optimistic layer with that ID string\n        //\n        // When typeof optimistic === \"string\", a new optimistic layer will be\n        // temporarily created within cache.batch with that string as its ID. If\n        // we then pass that same string as the removeOptimistic option, we can\n        // make cache.batch immediately remove the optimistic layer after\n        // running the updateCache function, triggering only one broadcast.\n        //\n        // However, the refetchQueries method accepts only true or false for its\n        // optimistic option (not string). We interpret true to mean a temporary\n        // optimistic layer should be created, to allow efficiently rolling back\n        // the effect of the updateCache function, which involves passing a\n        // string instead of true as the optimistic option to cache.batch, when\n        // refetchQueries receives optimistic: true.\n        //\n        // In other words, we are deliberately not supporting the use case of\n        // writing to an *existing* optimistic layer (using the refetchQueries\n        // updateCache function), since that would potentially interfere with\n        // other optimistic updates in progress. Instead, you can read/write\n        // only the root layer by passing optimistic: false to refetchQueries,\n        // or you can read/write a brand new optimistic layer that will be\n        // automatically removed by passing optimistic: true.\n        optimistic: (optimistic && removeOptimistic) || false,\n\n        // The removeOptimistic option can also be provided by itself, even if\n        // optimistic === false, to remove some previously-added optimistic\n        // layer safely and efficiently, like we do in markMutationResult.\n        //\n        // If an explicit removeOptimistic string is provided with optimistic:\n        // true, the removeOptimistic string will determine the ID of the\n        // temporary optimistic layer, in case that ever matters.\n        removeOptimistic,\n\n        onWatchUpdated(watch, diff, lastDiff) {\n          const oq =\n            watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;\n\n          if (oq) {\n            if (onQueryUpdated) {\n              // Since we're about to handle this query now, remove it from\n              // includedQueriesById, in case it was added earlier because of\n              // options.include.\n              includedQueriesById.delete(oq.queryId);\n\n              let result: TResult | boolean | Promise<ApolloQueryResult<any>> =\n                onQueryUpdated(oq, diff, lastDiff);\n\n              if (result === true) {\n                // The onQueryUpdated function requested the default refetching\n                // behavior by returning true.\n                result = oq.refetch();\n              }\n\n              // Record the result in the results Map, as long as onQueryUpdated\n              // did not return false to skip/ignore this result.\n              if (result !== false) {\n                results.set(\n                  oq,\n                  result as InternalRefetchQueriesResult<TResult>\n                );\n              }\n\n              // Allow the default cache broadcast to happen, except when\n              // onQueryUpdated returns false.\n              return result;\n            }\n\n            if (onQueryUpdated !== null) {\n              // If we don't have an onQueryUpdated function, and onQueryUpdated\n              // was not disabled by passing null, make sure this query is\n              // \"included\" like any other options.include-specified query.\n              includedQueriesById.set(oq.queryId, { oq, lastDiff, diff });\n            }\n          }\n        },\n      });\n    }\n\n    if (includedQueriesById.size) {\n      includedQueriesById.forEach(({ oq, lastDiff, diff }, queryId) => {\n        let result:\n          | TResult\n          | boolean\n          | Promise<ApolloQueryResult<any>>\n          | undefined;\n\n        // If onQueryUpdated is provided, we want to use it for all included\n        // queries, even the QueryOptions ones.\n        if (onQueryUpdated) {\n          if (!diff) {\n            const info = oq[\"queryInfo\"];\n            info.reset(); // Force info.getDiff() to read from cache.\n            diff = info.getDiff();\n          }\n          result = onQueryUpdated(oq, diff, lastDiff);\n        }\n\n        // Otherwise, we fall back to refetching.\n        if (!onQueryUpdated || result === true) {\n          result = oq.refetch();\n        }\n\n        if (result !== false) {\n          results.set(oq, result as InternalRefetchQueriesResult<TResult>);\n        }\n\n        if (queryId.indexOf(\"legacyOneTimeQuery\") >= 0) {\n          this.stopQueryNoBroadcast(queryId);\n        }\n      });\n    }\n\n    if (removeOptimistic) {\n      // In case no updateCache callback was provided (so cache.batch was not\n      // called above, and thus did not already remove the optimistic layer),\n      // remove it here. Since this is a no-op when the layer has already been\n      // removed, we do it even if we called cache.batch above, since it's\n      // possible this.cache is an instance of some ApolloCache subclass other\n      // than InMemoryCache, and does not fully support the removeOptimistic\n      // option for cache.batch.\n      this.cache.removeOptimistic(removeOptimistic);\n    }\n\n    return results;\n  }\n\n  private noCacheWarningsByQueryId = new Set<string>();\n\n  public maskOperation<TData = unknown>(\n    options: MaskOperationOptions<TData>\n  ): MaybeMasked<TData> {\n    const { document, data } = options;\n\n    if (__DEV__) {\n      const { fetchPolicy, id } = options;\n      const operationType = getOperationDefinition(document)?.operation;\n      const operationId = (operationType?.[0] ?? \"o\") + id;\n\n      if (\n        this.dataMasking &&\n        fetchPolicy === \"no-cache\" &&\n        !isFullyUnmaskedOperation(document) &&\n        !this.noCacheWarningsByQueryId.has(operationId)\n      ) {\n        this.noCacheWarningsByQueryId.add(operationId);\n\n        invariant.warn(\n          '[%s]: Fragments masked by data masking are inaccessible when using fetch policy \"no-cache\". Please add `@unmask` to each fragment spread to access the data.',\n          getOperationName(document) ??\n            `Unnamed ${operationType ?? \"operation\"}`\n        );\n      }\n    }\n\n    return (\n      this.dataMasking ?\n        maskOperation(data, document, this.cache)\n      : data) as MaybeMasked<TData>;\n  }\n\n  public maskFragment<TData = unknown>(options: MaskFragmentOptions<TData>) {\n    const { data, fragment, fragmentName } = options;\n\n    return this.dataMasking ?\n        maskFragment(data, fragment, this.cache, fragmentName)\n      : data;\n  }\n\n  private fetchQueryByPolicy<TData, TVars extends OperationVariables>(\n    queryInfo: QueryInfo,\n    {\n      query,\n      variables,\n      fetchPolicy,\n      refetchWritePolicy,\n      errorPolicy,\n      returnPartialData,\n      context,\n      notifyOnNetworkStatusChange,\n    }: WatchQueryOptions<TVars, TData>,\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus: NetworkStatus\n  ): SourcesAndInfo<TData> {\n    const oldNetworkStatus = queryInfo.networkStatus;\n\n    queryInfo.init({\n      document: query,\n      variables,\n      networkStatus,\n    });\n\n    const readCache = () => queryInfo.getDiff();\n\n    const resultsFromCache = (\n      diff: Cache.DiffResult<TData>,\n      networkStatus = queryInfo.networkStatus || NetworkStatus.loading\n    ) => {\n      const data = diff.result;\n\n      if (__DEV__ && !returnPartialData && !equal(data, {})) {\n        logMissingFieldErrors(diff.missing);\n      }\n\n      const fromData = (data: TData | undefined) =>\n        Observable.of({\n          data,\n          loading: isNetworkRequestInFlight(networkStatus),\n          networkStatus,\n          ...(diff.complete ? null : { partial: true }),\n        } as ApolloQueryResult<TData>);\n\n      if (data && this.getDocumentInfo(query).hasForcedResolvers) {\n        return this.localState\n          .runResolvers({\n            document: query,\n            remoteResult: { data },\n            context,\n            variables,\n            onlyRunForcedResolvers: true,\n          })\n          .then((resolved) => fromData(resolved.data || void 0));\n      }\n\n      // Resolves https://github.com/apollographql/apollo-client/issues/10317.\n      // If errorPolicy is 'none' and notifyOnNetworkStatusChange is true,\n      // data was incorrectly returned from the cache on refetch:\n      // if diff.missing exists, we should not return cache data.\n      if (\n        errorPolicy === \"none\" &&\n        networkStatus === NetworkStatus.refetch &&\n        Array.isArray(diff.missing)\n      ) {\n        return fromData(void 0);\n      }\n\n      return fromData(data);\n    };\n\n    const cacheWriteBehavior =\n      fetchPolicy === \"no-cache\" ? CacheWriteBehavior.FORBID\n        // Watched queries must opt into overwriting existing data on refetch,\n        // by passing refetchWritePolicy: \"overwrite\" in their WatchQueryOptions.\n      : (\n        networkStatus === NetworkStatus.refetch &&\n        refetchWritePolicy !== \"merge\"\n      ) ?\n        CacheWriteBehavior.OVERWRITE\n      : CacheWriteBehavior.MERGE;\n\n    const resultsFromLink = () =>\n      this.getResultsFromLink<TData, TVars>(queryInfo, cacheWriteBehavior, {\n        query,\n        variables,\n        context,\n        fetchPolicy,\n        errorPolicy,\n      });\n\n    const shouldNotify =\n      notifyOnNetworkStatusChange &&\n      typeof oldNetworkStatus === \"number\" &&\n      oldNetworkStatus !== networkStatus &&\n      isNetworkRequestInFlight(networkStatus);\n\n    switch (fetchPolicy) {\n      default:\n      case \"cache-first\": {\n        const diff = readCache();\n\n        if (diff.complete) {\n          return {\n            fromLink: false,\n            sources: [resultsFromCache(diff, queryInfo.markReady())],\n          };\n        }\n\n        if (returnPartialData || shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(diff), resultsFromLink()],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n      }\n\n      case \"cache-and-network\": {\n        const diff = readCache();\n\n        if (diff.complete || returnPartialData || shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(diff), resultsFromLink()],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n      }\n\n      case \"cache-only\":\n        return {\n          fromLink: false,\n          sources: [resultsFromCache(readCache(), queryInfo.markReady())],\n        };\n\n      case \"network-only\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(readCache()), resultsFromLink()],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n\n      case \"no-cache\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            // Note that queryInfo.getDiff() for no-cache queries does not call\n            // cache.diff, but instead returns a { complete: false } stub result\n            // when there is no queryInfo.diff already defined.\n            sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n\n      case \"standby\":\n        return { fromLink: false, sources: [] };\n    }\n  }\n\n  private getQuery(queryId: string): QueryInfo {\n    if (queryId && !this.queries.has(queryId)) {\n      this.queries.set(queryId, new QueryInfo(this, queryId));\n    }\n    return this.queries.get(queryId)!;\n  }\n\n  private prepareContext(context = {}) {\n    const newContext = this.localState.prepareContext(context);\n    return {\n      ...this.defaultContext,\n      ...newContext,\n      clientAwareness: this.clientAwareness,\n    };\n  }\n}\n\n// Return types used by fetchQueryByPolicy and other private methods above.\ninterface FetchConcastInfo {\n  // Metadata properties that can be returned in addition to the Concast.\n  fromLink: boolean;\n}\ninterface SourcesAndInfo<TData> extends FetchConcastInfo {\n  sources: ConcastSourcesArray<ApolloQueryResult<TData>>;\n}\ninterface ConcastAndInfo<TData> extends FetchConcastInfo {\n  concast: Concast<ApolloQueryResult<TData>>;\n}\n", "import { invariant } from \"../utilities/globals/index.js\";\n\nimport type {\n  DocumentNode,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  SelectionNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n  FieldNode,\n  ASTNode,\n  DirectiveNode,\n  FragmentSpreadNode,\n  ExecutableDefinitionNode,\n} from \"graphql\";\nimport { visit, BREAK, isSelectionNode } from \"graphql\";\n\nimport type { ApolloCache } from \"../cache/index.js\";\nimport type { FragmentMap, StoreObject } from \"../utilities/index.js\";\nimport {\n  argumentsObjectFromField,\n  buildQueryFromSelectionSet,\n  createFragmentMap,\n  getFragmentDefinitions,\n  getMainDefinition,\n  hasDirectives,\n  isField,\n  isInlineFragment,\n  mergeDeep,\n  mergeDeepArray,\n  removeClientSetsFromDocument,\n  resultKeyNameFromField,\n  shouldInclude,\n} from \"../utilities/index.js\";\nimport type { ApolloClient } from \"./ApolloClient.js\";\nimport type { Resolvers, OperationVariables } from \"./types.js\";\nimport type { FetchResult } from \"../link/core/index.js\";\nimport { cacheSlot } from \"../cache/index.js\";\n\nexport type Resolver = (\n  rootValue?: any,\n  args?: any,\n  context?: any,\n  info?: {\n    field: FieldNode;\n    fragmentMap: FragmentMap;\n  }\n) => any;\n\nexport type VariableMap = { [name: string]: any };\n\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: any\n) => boolean;\n\nexport type ExecContext = {\n  fragmentMap: FragmentMap;\n  context: any;\n  variables: VariableMap;\n  fragmentMatcher: FragmentMatcher;\n  defaultOperationType: string;\n  exportedVariables: Record<string, any>;\n  onlyRunForcedResolvers: boolean;\n  selectionsToResolve: Set<SelectionNode>;\n};\n\nexport type LocalStateOptions<TCacheShape> = {\n  cache: ApolloCache<TCacheShape>;\n  client?: ApolloClient<TCacheShape>;\n  resolvers?: Resolvers | Resolvers[];\n  fragmentMatcher?: FragmentMatcher;\n};\n\nexport class LocalState<TCacheShape> {\n  private cache: ApolloCache<TCacheShape>;\n  private client?: ApolloClient<TCacheShape>;\n  private resolvers?: Resolvers;\n  private fragmentMatcher?: FragmentMatcher;\n  private selectionsToResolveCache = new WeakMap<\n    ExecutableDefinitionNode,\n    Set<SelectionNode>\n  >();\n\n  constructor({\n    cache,\n    client,\n    resolvers,\n    fragmentMatcher,\n  }: LocalStateOptions<TCacheShape>) {\n    this.cache = cache;\n\n    if (client) {\n      this.client = client;\n    }\n\n    if (resolvers) {\n      this.addResolvers(resolvers);\n    }\n\n    if (fragmentMatcher) {\n      this.setFragmentMatcher(fragmentMatcher);\n    }\n  }\n\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = this.resolvers || {};\n    if (Array.isArray(resolvers)) {\n      resolvers.forEach((resolverGroup) => {\n        this.resolvers = mergeDeep(this.resolvers, resolverGroup);\n      });\n    } else {\n      this.resolvers = mergeDeep(this.resolvers, resolvers);\n    }\n  }\n\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = {};\n    this.addResolvers(resolvers);\n  }\n\n  public getResolvers() {\n    return this.resolvers || {};\n  }\n\n  // Run local client resolvers against the incoming query and remote data.\n  // Locally resolved field values are merged with the incoming remote data,\n  // and returned. Note that locally resolved fields will overwrite\n  // remote data using the same field name.\n  public async runResolvers<TData>({\n    document,\n    remoteResult,\n    context,\n    variables,\n    onlyRunForcedResolvers = false,\n  }: {\n    document: DocumentNode | null;\n    remoteResult: FetchResult<TData>;\n    context?: Record<string, any>;\n    variables?: Record<string, any>;\n    onlyRunForcedResolvers?: boolean;\n  }): Promise<FetchResult<TData>> {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        remoteResult.data,\n        context,\n        variables,\n        this.fragmentMatcher,\n        onlyRunForcedResolvers\n      ).then((localResult) => ({\n        ...remoteResult,\n        data: localResult.result,\n      }));\n    }\n\n    return remoteResult;\n  }\n\n  public setFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.fragmentMatcher = fragmentMatcher;\n  }\n\n  public getFragmentMatcher(): FragmentMatcher | undefined {\n    return this.fragmentMatcher;\n  }\n\n  // Client queries contain everything in the incoming document (if a @client\n  // directive is found).\n  public clientQuery(document: DocumentNode) {\n    if (hasDirectives([\"client\"], document)) {\n      if (this.resolvers) {\n        return document;\n      }\n    }\n    return null;\n  }\n\n  // Server queries are stripped of all @client based selection sets.\n  public serverQuery(document: DocumentNode) {\n    return removeClientSetsFromDocument(document);\n  }\n\n  public prepareContext(context?: Record<string, any>) {\n    const { cache } = this;\n    return {\n      ...context,\n      cache,\n      // Getting an entry's cache key is useful for local state resolvers.\n      getCacheKey(obj: StoreObject) {\n        return cache.identify(obj);\n      },\n    };\n  }\n\n  // To support `@client @export(as: \"someVar\")` syntax, we'll first resolve\n  // @client @export fields locally, then pass the resolved values back to be\n  // used alongside the original operation variables.\n  public async addExportedVariables<TVars extends OperationVariables>(\n    document: DocumentNode,\n    variables: TVars = {} as TVars,\n    context = {}\n  ): /* returns at least the variables that were passed in */ Promise<TVars> {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        this.buildRootValueFromCache(document, variables) || {},\n        this.prepareContext(context),\n        variables\n      ).then((data) => ({\n        ...variables,\n        ...data.exportedVariables,\n      }));\n    }\n\n    return {\n      ...variables,\n    };\n  }\n\n  public shouldForceResolvers(document: ASTNode) {\n    let forceResolvers = false;\n    visit(document, {\n      Directive: {\n        enter(node) {\n          if (node.name.value === \"client\" && node.arguments) {\n            forceResolvers = node.arguments.some(\n              (arg) =>\n                arg.name.value === \"always\" &&\n                arg.value.kind === \"BooleanValue\" &&\n                arg.value.value === true\n            );\n            if (forceResolvers) {\n              return BREAK;\n            }\n          }\n        },\n      },\n    });\n    return forceResolvers;\n  }\n\n  // Query the cache and return matching data.\n  private buildRootValueFromCache(\n    document: DocumentNode,\n    variables?: Record<string, any>\n  ) {\n    return this.cache.diff({\n      query: buildQueryFromSelectionSet(document),\n      variables,\n      returnPartialData: true,\n      optimistic: false,\n    }).result;\n  }\n\n  private async resolveDocument<TData>(\n    document: DocumentNode,\n    rootValue: TData,\n    context: any = {},\n    variables: VariableMap = {},\n    fragmentMatcher: FragmentMatcher = () => true,\n    onlyRunForcedResolvers: boolean = false\n  ) {\n    const mainDefinition = getMainDefinition(\n      document\n    ) as OperationDefinitionNode;\n    const fragments = getFragmentDefinitions(document);\n    const fragmentMap = createFragmentMap(fragments);\n    const selectionsToResolve = this.collectSelectionsToResolve(\n      mainDefinition,\n      fragmentMap\n    );\n\n    const definitionOperation = mainDefinition.operation;\n\n    const defaultOperationType =\n      definitionOperation ?\n        definitionOperation.charAt(0).toUpperCase() +\n        definitionOperation.slice(1)\n      : \"Query\";\n\n    const { cache, client } = this;\n    const execContext: ExecContext = {\n      fragmentMap,\n      context: {\n        ...context,\n        cache,\n        client,\n      },\n      variables,\n      fragmentMatcher,\n      defaultOperationType,\n      exportedVariables: {},\n      selectionsToResolve,\n      onlyRunForcedResolvers,\n    };\n    const isClientFieldDescendant = false;\n\n    return this.resolveSelectionSet(\n      mainDefinition.selectionSet,\n      isClientFieldDescendant,\n      rootValue,\n      execContext\n    ).then((result) => ({\n      result,\n      exportedVariables: execContext.exportedVariables,\n    }));\n  }\n\n  private async resolveSelectionSet<TData>(\n    selectionSet: SelectionSetNode,\n    isClientFieldDescendant: boolean,\n    rootValue: TData,\n    execContext: ExecContext\n  ) {\n    const { fragmentMap, context, variables } = execContext;\n    const resultsToMerge: TData[] = [rootValue];\n\n    const execute = async (selection: SelectionNode): Promise<void> => {\n      if (\n        !isClientFieldDescendant &&\n        !execContext.selectionsToResolve.has(selection)\n      ) {\n        // Skip selections without @client directives\n        // (still processing if one of the ancestors or one of the child fields has @client directive)\n        return;\n      }\n      if (!shouldInclude(selection, variables)) {\n        // Skip this entirely.\n        return;\n      }\n\n      if (isField(selection)) {\n        return this.resolveField(\n          selection,\n          isClientFieldDescendant,\n          rootValue,\n          execContext\n        ).then((fieldResult) => {\n          if (typeof fieldResult !== \"undefined\") {\n            resultsToMerge.push({\n              [resultKeyNameFromField(selection)]: fieldResult,\n            } as TData);\n          }\n        });\n      }\n\n      let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // This is a named fragment.\n        fragment = fragmentMap[selection.name.value];\n        invariant(fragment, `No fragment named %s`, selection.name.value);\n      }\n\n      if (fragment && fragment.typeCondition) {\n        const typeCondition = fragment.typeCondition.name.value;\n        if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n          return this.resolveSelectionSet(\n            fragment.selectionSet,\n            isClientFieldDescendant,\n            rootValue,\n            execContext\n          ).then((fragmentResult) => {\n            resultsToMerge.push(fragmentResult);\n          });\n        }\n      }\n    };\n\n    return Promise.all(selectionSet.selections.map(execute)).then(function () {\n      return mergeDeepArray(resultsToMerge);\n    });\n  }\n\n  private async resolveField(\n    field: FieldNode,\n    isClientFieldDescendant: boolean,\n    rootValue: any,\n    execContext: ExecContext\n  ): Promise<any> {\n    if (!rootValue) {\n      return null;\n    }\n\n    const { variables } = execContext;\n    const fieldName = field.name.value;\n    const aliasedFieldName = resultKeyNameFromField(field);\n    const aliasUsed = fieldName !== aliasedFieldName;\n    const defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n    let resultPromise = Promise.resolve(defaultResult);\n\n    // Usually all local resolvers are run when passing through here, but\n    // if we've specifically identified that we only want to run forced\n    // resolvers (that is, resolvers for fields marked with\n    // `@client(always: true)`), then we'll skip running non-forced resolvers.\n    if (\n      !execContext.onlyRunForcedResolvers ||\n      this.shouldForceResolvers(field)\n    ) {\n      const resolverType =\n        rootValue.__typename || execContext.defaultOperationType;\n      const resolverMap = this.resolvers && this.resolvers[resolverType];\n      if (resolverMap) {\n        const resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n        if (resolve) {\n          resultPromise = Promise.resolve(\n            // In case the resolve function accesses reactive variables,\n            // set cacheSlot to the current cache instance.\n            cacheSlot.withValue(this.cache, resolve, [\n              rootValue,\n              argumentsObjectFromField(field, variables),\n              execContext.context,\n              { field, fragmentMap: execContext.fragmentMap },\n            ])\n          );\n        }\n      }\n    }\n\n    return resultPromise.then((result = defaultResult) => {\n      // If an @export directive is associated with the current field, store\n      // the `as` export variable name and current result for later use.\n      if (field.directives) {\n        field.directives.forEach((directive) => {\n          if (directive.name.value === \"export\" && directive.arguments) {\n            directive.arguments.forEach((arg) => {\n              if (arg.name.value === \"as\" && arg.value.kind === \"StringValue\") {\n                execContext.exportedVariables[arg.value.value] = result;\n              }\n            });\n          }\n        });\n      }\n\n      // Handle all scalar types here.\n      if (!field.selectionSet) {\n        return result;\n      }\n\n      // From here down, the field has a selection set, which means it's trying\n      // to query a GraphQLObjectType.\n      if (result == null) {\n        // Basically any field in a GraphQL response can be null, or missing\n        return result;\n      }\n\n      const isClientField =\n        field.directives?.some((d) => d.name.value === \"client\") ?? false;\n\n      if (Array.isArray(result)) {\n        return this.resolveSubSelectedArray(\n          field,\n          isClientFieldDescendant || isClientField,\n          result,\n          execContext\n        );\n      }\n\n      // Returned value is an object, and the query has a sub-selection. Recurse.\n      if (field.selectionSet) {\n        return this.resolveSelectionSet(\n          field.selectionSet,\n          isClientFieldDescendant || isClientField,\n          result,\n          execContext\n        );\n      }\n    });\n  }\n\n  private resolveSubSelectedArray(\n    field: FieldNode,\n    isClientFieldDescendant: boolean,\n    result: any[],\n    execContext: ExecContext\n  ): any {\n    return Promise.all(\n      result.map((item) => {\n        if (item === null) {\n          return null;\n        }\n\n        // This is a nested array, recurse.\n        if (Array.isArray(item)) {\n          return this.resolveSubSelectedArray(\n            field,\n            isClientFieldDescendant,\n            item,\n            execContext\n          );\n        }\n\n        // This is an object, run the selection set on it.\n        if (field.selectionSet) {\n          return this.resolveSelectionSet(\n            field.selectionSet,\n            isClientFieldDescendant,\n            item,\n            execContext\n          );\n        }\n      })\n    );\n  }\n\n  // Collect selection nodes on paths from document root down to all @client directives.\n  // This function takes into account transitive fragment spreads.\n  // Complexity equals to a single `visit` over the full document.\n  private collectSelectionsToResolve(\n    mainDefinition: OperationDefinitionNode,\n    fragmentMap: FragmentMap\n  ): Set<SelectionNode> {\n    const isSingleASTNode = (\n      node: ASTNode | readonly ASTNode[]\n    ): node is ASTNode => !Array.isArray(node);\n    const selectionsToResolveCache = this.selectionsToResolveCache;\n\n    function collectByDefinition(\n      definitionNode: ExecutableDefinitionNode\n    ): Set<SelectionNode> {\n      if (!selectionsToResolveCache.has(definitionNode)) {\n        const matches = new Set<SelectionNode>();\n        selectionsToResolveCache.set(definitionNode, matches);\n\n        visit(definitionNode, {\n          Directive(node: DirectiveNode, _, __, ___, ancestors) {\n            if (node.name.value === \"client\") {\n              ancestors.forEach((node) => {\n                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                  matches.add(node);\n                }\n              });\n            }\n          },\n          FragmentSpread(spread: FragmentSpreadNode, _, __, ___, ancestors) {\n            const fragment = fragmentMap[spread.name.value];\n            invariant(fragment, `No fragment named %s`, spread.name.value);\n\n            const fragmentSelections = collectByDefinition(fragment);\n            if (fragmentSelections.size > 0) {\n              // Fragment for this spread contains @client directive (either directly or transitively)\n              // Collect selection nodes on paths from the root down to fields with the @client directive\n              ancestors.forEach((node) => {\n                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                  matches.add(node);\n                }\n              });\n              matches.add(spread);\n              fragmentSelections.forEach((selection) => {\n                matches.add(selection);\n              });\n            }\n          },\n        });\n      }\n      return selectionsToResolveCache.get(definitionNode)!;\n    }\n    return collectByDefinition(mainDefinition);\n  }\n}\n", "import { invariant, newInvariantError } from \"../utilities/globals/index.js\";\n\nimport type { DocumentNode, FormattedExecutionResult } from \"graphql\";\n\nimport type { FetchResult, GraphQLRequest } from \"../link/core/index.js\";\nimport { ApolloLink, execute } from \"../link/core/index.js\";\nimport type { ApolloCache, DataProxy, Reference } from \"../cache/index.js\";\nimport type { DocumentTransform } from \"../utilities/index.js\";\nimport type { Observable } from \"../utilities/index.js\";\nimport { version } from \"../version.js\";\nimport type { UriFunction } from \"../link/http/index.js\";\nimport { HttpLink } from \"../link/http/index.js\";\n\nimport { QueryManager } from \"./QueryManager.js\";\nimport type { ObservableQuery } from \"./ObservableQuery.js\";\n\nimport type {\n  ApolloQueryResult,\n  DefaultContext,\n  OperationVariables,\n  Resolvers,\n  RefetchQueriesOptions,\n  RefetchQueriesResult,\n  InternalRefetchQueriesResult,\n  RefetchQueriesInclude,\n} from \"./types.js\";\n\nimport type {\n  QueryOptions,\n  WatchQueryOptions,\n  MutationOptions,\n  SubscriptionOptions,\n  WatchQueryFetchPolicy,\n} from \"./watchQueryOptions.js\";\n\nimport type { FragmentMatcher } from \"./LocalState.js\";\nimport { LocalState } from \"./LocalState.js\";\n\nexport interface DefaultOptions {\n  watchQuery?: Partial<WatchQueryOptions<any, any>>;\n  query?: Partial<QueryOptions<any, any>>;\n  mutate?: Partial<MutationOptions<any, any, any>>;\n}\n\nexport interface DevtoolsOptions {\n  /**\n   * If `true`, the [Apollo Client Devtools](https://www.apollographql.com/docs/react/development-testing/developer-tooling/#apollo-client-devtools) browser extension can connect to this `ApolloClient` instance.\n   *\n   * The default value is `false` in production and `true` in development if there is a `window` object.\n   */\n  enabled?: boolean;\n\n  /**\n   * Optional name for this `ApolloClient` instance in the devtools. This is\n   * useful when you instantiate multiple clients and want to be able to\n   * identify them by name.\n   */\n  name?: string;\n}\n\nlet hasSuggestedDevtools = false;\n\nexport interface ApolloClientOptions<TCacheShape> {\n  /**\n   * The URI of the GraphQL endpoint that Apollo Client will communicate with.\n   *\n   * One of `uri` or `link` is **required**. If you provide both, `link` takes precedence.\n   */\n  uri?: string | UriFunction;\n  credentials?: string;\n  /**\n   * An object representing headers to include in every HTTP request, such as `{Authorization: 'Bearer 1234'}`\n   *\n   * This value will be ignored when using the `link` option.\n   */\n  headers?: Record<string, string>;\n  /**\n   * You can provide an `ApolloLink` instance to serve as Apollo Client's network layer. For more information, see [Advanced HTTP networking](https://www.apollographql.com/docs/react/networking/advanced-http-networking/).\n   *\n   * One of `uri` or `link` is **required**. If you provide both, `link` takes precedence.\n   */\n  link?: ApolloLink;\n  /**\n   * The cache that Apollo Client should use to store query results locally. The recommended cache is `InMemoryCache`, which is provided by the `@apollo/client` package.\n   *\n   * For more information, see [Configuring the cache](https://www.apollographql.com/docs/react/caching/cache-configuration/).\n   */\n  cache: ApolloCache<TCacheShape>;\n  /**\n   * The time interval (in milliseconds) before Apollo Client force-fetches queries after a server-side render.\n   *\n   * @defaultValue `0` (no delay)\n   */\n  ssrForceFetchDelay?: number;\n  /**\n   * When using Apollo Client for [server-side rendering](https://www.apollographql.com/docs/react/performance/server-side-rendering/), set this to `true` so that the [`getDataFromTree` function](../react/ssr/#getdatafromtree) can work effectively.\n   *\n   * @defaultValue `false`\n   */\n  ssrMode?: boolean;\n  /**\n   * If `true`, the [Apollo Client Devtools](https://www.apollographql.com/docs/react/development-testing/developer-tooling/#apollo-client-devtools) browser extension can connect to Apollo Client.\n   *\n   * The default value is `false` in production and `true` in development (if there is a `window` object).\n   * @deprecated Please use the `devtools.enabled` option.\n   */\n  connectToDevTools?: boolean;\n  /**\n   * If `false`, Apollo Client sends every created query to the server, even if a _completely_ identical query (identical in terms of query string, variable values, and operationName) is already in flight.\n   *\n   * @defaultValue `true`\n   */\n  queryDeduplication?: boolean;\n  /**\n   * Provide this object to set application-wide default values for options you can provide to the `watchQuery`, `query`, and `mutate` functions. See below for an example object.\n   *\n   * See this [example object](https://www.apollographql.com/docs/react/api/core/ApolloClient#example-defaultoptions-object).\n   */\n  defaultOptions?: DefaultOptions;\n  defaultContext?: Partial<DefaultContext>;\n  /**\n   * If `true`, Apollo Client will assume results read from the cache are never mutated by application code, which enables substantial performance optimizations.\n   *\n   * @defaultValue `false`\n   */\n  assumeImmutableResults?: boolean;\n  resolvers?: Resolvers | Resolvers[];\n  typeDefs?: string | string[] | DocumentNode | DocumentNode[];\n  fragmentMatcher?: FragmentMatcher;\n  /**\n   * A custom name (e.g., `iOS`) that identifies this particular client among your set of clients. Apollo Server and Apollo Studio use this property as part of the [client awareness](https://www.apollographql.com/docs/apollo-server/monitoring/metrics#identifying-distinct-clients) feature.\n   */\n  name?: string;\n  /**\n   * A custom version that identifies the current version of this particular client (e.g., `1.2`). Apollo Server and Apollo Studio use this property as part of the [client awareness](https://www.apollographql.com/docs/apollo-server/monitoring/metrics#identifying-distinct-clients) feature.\n   *\n   * This is **not** the version of Apollo Client that you are using, but rather any version string that helps you differentiate between versions of your client.\n   */\n  version?: string;\n  documentTransform?: DocumentTransform;\n\n  /**\n   * Configuration used by the [Apollo Client Devtools extension](https://www.apollographql.com/docs/react/development-testing/developer-tooling/#apollo-client-devtools) for this client.\n   *\n   * @since 3.11.0\n   */\n  devtools?: DevtoolsOptions;\n\n  /**\n   * Determines if data masking is enabled for the client.\n   *\n   * @defaultValue false\n   */\n  dataMasking?: boolean;\n}\n\n// Though mergeOptions now resides in @apollo/client/utilities, it was\n// previously declared and exported from this module, and then reexported from\n// @apollo/client/core. Since we need to preserve that API anyway, the easiest\n// solution is to reexport mergeOptions where it was previously declared (here).\nimport { mergeOptions } from \"../utilities/index.js\";\nimport { getApolloClientMemoryInternals } from \"../utilities/caching/getMemoryInternals.js\";\nimport type {\n  WatchFragmentOptions,\n  WatchFragmentResult,\n} from \"../cache/core/cache.js\";\nimport type { MaybeMasked, Unmasked } from \"../masking/index.js\";\nexport { mergeOptions };\n\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over an `ApolloLink` instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through `Observable` instances.\n */\nexport class ApolloClient<TCacheShape> implements DataProxy {\n  public link: ApolloLink;\n  public cache: ApolloCache<TCacheShape>;\n  public disableNetworkFetches: boolean;\n  public version: string;\n  public queryDeduplication: boolean;\n  public defaultOptions: DefaultOptions;\n  public readonly typeDefs: ApolloClientOptions<TCacheShape>[\"typeDefs\"];\n  public readonly devtoolsConfig: DevtoolsOptions;\n\n  private queryManager: QueryManager<TCacheShape>;\n  private devToolsHookCb?: Function;\n  private resetStoreCallbacks: Array<() => Promise<any>> = [];\n  private clearStoreCallbacks: Array<() => Promise<any>> = [];\n  private localState: LocalState<TCacheShape>;\n\n  /**\n   * Constructs an instance of `ApolloClient`.\n   *\n   * @example\n   * ```js\n   * import { ApolloClient, InMemoryCache } from '@apollo/client';\n   *\n   * const cache = new InMemoryCache();\n   *\n   * const client = new ApolloClient({\n   *   // Provide required constructor fields\n   *   cache: cache,\n   *   uri: 'http://localhost:4000/',\n   *\n   *   // Provide some optional constructor fields\n   *   name: 'react-web-client',\n   *   version: '1.3',\n   *   queryDeduplication: false,\n   *   defaultOptions: {\n   *     watchQuery: {\n   *       fetchPolicy: 'cache-and-network',\n   *     },\n   *   },\n   * });\n   * ```\n   */\n  constructor(options: ApolloClientOptions<TCacheShape>) {\n    if (!options.cache) {\n      throw newInvariantError(\n        \"To initialize Apollo Client, you must specify a 'cache' property \" +\n          \"in the options object. \\n\" +\n          \"For more information, please visit: https://go.apollo.dev/c/docs\"\n      );\n    }\n\n    const {\n      uri,\n      credentials,\n      headers,\n      cache,\n      documentTransform,\n      ssrMode = false,\n      ssrForceFetchDelay = 0,\n      // Expose the client instance as window.__APOLLO_CLIENT__ and call\n      // onBroadcast in queryManager.broadcastQueries to enable browser\n      // devtools, but disable them by default in production.\n      connectToDevTools,\n      queryDeduplication = true,\n      defaultOptions,\n      defaultContext,\n      assumeImmutableResults = cache.assumeImmutableResults,\n      resolvers,\n      typeDefs,\n      fragmentMatcher,\n      name: clientAwarenessName,\n      version: clientAwarenessVersion,\n      devtools,\n      dataMasking,\n    } = options;\n\n    let { link } = options;\n\n    if (!link) {\n      link =\n        uri ? new HttpLink({ uri, credentials, headers }) : ApolloLink.empty();\n    }\n\n    this.link = link;\n    this.cache = cache;\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.defaultOptions = defaultOptions || Object.create(null);\n    this.typeDefs = typeDefs;\n    this.devtoolsConfig = {\n      ...devtools,\n      enabled: devtools?.enabled ?? connectToDevTools,\n    };\n\n    if (this.devtoolsConfig.enabled === undefined) {\n      this.devtoolsConfig.enabled = __DEV__;\n    }\n\n    if (ssrForceFetchDelay) {\n      setTimeout(\n        () => (this.disableNetworkFetches = false),\n        ssrForceFetchDelay\n      );\n    }\n\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.watchFragment = this.watchFragment.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n\n    this.version = version;\n\n    this.localState = new LocalState({\n      cache,\n      client: this,\n      resolvers,\n      fragmentMatcher,\n    });\n\n    this.queryManager = new QueryManager({\n      cache: this.cache,\n      link: this.link,\n      defaultOptions: this.defaultOptions,\n      defaultContext,\n      documentTransform,\n      queryDeduplication,\n      ssrMode,\n      dataMasking: !!dataMasking,\n      clientAwareness: {\n        name: clientAwarenessName!,\n        version: clientAwarenessVersion!,\n      },\n      localState: this.localState,\n      assumeImmutableResults,\n      onBroadcast:\n        this.devtoolsConfig.enabled ?\n          () => {\n            if (this.devToolsHookCb) {\n              this.devToolsHookCb({\n                action: {},\n                state: {\n                  queries: this.queryManager.getQueryStore(),\n                  mutations: this.queryManager.mutationStore || {},\n                },\n                dataWithOptimisticResults: this.cache.extract(true),\n              });\n            }\n          }\n        : void 0,\n    });\n\n    if (this.devtoolsConfig.enabled) this.connectToDevTools();\n  }\n\n  private connectToDevTools() {\n    if (typeof window === \"undefined\") {\n      return;\n    }\n\n    type DevToolsConnector = {\n      push(client: ApolloClient<any>): void;\n    };\n    const windowWithDevTools = window as Window & {\n      [devtoolsSymbol]?: DevToolsConnector;\n      __APOLLO_CLIENT__?: ApolloClient<any>;\n    };\n    const devtoolsSymbol = Symbol.for(\"apollo.devtools\");\n    (windowWithDevTools[devtoolsSymbol] =\n      windowWithDevTools[devtoolsSymbol] || ([] as DevToolsConnector)).push(\n      this\n    );\n    windowWithDevTools.__APOLLO_CLIENT__ = this;\n\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n    if (!hasSuggestedDevtools && __DEV__) {\n      hasSuggestedDevtools = true;\n      if (\n        window.document &&\n        window.top === window.self &&\n        /^(https?|file):$/.test(window.location.protocol)\n      ) {\n        setTimeout(() => {\n          if (!(window as any).__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {\n            const nav = window.navigator;\n            const ua = nav && nav.userAgent;\n            let url: string | undefined;\n            if (typeof ua === \"string\") {\n              if (ua.indexOf(\"Chrome/\") > -1) {\n                url =\n                  \"https://chrome.google.com/webstore/detail/\" +\n                  \"apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\";\n              } else if (ua.indexOf(\"Firefox/\") > -1) {\n                url =\n                  \"https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/\";\n              }\n            }\n            if (url) {\n              invariant.log(\n                \"Download the Apollo DevTools for a better development \" +\n                  \"experience: %s\",\n                url\n              );\n            }\n          }\n        }, 10000);\n      }\n    }\n  }\n\n  /**\n   * The `DocumentTransform` used to modify GraphQL documents before a request\n   * is made. If a custom `DocumentTransform` is not provided, this will be the\n   * default document transform.\n   */\n  get documentTransform() {\n    return this.queryManager.documentTransform;\n  }\n\n  /**\n   * Call this method to terminate any active client processes, making it safe\n   * to dispose of this `ApolloClient` instance.\n   */\n  public stop() {\n    this.queryManager.stop();\n  }\n\n  /**\n   * This watches the cache store of the query according to the options specified and\n   * returns an `ObservableQuery`. We can subscribe to this `ObservableQuery` and\n   * receive updated results through an observer when the cache store changes.\n   *\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   *\n   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n   * first and last name and this person has a particular object identifier, provided by\n   * dataIdFromObject. Later, a different query fetches that same person's\n   * first and last name and the first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   *\n   * Note that if the cache does not change, the subscriber will *not* be notified.\n   *\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   */\n  public watchQuery<\n    T = any,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: WatchQueryOptions<TVariables, T>): ObservableQuery<T, TVariables> {\n    if (this.defaultOptions.watchQuery) {\n      options = mergeOptions(this.defaultOptions.watchQuery, options);\n    }\n\n    // XXX Overwriting options is probably not the best way to do this long term...\n    if (\n      this.disableNetworkFetches &&\n      (options.fetchPolicy === \"network-only\" ||\n        options.fetchPolicy === \"cache-and-network\")\n    ) {\n      options = { ...options, fetchPolicy: \"cache-first\" };\n    }\n\n    return this.queryManager.watchQuery<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single query according to the options specified and\n   * returns a `Promise` which is either resolved with the resulting data\n   * or rejected with an error.\n   *\n   * @param options - An object of type `QueryOptions` that allows us to\n   * describe how this query should be treated e.g. whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n  public query<\n    T = any,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: QueryOptions<TVariables, T>\n  ): Promise<ApolloQueryResult<MaybeMasked<T>>> {\n    if (this.defaultOptions.query) {\n      options = mergeOptions(this.defaultOptions.query, options);\n    }\n\n    invariant(\n      (options.fetchPolicy as WatchQueryFetchPolicy) !== \"cache-and-network\",\n      \"The cache-and-network fetchPolicy does not work with client.query, because \" +\n        \"client.query can only return a single result. Please use client.watchQuery \" +\n        \"to receive multiple results from the cache and the network, or consider \" +\n        \"using a different fetchPolicy, such as cache-first or network-only.\"\n    );\n\n    if (this.disableNetworkFetches && options.fetchPolicy === \"network-only\") {\n      options = { ...options, fetchPolicy: \"cache-first\" };\n    }\n\n    return this.queryManager.query<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * Promise which is either resolved with the resulting data or rejected with an\n   * error. In some cases both `data` and `errors` might be undefined, for example\n   * when `errorPolicy` is set to `'ignore'`.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n  public mutate<\n    TData = any,\n    TVariables extends OperationVariables = OperationVariables,\n    TContext extends Record<string, any> = DefaultContext,\n    TCache extends ApolloCache<any> = ApolloCache<any>,\n  >(\n    options: MutationOptions<TData, TVariables, TContext>\n  ): Promise<FetchResult<MaybeMasked<TData>>> {\n    if (this.defaultOptions.mutate) {\n      options = mergeOptions(this.defaultOptions.mutate, options);\n    }\n    return this.queryManager.mutate<TData, TVariables, TContext, TCache>(\n      options\n    );\n  }\n\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * `Observable` which either emits received data or an error.\n   */\n  public subscribe<\n    T = any,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: SubscriptionOptions<TVariables, T>\n  ): Observable<FetchResult<MaybeMasked<T>>> {\n    const id = this.queryManager.generateQueryId();\n\n    return this.queryManager\n      .startGraphQLSubscription<T>(options)\n      .map((result) => ({\n        ...result,\n        data: this.queryManager.maskOperation({\n          document: options.query,\n          data: result.data,\n          fetchPolicy: options.fetchPolicy,\n          id,\n        }),\n      }));\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL query without making a network request. This method will start at\n   * the root query. To start at a specific id returned by `dataIdFromObject`\n   * use `readFragment`.\n   *\n   * @param optimistic - Set to `true` to allow `readQuery` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readQuery<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Query<TVariables, T>,\n    optimistic: boolean = false\n  ): Unmasked<T> | null {\n    return this.cache.readQuery<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Watches the cache store of the fragment according to the options specified\n   * and returns an `Observable`. We can subscribe to this\n   * `Observable` and receive updated results through an\n   * observer when the cache store changes.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @since 3.10.0\n   * @param options - An object of type `WatchFragmentOptions` that allows\n   * the cache to identify the fragment and optionally specify whether to react\n   * to optimistic updates.\n   */\n\n  public watchFragment<\n    TFragmentData = unknown,\n    TVariables = OperationVariables,\n  >(\n    options: WatchFragmentOptions<TFragmentData, TVariables>\n  ): Observable<WatchFragmentResult<TFragmentData>> {\n    return this.cache.watchFragment({\n      ...options,\n      [Symbol.for(\"apollo.dataMasking\")]: this.queryManager.dataMasking,\n    });\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL fragment without making a network request. This method will read a\n   * GraphQL fragment from any arbitrary id that is currently cached, unlike\n   * `readQuery` which will only read from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @param optimistic - Set to `true` to allow `readFragment` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readFragment<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Fragment<TVariables, T>,\n    optimistic: boolean = false\n  ): Unmasked<T> | null {\n    return this.cache.readFragment<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a\n   * specific id returned by `dataIdFromObject` then use `writeFragment`.\n   */\n  public writeQuery<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteQueryOptions<TData, TVariables>\n  ): Reference | undefined {\n    const ref = this.cache.writeQuery<TData, TVariables>(options);\n\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n\n    return ref;\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  public writeFragment<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteFragmentOptions<TData, TVariables>\n  ): Reference | undefined {\n    const ref = this.cache.writeFragment<TData, TVariables>(options);\n\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n\n    return ref;\n  }\n\n  public __actionHookForDevTools(cb: () => any) {\n    this.devToolsHookCb = cb;\n  }\n\n  public __requestRaw(\n    payload: GraphQLRequest\n  ): Observable<FormattedExecutionResult> {\n    return execute(this.link, payload);\n  }\n\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. You’ve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public resetStore(): Promise<ApolloQueryResult<any>[] | null> {\n    return Promise.resolve()\n      .then(() =>\n        this.queryManager.clearStore({\n          discardWatches: false,\n        })\n      )\n      .then(() => Promise.all(this.resetStoreCallbacks.map((fn) => fn())))\n      .then(() => this.reFetchObservableQueries());\n  }\n\n  /**\n   * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n   * not refetch any active queries.\n   */\n  public clearStore(): Promise<any[]> {\n    return Promise.resolve()\n      .then(() =>\n        this.queryManager.clearStore({\n          discardWatches: true,\n        })\n      )\n      .then(() => Promise.all(this.clearStoreCallbacks.map((fn) => fn())));\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * reset. `onResetStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onResetStore(cb: () => Promise<any>): () => void {\n    this.resetStoreCallbacks.push(cb);\n    return () => {\n      this.resetStoreCallbacks = this.resetStoreCallbacks.filter(\n        (c) => c !== cb\n      );\n    };\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * cleared. `onClearStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onClearStore(cb: () => Promise<any>): () => void {\n    this.clearStoreCallbacks.push(cb);\n    return () => {\n      this.clearStoreCallbacks = this.clearStoreCallbacks.filter(\n        (c) => c !== cb\n      );\n    };\n  }\n\n  /**\n   * Refetches all of your active queries.\n   *\n   * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   */\n  public reFetchObservableQueries(\n    includeStandby?: boolean\n  ): Promise<ApolloQueryResult<any>[]> {\n    return this.queryManager.reFetchObservableQueries(includeStandby);\n  }\n\n  /**\n   * Refetches specified active queries. Similar to \"reFetchObservableQueries()\" but with a specific list of queries.\n   *\n   * `refetchQueries()` is useful for use cases to imperatively refresh a selection of queries.\n   *\n   * It is important to remember that `refetchQueries()` *will* refetch specified active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public refetchQueries<\n    TCache extends ApolloCache<any> = ApolloCache<TCacheShape>,\n    TResult = Promise<ApolloQueryResult<any>>,\n  >(\n    options: RefetchQueriesOptions<TCache, TResult>\n  ): RefetchQueriesResult<TResult> {\n    const map = this.queryManager.refetchQueries(\n      options as RefetchQueriesOptions<ApolloCache<TCacheShape>, TResult>\n    );\n    const queries: ObservableQuery<any>[] = [];\n    const results: InternalRefetchQueriesResult<TResult>[] = [];\n\n    map.forEach((result, obsQuery) => {\n      queries.push(obsQuery);\n      results.push(result);\n    });\n\n    const result = Promise.all<TResult>(\n      results as TResult[]\n    ) as RefetchQueriesResult<TResult>;\n\n    // In case you need the raw results immediately, without awaiting\n    // Promise.all(results):\n    result.queries = queries;\n    result.results = results;\n\n    // If you decide to ignore the result Promise because you're using\n    // result.queries and result.results instead, you shouldn't have to worry\n    // about preventing uncaught rejections for the Promise.all result.\n    result.catch((error) => {\n      invariant.debug(\n        `In client.refetchQueries, Promise.all promise rejected with error %o`,\n        error\n      );\n    });\n\n    return result;\n  }\n\n  /**\n   * Get all currently active `ObservableQuery` objects, in a `Map` keyed by\n   * query ID strings.\n   *\n   * An \"active\" query is one that has observers and a `fetchPolicy` other than\n   * \"standby\" or \"cache-only\".\n   *\n   * You can include all `ObservableQuery` objects (including the inactive ones)\n   * by passing \"all\" instead of \"active\", or you can include just a subset of\n   * active queries by passing an array of query names or DocumentNode objects.\n   */\n  public getObservableQueries(\n    include: RefetchQueriesInclude = \"active\"\n  ): Map<string, ObservableQuery<any>> {\n    return this.queryManager.getObservableQueries(include);\n  }\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public extract(optimistic?: boolean): TCacheShape {\n    return this.cache.extract(optimistic);\n  }\n\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public restore(serializedState: TCacheShape): ApolloCache<TCacheShape> {\n    return this.cache.restore(serializedState);\n  }\n\n  /**\n   * Add additional local resolvers.\n   */\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.addResolvers(resolvers);\n  }\n\n  /**\n   * Set (override existing) local resolvers.\n   */\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.setResolvers(resolvers);\n  }\n\n  /**\n   * Get all registered local resolvers.\n   */\n  public getResolvers() {\n    return this.localState.getResolvers();\n  }\n\n  /**\n   * Set a custom local state fragment matcher.\n   */\n  public setLocalStateFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.localState.setFragmentMatcher(fragmentMatcher);\n  }\n\n  /**\n   * Define a new ApolloLink (or link chain) that Apollo Client will use.\n   */\n  public setLink(newLink: ApolloLink) {\n    this.link = this.queryManager.link = newLink;\n  }\n\n  public get defaultContext() {\n    return this.queryManager.defaultContext;\n  }\n\n  /**\n   * @experimental\n   * This is not a stable API - it is used in development builds to expose\n   * information to the DevTools.\n   * Use at your own risk!\n   * For more details, see [Memory Management](https://www.apollographql.com/docs/react/caching/memory-management/#measuring-cache-usage)\n   *\n   * @example\n   * ```ts\n   * console.log(client.getMemoryInternals())\n   * ```\n   * Logs output in the following JSON format:\n   * @example\n   * ```json\n   *{\n   *  limits:     {\n   *    parser: 1000,\n   *    canonicalStringify: 1000,\n   *    print: 2000,\n   *    'documentTransform.cache': 2000,\n   *    'queryManager.getDocumentInfo': 2000,\n   *    'PersistedQueryLink.persistedQueryHashes': 2000,\n   *    'fragmentRegistry.transform': 2000,\n   *    'fragmentRegistry.lookup': 1000,\n   *    'fragmentRegistry.findFragmentSpreads': 4000,\n   *    'cache.fragmentQueryDocuments': 1000,\n   *    'removeTypenameFromVariables.getVariableDefinitions': 2000,\n   *    'inMemoryCache.maybeBroadcastWatch': 5000,\n   *    'inMemoryCache.executeSelectionSet': 10000,\n   *    'inMemoryCache.executeSubSelectedArray': 5000\n   *  },\n   *  sizes: {\n   *    parser: 26,\n   *    canonicalStringify: 4,\n   *    print: 14,\n   *    addTypenameDocumentTransform: [\n   *      {\n   *        cache: 14,\n   *      },\n   *    ],\n   *    queryManager: {\n   *      getDocumentInfo: 14,\n   *      documentTransforms: [\n   *        {\n   *          cache: 14,\n   *        },\n   *        {\n   *          cache: 14,\n   *        },\n   *      ],\n   *    },\n   *    fragmentRegistry: {\n   *      findFragmentSpreads: 34,\n   *      lookup: 20,\n   *      transform: 14,\n   *    },\n   *    cache: {\n   *      fragmentQueryDocuments: 22,\n   *    },\n   *    inMemoryCache: {\n   *      executeSelectionSet: 4345,\n   *      executeSubSelectedArray: 1206,\n   *      maybeBroadcastWatch: 32,\n   *    },\n   *    links: [\n   *      {\n   *        PersistedQueryLink: {\n   *          persistedQueryHashes: 14,\n   *        },\n   *      },\n   *      {\n   *        removeTypenameFromVariables: {\n   *          getVariableDefinitions: 14,\n   *        },\n   *      },\n   *    ],\n   *  },\n   * }\n   *```\n   */\n  public getMemoryInternals?: typeof getApolloClientMemoryInternals;\n}\n\nif (__DEV__) {\n  ApolloClient.prototype.getMemoryInternals = getApolloClientMemoryInternals;\n}\n", "import { parse } from 'graphql';\n\nimport {\n  DocumentNode,\n  DefinitionNode,\n  Location,\n} from 'graphql/language/ast';\n\n// A map docString -> graphql document\nconst docCache = new Map<string, DocumentNode>();\n\n// A map fragmentName -> [normalized source]\nconst fragmentSourceMap = new Map<string, Set<string>>();\n\nlet printFragmentWarnings = true;\nlet experimentalFragmentVariables = false;\n\n// Strip insignificant whitespace\n// Note that this could do a lot more, such as reorder fields etc.\nfunction normalize(string: string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\n\nfunction cacheKeyFromLoc(loc: Location) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\n\n// Take a unstripped parsed document (query/mutation or even fragment), and\n// check all fragment definitions, checking for name->source uniqueness.\n// We also want to make sure only unique fragments exist in the document.\nfunction processFragments(ast: DocumentNode) {\n  const seenKeys = new Set<string>();\n  const definitions: DefinitionNode[] = [];\n\n  ast.definitions.forEach(fragmentDefinition => {\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc!);\n\n      // We know something about this fragment\n      let sourceKeySet = fragmentSourceMap.get(fragmentName)!;\n      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n        // this is a problem because the app developer is trying to register another fragment with\n        // the same name as one previously registered. So, we tell them about it.\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n            + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n            + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n      } else if (!sourceKeySet) {\n        fragmentSourceMap.set(fragmentName, sourceKeySet = new Set);\n      }\n\n      sourceKeySet.add(sourceKey);\n\n      if (!seenKeys.has(sourceKey)) {\n        seenKeys.add(sourceKey);\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  });\n\n  return {\n    ...ast,\n    definitions,\n  };\n}\n\nfunction stripLoc(doc: DocumentNode) {\n  const workSet = new Set<Record<string, any>>(doc.definitions);\n\n  workSet.forEach(node => {\n    if (node.loc) delete node.loc;\n    Object.keys(node).forEach(key => {\n      const value = node[key];\n      if (value && typeof value === 'object') {\n        workSet.add(value);\n      }\n    });\n  });\n\n  const loc = doc.loc as Record<string, any>;\n  if (loc) {\n    delete loc.startToken;\n    delete loc.endToken;\n  }\n\n  return doc;\n}\n\nfunction parseDocument(source: string) {\n  var cacheKey = normalize(source);\n  if (!docCache.has(cacheKey)) {\n    const parsed = parse(source, {\n      experimentalFragmentVariables,\n      allowLegacyFragmentVariables: experimentalFragmentVariables,\n    } as any);\n    if (!parsed || parsed.kind !== 'Document') {\n      throw new Error('Not a valid GraphQL document.');\n    }\n    docCache.set(\n      cacheKey,\n      // check that all \"new\" fragments inside the documents are consistent with\n      // existing fragments of the same name\n      stripLoc(processFragments(parsed)),\n    );\n  }\n  return docCache.get(cacheKey)!;\n}\n\n// XXX This should eventually disallow arbitrary string interpolation, like Relay does\nexport function gql(\n  literals: string | readonly string[],\n  ...args: any[]\n) {\n\n  if (typeof literals === 'string') {\n    literals = [literals];\n  }\n\n  let result = literals[0];\n\n  args.forEach((arg, i) => {\n    if (arg && arg.kind === 'Document') {\n      result += arg.loc.source.body;\n    } else {\n      result += arg;\n    }\n    result += literals[i + 1];\n  });\n\n  return parseDocument(result);\n}\n\nexport function resetCaches() {\n  docCache.clear();\n  fragmentSourceMap.clear();\n}\n\nexport function disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\n\nexport function enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\n\nexport function disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\n\nconst extras = {\n  gql,\n  resetCaches,\n  disableFragmentWarnings,\n  enableExperimentalFragmentVariables,\n  disableExperimentalFragmentVariables,\n};\n\nexport namespace gql {\n  export const {\n    gql,\n    resetCaches,\n    disableFragmentWarnings,\n    enableExperimentalFragmentVariables,\n    disableExperimentalFragmentVariables,\n  } = extras;\n}\n\ngql.default = gql;\n\nexport default gql;\n", "/* Core */\n\nexport type { ApolloClientOptions, DefaultOptions } from \"./ApolloClient.js\";\nexport { ApolloClient, mergeOptions } from \"./ApolloClient.js\";\nexport type { FetchMoreOptions } from \"./ObservableQuery.js\";\nexport { ObservableQuery } from \"./ObservableQuery.js\";\nexport type {\n  QueryOptions,\n  WatchQueryOptions,\n  MutationOptions,\n  SubscriptionOptions,\n  FetchPolicy,\n  WatchQueryFetchPolicy,\n  MutationFetchPolicy,\n  RefetchWritePolicy,\n  ErrorPolicy,\n  FetchMoreQueryOptions,\n  SubscribeToMoreOptions,\n  SubscribeToMoreFunction,\n  UpdateQueryMapFn,\n  UpdateQueryOptions,\n  SubscribeToMoreUpdateQueryFn,\n} from \"./watchQueryOptions.js\";\nexport { NetworkStatus, isNetworkRequestSettled } from \"./networkStatus.js\";\nexport type * from \"./types.js\";\nexport type { Resolver, FragmentMatcher } from \"./LocalState.js\";\nexport { isApolloError, ApolloError } from \"../errors/index.js\";\n/* Cache */\n\nexport type {\n  // All the exports (types) from ../cache, minus cacheSlot,\n  // which we want to keep semi-private.\n  Transaction,\n  DataProxy,\n  InMemoryCacheConfig,\n  ReactiveVar,\n  TypePolicies,\n  TypePolicy,\n  FieldPolicy,\n  FieldReadFunction,\n  FieldMergeFunction,\n  FieldFunctionOptions,\n  PossibleTypesMap,\n  WatchFragmentOptions,\n  WatchFragmentResult,\n} from \"../cache/index.js\";\nexport {\n  Cache,\n  ApolloCache,\n  InMemoryCache,\n  MissingFieldError,\n  defaultDataIdFromObject,\n  makeVar,\n} from \"../cache/index.js\";\n\nexport type * from \"../cache/inmemory/types.js\";\n\n/* Link */\n\nexport * from \"../link/core/index.js\";\nexport * from \"../link/http/index.js\";\nexport type { ServerError } from \"../link/utils/index.js\";\nexport {\n  fromError,\n  toPromise,\n  fromPromise,\n  throwServerError,\n} from \"../link/utils/index.js\";\n\n/* Masking */\nexport type {\n  DataMasking,\n  FragmentType,\n  Masked,\n  MaskedDocumentNode,\n  MaybeMasked,\n  Unmasked,\n} from \"../masking/index.js\";\n\n/* Utilities */\n\nexport type {\n  DocumentTransformCacheKey,\n  Observer,\n  ObservableSubscription,\n  Reference,\n  StoreObject,\n} from \"../utilities/index.js\";\nexport {\n  DocumentTransform,\n  Observable,\n  isReference,\n  makeReference,\n} from \"../utilities/index.js\";\n\n/* Supporting */\n\n// The verbosity of invariant.{log,warn,error} can be controlled globally\n// (for anyone using the same ts-invariant package) by passing \"log\",\n// \"warn\", \"error\", or \"silent\" to setVerbosity (\"log\" is the default).\n// Note that all invariant.* logging is hidden in production.\nimport { setVerbosity } from \"ts-invariant\";\nexport { setVerbosity as setLogVerbosity };\nsetVerbosity(__DEV__ ? \"log\" : \"silent\");\n\n// Note that importing `gql` by itself, then destructuring\n// additional properties separately before exporting, is intentional.\n// Due to the way the `graphql-tag` library is setup, certain bundlers\n// can't find the properties added to the exported `gql` function without\n// additional guidance (e.g. Rollup - see\n// https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module).\n// Instead of having people that are using bundlers with `@apollo/client` add\n// extra bundler config to help `graphql-tag` exports be found (which would be\n// awkward since they aren't importing `graphql-tag` themselves), this\n// workaround of pulling the extra properties off the `gql` function,\n// then re-exporting them separately, helps keeps bundlers happy without any\n// additional config changes.\nexport {\n  gql,\n  resetCaches,\n  disableFragmentWarnings,\n  enableExperimentalFragmentVariables,\n  disableExperimentalFragmentVariables,\n} from \"graphql-tag\";\n"],
  "mappings": "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",
  "names": ["print", "_a", "version", "_b", "_c", "parseError", "HttpLink", "hasOwnProperty", "init_lib", "init_lib", "init_utils", "init_lib", "init_utils", "fragment", "init_utils", "init_lib", "init_utils", "init_utils", "init_lib", "ApolloCache", "from", "Cache", "MissingFieldError", "cache", "init_lib", "init_lib", "EntityStore", "from", "CacheGroup", "Root", "Layer", "Stump", "ObjectCanon", "init_lib", "StoreReader", "result", "_a", "from", "d", "from", "Policies", "existing", "incoming", "supertypeSet", "init_lib", "StoreWriter", "_a", "dataId", "context", "value", "selectionSet", "from", "init_lib", "InMemoryCache", "_a", "init_lib", "FragmentRegistry", "init_cache", "NetworkStatus", "hasOwnProperty", "init_lib", "ObservableQuery", "_a", "updateQuery", "info", "init_lib", "QueryInfo", "diff", "hasOwnProperty", "init_lib", "init_cache", "QueryManager", "hasClientExports", "cache", "diff", "DELETE", "result", "variables", "sourcesWithInfo", "_a", "networkStatus", "data", "init_cache", "LocalState", "execute", "_a", "node", "ApolloClient", "defaultOptions", "result", "normalize", "init_core", "init_cache", "init_lib"]
}
